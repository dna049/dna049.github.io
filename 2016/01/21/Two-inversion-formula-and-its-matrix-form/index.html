<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 两类反演公式及其矩阵形式 · 0.肆玖</title><meta name="description" content="两类反演公式及其矩阵形式 - dna049"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/dna049" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/About" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">两类反演公式及其矩阵形式</h1><div class="post-time">2016年1月21日</div><div class="post-content"><p>在上一篇<a href="http://dna049.com/2016/01/20/Dirichlet-product-of-number-function/">博文</a>中，介绍过数论中的 Mobius 反演公式，让我想起了另一个经典的反演公式－－－二项式反演公式。然而本质上反演公式就是矩阵求逆的过程。只是他们的逆有很简单的形式，因此就有了这样两个反演公式而已。<br><a id="more"></a></p>
<p>Mobius 反演在上一篇博客中已经提及，现在着重提一下二项式反演公式，这个公式让我在2014年ACM－ICPC亚洲区域赛西安站拿银，当时<a href="2014acmicpc-asia-xian-regional-contest.pdf">F题</a>答案直接算需要$n^3$复杂度，而利用二项式反演公式后，可以在$n^2$复杂度内完美解决。1A过题，感觉超爽。</p>
<h3 id="u53CD_u6F14_u516C_u5F0F_u4E0E_u5176_u77E9_u9635_u5F62_u5F0F"><a href="#u53CD_u6F14_u516C_u5F0F_u4E0E_u5176_u77E9_u9635_u5F62_u5F0F" class="headerlink" title="反演公式与其矩阵形式"></a>反演公式与其矩阵形式</h3><p>由<br><span>$$\sum _{r = 1} ^n a _{n,r} f(r) 
= g(n)$$</span><!-- Has MathJax --><br>其中$g(n)$已知，解出$f(n)$<br><span>$$f(n) = 
\sum _{r = 1} ^n b _{n,r} g(r)$$</span><!-- Has MathJax --><br>为其反演公式，也称上面两式互为反演公式。</p>
<p>令<br><span>$$A = \left( \begin{matrix} a _{11} &amp; &amp;  \\
a _{21} &amp; a _{22} &amp; \\
\cdots &amp; \cdots &amp; \ddots &amp; \\
a _{n1} &amp; a _{n2} &amp; \cdots &amp; a _{nn} \\
\end{matrix} \right) 
\qquad
B = \left( \begin{matrix} b _{11} &amp; &amp;  \\
b _{21} &amp; b _{22} &amp; \\
\cdots &amp; \cdots &amp; \ddots &amp; \\
b _{n1} &amp; b _{n2} &amp; \cdots &amp; b _{nn} \\
\end{matrix} \right)$$</span><!-- Has MathJax --></p>
<p>则上述反演公式本质上就是求矩阵$A$的逆$B$.</p>
<h3 id="u4E8C_u9879_u5F0F_u53CD_u6F14_u516C_u5F0F"><a href="#u4E8C_u9879_u5F0F_u53CD_u6F14_u516C_u5F0F" class="headerlink" title="二项式反演公式"></a>二项式反演公式</h3><p>若<br><span>$$g(n) = 
\sum _{r = s} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) f(r)$$</span><!-- Has MathJax --><br>其中 $s \geq 0$ 则<br><span>$$f(n) 
= \sum _{r = s} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) g(r)$$</span><!-- Has MathJax --></p>
<p>Proof: 要证明反演公式，只需证明，对应的矩阵 $A$ 和 $B$ 互为逆即可. 令 $C = A*B$ 则<br><span>$$\begin{align}
c _{ij} = \sum _{k=1} ^n a _{ik} b _{kj} &amp; = \sum _{k =j} ^ i \left(\begin{matrix} i \\ k\end{matrix}\right) (-1)^{k-j} \left(\begin{matrix} k \\ j\end{matrix}\right) = 
\sum _{k=0} ^ {i-j} \left(\begin{matrix} i \\ k+j\end{matrix}\right) (-1)^k \left(\begin{matrix} k+j \\ j\end{matrix}\right) \\
&amp; = \left(\begin{matrix} i \\ j\end{matrix}\right) \sum _{k=0} ^ {i-j} (-1)^k \left(\begin{matrix} i-j \\ k\end{matrix}\right) = \left\{ \begin{array}{ll} 1,&amp; i=j \\  0,&amp; i&gt;j\end{array} \right.
\end{align}$$</span><!-- Has MathJax --><br>证毕。</p>
<h3 id="u4E24_u7C7B_u53CD_u6F14_u516C_u5F0F_u7684_u5E94_u7528"><a href="#u4E24_u7C7B_u53CD_u6F14_u516C_u5F0F_u7684_u5E94_u7528" class="headerlink" title="两类反演公式的应用"></a>两类反演公式的应用</h3><p>这两类反演公式在组合数学和数论中都有诸多应用，这里简单的提几个。</p>
<h5 id="28_u9519_u6392_u95EE_u9898_29__u5728__24n_24__u4E2A_u6570_u5B57__241_2C2_2C_5Cdots_2Cn_24__u5F62_u6210__24n_21_24__u4E2A_u6392_u5217__24a_1a_2__5Cdots_a_n_24__u4E2D_u6EE1_u8DB3__24a_i__5Cneq_i_24__u7684_u6392_u5217_u6709_u591A_u5C11_u4E2A_uFF1F"><a href="#28_u9519_u6392_u95EE_u9898_29__u5728__24n_24__u4E2A_u6570_u5B57__241_2C2_2C_5Cdots_2Cn_24__u5F62_u6210__24n_21_24__u4E2A_u6392_u5217__24a_1a_2__5Cdots_a_n_24__u4E2D_u6EE1_u8DB3__24a_i__5Cneq_i_24__u7684_u6392_u5217_u6709_u591A_u5C11_u4E2A_uFF1F" class="headerlink" title="(错排问题) 在 $n$ 个数字 $1,2,\dots,n$ 形成 $n!$ 个排列 $a_1a_2 \dots a_n$ 中满足 $a_i \neq i$ 的排列有多少个？"></a>(错排问题) 在 $n$ 个数字 $1,2,\dots,n$ 形成 $n!$ 个排列 $a_1a_2 \dots a_n$ 中满足 $a_i \neq i$ 的排列有多少个？</h5><p>不妨设答案为 <span>$D_n$</span><!-- Has MathJax --> ,则可以看出恰好有 $r$ 个 <span>$a_i =i$</span><!-- Has MathJax -->的排列数为<span>$\left(\begin{matrix} n \\ r\end{matrix}\right) D_{n-r}$</span><!-- Has MathJax -->,因此<br><span>$$n! =
\sum _{r = 0} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) D_{n-r}$$</span><!-- Has MathJax --><br>因此<br><span>$$D_n ＝ 
\sum _{r = 0} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) r! = n! \sum _{r=0} ^n \frac{(-1)^r}{r!}$$</span><!-- Has MathJax --></p>
<h5 id="28_u6EE1_u5C04_u4E2A_u6570_29__u6C42m_u5143_u96C6A_u5230n_u5143_u96C6B_u7684_u6EE1_u8EAB_u7684_u4E2A_u6570g_28m_2Cn_29"><a href="#28_u6EE1_u5C04_u4E2A_u6570_29__u6C42m_u5143_u96C6A_u5230n_u5143_u96C6B_u7684_u6EE1_u8EAB_u7684_u4E2A_u6570g_28m_2Cn_29" class="headerlink" title="(满射个数) 求m元集A到n元集B的满身的个数g(m,n)"></a>(满射个数) 求m元集A到n元集B的满身的个数g(m,n)</h5><p>类似于错排的思路，我们有<br><span>$$n^m =
\sum _{r = 1} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) g(m,r)$$</span><!-- Has MathJax --><br>于是<br><span>$$g(m,n) = 
\sum _{r = 1} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) r^m$$</span><!-- Has MathJax --></p>
<h5 id="Mobius_u53CD_u6F14_u5728_u53EF_u91CD_u590D_u5706_u6392_u5217_u4E2D_u6709_u91CD_u8981_u5E94_u7528_uFF0C_u8FD9_u91CC_u5C31_u4E0D_u8BF4_u4E86_u3002"><a href="#Mobius_u53CD_u6F14_u5728_u53EF_u91CD_u590D_u5706_u6392_u5217_u4E2D_u6709_u91CD_u8981_u5E94_u7528_uFF0C_u8FD9_u91CC_u5C31_u4E0D_u8BF4_u4E86_u3002" class="headerlink" title="Mobius反演在可重复圆排列中有重要应用，这里就不说了。"></a>Mobius反演在可重复圆排列中有重要应用，这里就不说了。</h5><h3 id="Mobius__u77E9_u9635"><a href="#Mobius__u77E9_u9635" class="headerlink" title="Mobius 矩阵"></a>Mobius 矩阵</h3><p>由 Mobius 反演公式对应的矩阵我们有,若<br><span>$$a _{ij} = \left\{ \begin{array}{cc} 1, &amp; j|i \\
0, &amp; else. \end{array} \right.$$</span><!-- Has MathJax --><br>则，其逆矩阵为<br><span>$$b _{ij} = \left\{ \begin{array}{cc} \mu (\frac{i}{j}), &amp; j|i \\
0, &amp; else. \end{array} \right.$$</span><!-- Has MathJax --></p>
<p>本文参考了<a href="http://www.douban.com/note/480023639/?type=like" target="_blank" rel="external">豆瓣</a>和<a href="http://wenku.baidu.com/link?url=0m3D-588KfEUvocmKGoW5X4z5SHrEKVOaqfLoTeRtJaJcG6oDEUh2QEbJmNa1p2OTkqFLCqhfhM-RsoOI2fkutlqL9q3xgJhIAic4HumI5W" target="_blank" rel="external">百度文库</a>以及 许胤龙，孙淑玲《组合数学引论》。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/01/21/Formula-of-pow-sum-of-natural-number/" class="prev">PREV</a><a href="/2016/01/20/Dirichlet-product-of-number-function/" class="next">NEXT</a></div><div data-thread-key="2016/01/21/Two-inversion-formula-and-its-matrix-form/" data-title="两类反演公式及其矩阵形式" data-url="http://dna049.com/2016/01/21/Two-inversion-formula-and-its-matrix-form/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"dna049"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://dna049.com">dna049</a>, unless otherwise noted.</p></div></footer></div><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?699b245cef6684fc1e306cd9cc1cb26a";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body></html>