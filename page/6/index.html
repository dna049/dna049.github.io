<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 0.肆玖</title><meta name="description" content="dna049 | math | C++ | hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/dna049" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/About" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/12/20/Open-and-Close-set-in-topology-vector-space/" class="post-title-link">拓扑线性空间中的开集和闭集</a></h2><div class="post-time">2015年12月20日</div><div class="post-content"><p>在复习泛函分析的时候，因为很多结论可以推广到更为一般的情况，因此就看了刘培德先生编著的《拓扑线性空间与算子谱理论》这本书。然后在书中读到了有关开集和闭集的一些性质，在此总结一下，先叙述一下结论。<br>在拓扑线性空间中，</p>
<ol>
<li>若A是开集，B是任意集合，则A+B是开集。</li>
<li>若A是闭集，B是闭集，则A+B不一定为闭集。</li>
<li>若A是紧集，B是闭集，则A+B是闭集。</div><a href="/2015/12/20/Open-and-Close-set-in-topology-vector-space/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/12/17/Perron-Frobenius Theory/" class="post-title-link">Perron-Frobenius理论</a></h2><div class="post-time">2015年12月17日</div><div class="post-content"><p>1907年O.Perron发现正矩阵的谱有特别有趣的性质。G.Frobenius在1908-1912年间将Perron的工作推广到不可约非负矩阵的情形，并得到了新的进一步结果。Ferron-Frobenius理论有很多证明方式，下面介绍H.Wielandt的优美证明。<br></div><a href="/2015/12/17/Perron-Frobenius Theory/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/12/16/Shur-Theorem/" class="post-title-link">Shur定理</a></h2><div class="post-time">2015年12月16日</div><div class="post-content"><p>在研究一个数学对象时，我们经常会对它进行分类。比如我们通常把数分为：实数，虚数；实数又分成有理数，无理数；当然也有按照正负来分的。还有整数分成素数（也叫质数）和合数，等等。现在我们谈谈矩阵的分类，以下默认矩阵是方的。<br></div><a href="/2015/12/16/Shur-Theorem/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/12/16/Cayley-Hamilton-Theorem/" class="post-title-link">Cayley-Hamilton定理</a></h2><div class="post-time">2015年12月16日</div><div class="post-content"><p>大一学了矩阵之后,一直很喜欢它，因为它形式简洁优美，又不缺乏技巧，是抽象和具体的桥梁，又有其实用性，成为现代数学最基础的工具之一。个人认为，矩阵中最优美的定理非Cayley-Hamilton定理（矩阵的特征多项式是它的一个化零多项式）莫属了。详细表述和证明如下：</p></div><a href="/2015/12/16/Cayley-Hamilton-Theorem/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/12/16/Example-of-function-only-continue-at-a-point/" class="post-title-link">仅在一点连续的函数例子</a></h2><div class="post-time">2015年12月16日</div><div class="post-content"><p>在一元微积分中，有一个广为人知的结论：一元函数在一点可导，必在该点连续，即可导必连续。</p>
<p>自然会有这样一个问题：</p>
<pre><code>一元函数在一点可导能否推出它在该点的一个小邻域连续呢？
</code></pre><p>这个想法是很自然的，不严格的思考可能会认为应该是对的,但是它并不成立。下面给出一个反例：</p>
<p>\[ f(x) = x^2 D(x) = \left\{<br>\begin{array}{ll}<br>0 &amp; x \in \mathbb{Q} \\<br>x^2 &amp; x \notin \mathbb{Q}<br>\end{array} \right. \]</p>
<p>其中$D(x)$为Dirichlet函数。<br></div><a href="/2015/12/16/Example-of-function-only-continue-at-a-point/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/12/15/Calculater-program/" class="post-title-link">计算器程序</a></h2><div class="post-time">2015年12月15日</div><div class="post-content"><h4 id="u8BA1_u7B97_u5668_u5230_u5904_u90FD_u6709_uFF0C_u6709_u5565_u597D_u5199_u7684_u5462_uFF1F"><a href="#u8BA1_u7B97_u5668_u5230_u5904_u90FD_u6709_uFF0C_u6709_u5565_u597D_u5199_u7684_u5462_uFF1F" class="headerlink" title="计算器到处都有，有啥好写的呢？"></a>计算器到处都有，有啥好写的呢？</h4><p>我们在写程序时，对于长串计算，我们通常直接输入了，让计算机高级语言（例如C++）给我们算就行了。但是，仔细想想这件事其实并不简单。</p>
<pre><code>ps:最处想做这件事的原因是：我在大学想写一个带GUI界面的计算器，就在这里被卡住了。
</code></pre><p>其实这是一个很有名的问题，大家有兴趣可以搜一下 <a href="http://baike.baidu.com/link?url=K67J7hWFkpdwOzjAA-nalFK4JqnnLI5TPtK1Dx7dOBn0P5WhAsq09j0e4qBI590vomEWc0w2gtCFWreeta0gr_">逆波兰式</a><br></div><a href="/2015/12/15/Calculater-program/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/12/15/Complex-code-to-generate-520/" class="post-title-link">产生520的复杂代码</a></h2><div class="post-time">2015年12月15日</div><div class="post-content"><p>想想我当初也是厉害，貌似是在2014年情人节在网吧写的代码，简直强的不行。<br></div><a href="/2015/12/15/Complex-code-to-generate-520/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/12/15/prime-seive/" class="post-title-link">素数筛选</a></h2><div class="post-time">2015年12月15日</div><div class="post-content"><p>判断一个数是否为素数，是一个很古老的问题，这里给出一个素数筛选的函数和调用实例。当然这里也有限制，要求数不能超过1e7。当然适当修改代码或者对于不同的需求可以相应修改达到不同目的。下面代码是提交到hdu2879上排行第一的代码：<br></div><a href="/2015/12/15/prime-seive/" class="read-more">...more</a></article></li></ul></section><footer><div class="paginator"><a href="/page/5/" class="prev">PREV</a><a href="/page/7/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://dna049.com">dna049</a>, unless otherwise noted.</p></div></footer></div><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?699b245cef6684fc1e306cd9cc1cb26a";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body></html>