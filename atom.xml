<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[0.肆玖]]></title>
  <subtitle><![CDATA[原谅我一生放荡不羁是傻逼]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://dna049.com/"/>
  <updated>2016-05-08T13:04:06.000Z</updated>
  <id>http://dna049.com/</id>
  
  <author>
    <name><![CDATA[dna049]]></name>
    <email><![CDATA[dna049@foxmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[C++ Template dna049]]></title>
    <link href="http://dna049.com/2020/02/02/C-Template-dna049/"/>
    <id>http://dna049.com/2020/02/02/C-Template-dna049/</id>
    <published>2020-02-01T18:02:02.000Z</published>
    <updated>2016-05-08T13:04:06.000Z</updated>
    <content type="html"><![CDATA[<p>突然想到在此留点模板貌似是个不错的选择也 0.0</p>
<blockquote>
<p>虽说程序需求千变万化，但是一些短小精湛的函数块还是很值得整理收藏的。<br>在此提醒自己：找到一种慢的解法可能是找到最终解法的一步。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Composed by dna049 at <span class="number">2016</span>-<span class="number">4</span>-<span class="number">10</span> in FDU</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="u901A_u7528_u4EE3_u7801_u5757"><a href="#u901A_u7528_u4EE3_u7801_u5757" class="headerlink" title="通用代码块"></a>通用代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> __int128 ll; <span class="comment">// for g++</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="comment">//1e9+7,1e9+9,1e18+3,1e18+9 are prime</span></span><br><span class="line"><span class="comment">//479&lt;&lt;21|1=1004535809,17&lt;&lt;27|1=2281701377 and g=3</span></span><br><span class="line"><span class="comment">/*------ Welcome to visit blog of dna049: http://dna049.com ------*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line">                   _ooOoo_</span><br><span class="line">                  o8888888o</span><br><span class="line">                  88" . "88</span><br><span class="line">                  (| -_- |)</span><br><span class="line">                  O\  =  /O</span><br><span class="line">               ____/`---'\____</span><br><span class="line">             .'  \\|     |//  `.</span><br><span class="line">            /  \\|||  :  |||//  \</span><br><span class="line">           /  _||||| -:- |||||-  \</span><br><span class="line">           |   | \\\  -  /// |   |</span><br><span class="line">           | \_|  ''\---/''  |   |</span><br><span class="line">           \  .-\__  `-`  ___/-. /</span><br><span class="line">         ___`. .'  /--.--\  `. . __</span><br><span class="line">      ."" '&lt;  `.___\_&lt;|&gt;_/___.'  &gt;'"".</span><br><span class="line">     | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">     \  \ `-.   \_ __\ /__ _/   .-` /  /</span><br><span class="line">======`-.____`-.___\_____/___.-`____.-'======</span><br><span class="line">                   `=---='</span><br><span class="line">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">            佛祖保佑       永无BUG</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="u6570_u8BBA_u7BC7"><a href="#u6570_u8BBA_u7BC7" class="headerlink" title="数论篇"></a>数论篇</h2><h4 id="Greatest_Common_divisor"><a href="#Greatest_Common_divisor" class="headerlink" title="Greatest Common divisor"></a>Greatest Common divisor</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(a&amp;&amp;b&amp;&amp;(a&gt;b?a%=b:b%=a));</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span></span>&#123;	<span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL&amp; x,LL&amp; y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL d=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然用直接 GNU 内建函数 __gcd</p>
<h4 id="u6A21_u4E58_u6CD5_u9006_u5143"><a href="#u6A21_u4E58_u6CD5_u9006_u5143" class="headerlink" title="模乘法逆元"></a>模乘法逆元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a,LL p)</span></span>&#123; <span class="comment">// 0&lt;a&lt;p and gcd(a,p)=1</span>    <span class="keyword">if</span>(a==<span class="number">1</span>)    <span class="keyword">return</span> <span class="number">1</span>;    <span class="keyword">return</span> (p-p/a)*inv(p%a,p)%p;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5FEB_u901F_u6A21_u52A0_u6CD5_u4E58_u6CD5"><a href="#u5FEB_u901F_u6A21_u52A0_u6CD5_u4E58_u6CD5" class="headerlink" title="快速模加法乘法"></a>快速模加法乘法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">pow</span><span class="params">(LL x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    LL r=<span class="number">1</span>;<span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>,x*=x)  <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r*=x;<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;</span><br><span class="line">    LL r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=x*x%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mul_mod</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;	    LL r=<span class="number">0</span>;</span><br><span class="line">	x%=p; n%=p;    <span class="keyword">while</span>(n)&#123;        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;            r+=x;            <span class="keyword">if</span>(r&gt;=m)    r-=m;        &#125;        n&gt;&gt;=<span class="number">1</span>;x&lt;&lt;=<span class="number">1</span>;        <span class="keyword">if</span>(x&gt;=m)    x-=m;    &#125;    <span class="keyword">return</span> r;&#125;<span class="function">LL <span class="title">mul_mod</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;    LL r=<span class="number">0</span>;    <span class="keyword">while</span>(n)&#123;        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=(r+x)%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=(x+x)%p;    &#125;    <span class="keyword">return</span> r;&#125;</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;</span><br><span class="line">    LL r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=mul_mod(r,x,p);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=mul_mod(x,x,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6574_u6570_u5F00_u6839_u53F7"><a href="#u6574_u6570_u5F00_u6839_u53F7" class="headerlink" title="整数开根号"></a>整数开根号</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrt2</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL r = (LL)<span class="built_in">sqrt</span>(x-<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">while</span>(r*r&lt;=x)   ++r;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(r-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrt3</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL r = (LL)cbrt(x-<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">while</span>(r*r*r&lt;=x)   ++r;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(r-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6A21_u6C42_u548C"><a href="#u6A21_u6C42_u548C" class="headerlink" title="模求和"></a>模求和</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LL getSum(LL a,LL n,LL p)&#123;    LL r=0,x=1;    while(n)&#123;        if(n&amp;1) r=(r+x*pow_mod(a,n,p))%p;        n&gt;&gt;=1;        x=x*(1+pow_mod(a,n,p))%p;    &#125;    return r;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u79BB_u6563_u5BF9_u6570"><a href="#u79BB_u6563_u5BF9_u6570" class="headerlink" title="离散对数"></a><a href="http://blog.miskcoo.com/2015/05/discrete-logarithm-problem" target="_blank" rel="external">离散对数</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">baby_step_giant_step</span><span class="params">(LL a,LL b,LL p)</span></span>&#123; <span class="comment">// a^x = b mod p</span></span><br><span class="line">    a%=p,b%=p;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>)    <span class="keyword">return</span> b%p?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">1</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL cnt = <span class="number">0</span>,t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL g=__gcd(a,p);g!=<span class="number">1</span>;g=__gcd(a,p))&#123;</span><br><span class="line">        <span class="keyword">if</span>(b%g) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        p/=g,b/=g,t=t*(a/g)%p;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">if</span>(b==t)    <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;LL,LL&gt; hash;</span><br><span class="line">    LL m = LL(<span class="built_in">sqrt</span>(p+<span class="number">0.1</span>) + <span class="number">1</span>);</span><br><span class="line">    LL base = b;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">0</span>;i!=m;++i)&#123;</span><br><span class="line">        hash[base] = i;</span><br><span class="line">        base = base*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    base = pow_mod(a,m,p);</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;++i)&#123;</span><br><span class="line">        t=t*base%p;</span><br><span class="line">        <span class="keyword">if</span>(hash.count(t))   <span class="keyword">return</span> i*m-hash[t]+cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6A21_u7D20_u6570_u5F00_u6839_u53F7"><a href="#u6A21_u7D20_u6570_u5F00_u6839_u53F7" class="headerlink" title="模素数开根号"></a>模素数开根号</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LL modsqrt(LL a,LL p)&#123;  // find x s.t x*x=a mod p;</span><br><span class="line">    if((a%=p)==0)   return 0;</span><br><span class="line">    if(p==2)    return (a&amp;1)?1:0;</span><br><span class="line">    LL q=(p-1)&gt;&gt;1;</span><br><span class="line">    if(pow_mod(a,q,p)!=1)   return -1;</span><br><span class="line">    if(q&amp;1) return pow_mod(a,(q+1)&gt;&gt;1,p);</span><br><span class="line">    LL b,cnt=1;</span><br><span class="line">    while(pow_mod(b=rand()%p,q,p)==1);//find a non quadratic residue</span><br><span class="line">    while(!(q&amp;1))   ++cnt,q&gt;&gt;=1;</span><br><span class="line">    b=pow_mod(b,q,p);</span><br><span class="line">    LL x=pow_mod(a,(q+1)&gt;&gt;1,p);</span><br><span class="line">    for(LL s,t=pow_mod(a,q,p);t!=1;cnt=s)&#123; //keep x*x=t*a;t^&#123;2^&#123;cnt-1&#125;&#125;=1</span><br><span class="line">        for(s=1;s&lt;cnt&amp;&amp;pow_mod(t,1&lt;&lt;s,p)!=1;++s);</span><br><span class="line">        LL d=pow_mod(b,1&lt;&lt;(cnt-s-1),p);</span><br><span class="line">        x=(x*d)%p;b=d*d%p;t=t*b%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6A21_u7D20_u6570_u5E42_u5F00_u65B9"><a href="#u6A21_u7D20_u6570_u5E42_u5F00_u65B9" class="headerlink" title="模素数幂开方"></a>模素数幂开方</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">LL mod_sqrt_p(LL a,LL <span class="keyword">n</span>,LL p,int k)&#123;<span class="comment">//find x s.t x*x=a mod p^k where (a,p)=1,p&gt;2</span></span><br><span class="line">    LL q = (<span class="keyword">n</span>/p)*((p-1)&gt;&gt;1);</span><br><span class="line">    <span class="keyword">if</span>(pow_mod(a,q,<span class="keyword">n</span>)!=1)   <span class="keyword">return</span> -1;</span><br><span class="line">    <span class="keyword">if</span>(q&amp;1) <span class="keyword">return</span> pow_mod(a,(q+1)&gt;&gt;1,<span class="keyword">n</span>);</span><br><span class="line">    LL b,cnt=1;</span><br><span class="line">    <span class="keyword">while</span>(pow_mod(b=rand()%<span class="keyword">n</span>,q,<span class="keyword">n</span>)==1);<span class="comment">//find a non quadratic residue</span></span><br><span class="line">    <span class="keyword">while</span>(!(q&amp;1))   ++cnt,q&gt;&gt;=1;</span><br><span class="line">    b=pow_mod(b,q,<span class="keyword">n</span>);</span><br><span class="line">    LL x=pow_mod(a,(q+1)&gt;&gt;1,<span class="keyword">n</span>);</span><br><span class="line">    <span class="keyword">for</span>(LL s,t=pow_mod(a,q,<span class="keyword">n</span>);t!=1;cnt=s)&#123;<span class="comment">// keep x*x=t*a;t^&#123;2^&#123;cnt-1&#125;&#125;=1</span></span><br><span class="line">        <span class="keyword">for</span>(s=1;s&lt;cnt&amp;&amp;pow_mod(t,1&lt;&lt;s,<span class="keyword">n</span>)!=1;++s);</span><br><span class="line">        LL <span class="keyword">d</span> = pow_mod(b,1&lt;&lt;(cnt-s-1),<span class="keyword">n</span>);</span><br><span class="line">        x=(x*<span class="keyword">d</span>)%<span class="keyword">n</span>;b=<span class="keyword">d</span>*<span class="keyword">d</span>%<span class="keyword">n</span>;t=t*b%<span class="keyword">n</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">LL pow(LL x,int <span class="keyword">n</span>)&#123;</span><br><span class="line">    LL r=1;<span class="keyword">for</span>(;<span class="keyword">n</span>;<span class="keyword">n</span>&gt;&gt;=1,x*=x)  <span class="keyword">if</span>(<span class="keyword">n</span>&amp;1) r*=x;<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">LL mod_sqrt(LL a,LL p,int k=1)&#123;<span class="comment">//find smallest x&gt;=0 s.t x*x=a mod p^k</span></span><br><span class="line">    <span class="keyword">if</span>(a==0)    <span class="keyword">return</span> 0;</span><br><span class="line">    int ka=0;</span><br><span class="line">    <span class="keyword">while</span>(a%p==0)   a/=p,++ka,--k;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=0)    <span class="keyword">return</span> 0;</span><br><span class="line">    <span class="keyword">if</span>(ka&amp;1)    <span class="keyword">return</span> -1;</span><br><span class="line">    LL <span class="keyword">n</span> = pow(p,k),x;</span><br><span class="line">    <span class="keyword">if</span>(p==2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==1||k==2)  x = a==1?1:-1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a%8!=1)    x=-1;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            x=1;</span><br><span class="line">            <span class="keyword">for</span>(int i=4;i&lt;=k;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>( (x*x)%(1&lt;&lt;i) == a%(1&lt;&lt;i))   <span class="keyword">continue</span>;</span><br><span class="line">                x+=1&lt;&lt;(i-2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>   x = mod_sqrt_p(a,<span class="keyword">n</span>,p,k);</span><br><span class="line">    <span class="keyword">return</span> x==-1?-1:pow(p,ka&gt;&gt;1)*(x&lt;<span class="keyword">n</span>-x?x:<span class="keyword">n</span>-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于模一般的 $n$，先素因子分解分别求出答案，然后用中国剩余定理求最终解。</p>
</blockquote>
<h4 id="u7EC4_u5408_u6570"><a href="#u7EC4_u5408_u6570" class="headerlink" title="组合数"></a>组合数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">LL C(int n,int m)&#123;</span><br><span class="line">    if(n&lt;m) return 0;</span><br><span class="line">    LL ans = 1;</span><br><span class="line">    for(int i=n;i+m&gt;n;--i)&#123;</span><br><span class="line">        ans = ans*i/(n-i+1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">const int N = 12;</span><br><span class="line">void get_C()&#123;  </span><br><span class="line">    C[0][0]=C[1][0]=C[1][1]=1;  </span><br><span class="line">    for(int i=2;i&lt;=N;++i)&#123;  </span><br><span class="line">        c[i][0]=c[i][i]=1;  </span><br><span class="line">        for(int j=1;j&lt;i;++j)&#123;</span><br><span class="line">        	c[i][j]=c[i-1][j]+c[i-1][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL f[N]; // can add invf[N] for speed</span><br><span class="line">LL Lucas(LL n, LL m, LL p) &#123; // C(n,m)%p,f[n]=n!%p</span><br><span class="line">    LL r = 1;</span><br><span class="line">    while(n&amp;&amp;m)&#123;</span><br><span class="line">        LL np=n%p,mp=m%p;</span><br><span class="line">        if(np&lt;mp)   return 0;</span><br><span class="line">        r = r*f[np]%p*inv(f[mp]*f[np-mp]%p,p)%p;</span><br><span class="line">        n/=p,m/=p;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6709_u7406_u6570_u8F6C_u5316_u6210_u5C0F_u6570"><a href="#u6709_u7406_u6570_u8F6C_u5316_u6210_u5C0F_u6570" class="headerlink" title="有理数转化成小数"></a>有理数转化成小数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">rational</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">string</span> r;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;<span class="number">0</span>) n=-n,m=-m;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        n=-n;</span><br><span class="line">        r.push_back(<span class="string">'-'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = n/m;    <span class="comment">// get the integer part of n/m</span></span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>)    r.push_back(<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        r.push_back(t%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.reserve();</span><br><span class="line">    n%=m;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)    <span class="keyword">return</span> r;</span><br><span class="line">    r.push_back(<span class="string">'.'</span>);</span><br><span class="line">    t = __gcd(n,m);</span><br><span class="line">    n/=t;m/=t;</span><br><span class="line">    <span class="keyword">while</span>(m%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        m/=<span class="number">10</span>;</span><br><span class="line">        r.push_back(n/m+<span class="string">'0'</span>);</span><br><span class="line">        n%=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        m/=<span class="number">2</span>;n*=<span class="number">5</span>;</span><br><span class="line">        r.push_back(n/m+<span class="string">'0'</span>);</span><br><span class="line">        n%=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        m/=<span class="number">5</span>;n*=<span class="number">2</span>;</span><br><span class="line">        r.push_back(n/m+<span class="string">'0'</span>);</span><br><span class="line">        n%=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)    <span class="keyword">return</span> r;</span><br><span class="line">    r.push_back(<span class="string">'('</span>);</span><br><span class="line">    t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        r.push_back(<span class="number">10</span>*n/m+<span class="string">'0'</span>);</span><br><span class="line">        n=<span class="number">10</span>*n%m;</span><br><span class="line">        t=<span class="number">10</span>*t%m;</span><br><span class="line">    &#125;<span class="keyword">while</span>(t!=<span class="number">1</span>);</span><br><span class="line">    r.push_back(<span class="string">')'</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细分析见<a href="http://dna049.com/2016/04/17/Length-of-period-of-fraction/">我的博文</a>。</p>
<h4 id="N_u4EE5_u5185_u7D20_u6570_u7B5B__24O_28n_29_24"><a href="#N_u4EE5_u5185_u7D20_u6570_u7B5B__24O_28n_29_24" class="headerlink" title="N以内素数筛 $O(n)$"></a>N以内素数筛 $O(n)$</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> np[N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    np[<span class="number">0</span>]=np[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) p[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt &amp;&amp; i * p[j] &lt; N; ++j) &#123;</span><br><span class="line">            np[i * p[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>)	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isp</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;N)	<span class="keyword">return</span> !np[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;p[i]*p[i]&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%p[i]==<span class="number">0</span>)	<span class="keyword">return</span> <span class="literal">false</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5927_u7D20_u6570Miller-Rabin_u6982_u7387_u5224_u522B_u6CD5"><a href="#u5927_u7D20_u6570Miller-Rabin_u6982_u7387_u5224_u522B_u6CD5" class="headerlink" title="大素数Miller-Rabin概率判别法"></a><a href="http://blog.miskcoo.com/2014/07/miller-rabin-primality-test" target="_blank" rel="external">大素数Miller-Rabin概率判别法</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Witness</span><span class="params">(LL a,LL n,LL m,<span class="keyword">int</span> t)</span></span>&#123;    LL x=pow_mod(a,m,n);    <span class="keyword">if</span>(x==<span class="number">1</span>||x==n-<span class="number">1</span>)    <span class="keyword">return</span> <span class="literal">false</span>;    <span class="keyword">while</span>(t--)&#123;        x=mul_mod(x,x,n);        <span class="keyword">if</span>(x==n-<span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="function"><span class="keyword">bool</span> <span class="title">Rabin</span><span class="params">(LL n)</span></span>&#123;    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)     <span class="keyword">return</span> <span class="literal">false</span>;    <span class="keyword">if</span>(n==<span class="number">2</span>)    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="keyword">if</span>(!(n&amp;<span class="number">1</span>))  <span class="keyword">return</span> <span class="literal">false</span>;    LL m=n-<span class="number">1</span>;    <span class="keyword">int</span> t=<span class="number">0</span>,cnt=<span class="number">33</span>;    <span class="keyword">while</span>(!(m&amp;<span class="number">1</span>))&#123;        ++t;m&gt;&gt;=<span class="number">1</span>;    &#125;    <span class="keyword">while</span>(cnt--)&#123;        LL a=rand()%(n-<span class="number">1</span>)+<span class="number">1</span>;        <span class="keyword">if</span>(Witness(a,n,m,t))    <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6700_u5C0F_u7D20_u56E0_u5B50_u9884_u5904_u7406"><a href="#u6700_u5C0F_u7D20_u56E0_u5B50_u9884_u5904_u7406" class="headerlink" title="最小素因子预处理"></a>最小素因子预处理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> sp[N],p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spf</span><span class="params">()</span></span>&#123; <span class="comment">// samllest prime factor</span></span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)    sp[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sp[i]==i)    p[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt &amp;&amp; p[j]&lt;=sp[i] &amp;&amp; i * p[j] &lt; N; ++j) &#123;</span><br><span class="line">            sp[i * p[j]] = p[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5927_u6574_u6570_u7684_u6700_u5C0F_u7D20_u56E0_u5B50"><a href="#u5927_u6574_u6570_u7684_u6700_u5C0F_u7D20_u56E0_u5B50" class="headerlink" title="大整数的最小素因子"></a>大整数的最小素因子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">Pollard_rho</span><span class="params">(LL n)</span></span>&#123;</span><br><span class="line">    LL x=rand()%(n-<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    LL y=x,i=<span class="number">1</span>,k=<span class="number">2</span>,c=rand()%(n-<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        x=(mul_mod(x,x,n)+c)%n;</span><br><span class="line">        LL d=gcd(y-x+n,n);</span><br><span class="line">        <span class="keyword">if</span>(d&gt;<span class="number">1</span>)    <span class="keyword">return</span> d;</span><br><span class="line">        <span class="keyword">if</span>(++i==k)&#123;</span><br><span class="line">            y=x;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;n)	<span class="keyword">return</span> n;</span><br><span class="line">            k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findp</span><span class="params">(LL n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Rabin(n))&#123;</span><br><span class="line">        ans=min(ans,n);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL p=n;</span><br><span class="line">    <span class="keyword">while</span>(p==n) p=Pollard_rho(n);</span><br><span class="line">    findp(p);</span><br><span class="line">    findp(n/p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Mobius_function"><a href="#Mobius_function" class="headerlink" title="Mobius function"></a>Mobius function</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> np[N];</span><br><span class="line"><span class="keyword">int</span> mu[N],p[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,cnt = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) &#123;</span><br><span class="line">            p[cnt++] = i;</span><br><span class="line">            mu[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>,t;j &lt; cnt &amp;&amp; (t= i * p[j]) &lt; N; ++j) &#123;</span><br><span class="line">            np[t] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j])   mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Euler_u2019s_totient_function"><a href="#Euler_u2019s_totient_function" class="headerlink" title="Euler’s totient function"></a>Euler’s totient function</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getphi</span><span class="params">(LL x)</span></span>&#123;    LL r=x;    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;p[i]*p[i]&lt;=x;++i)&#123;        <span class="keyword">if</span>(x%p[i]==<span class="number">0</span>)&#123;            r=r/p[i]*(p[i]-<span class="number">1</span>);            <span class="keyword">while</span>(x%p[i]==<span class="number">0</span>)    x/=p[i];        &#125;    &#125;    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) r=r/x*(x-<span class="number">1</span>);    <span class="keyword">return</span> r;&#125;<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> phi[N];<span class="function"><span class="keyword">void</span> <span class="title">getphi</span><span class="params">()</span></span>&#123;    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i!=N;++i)   phi[i]=i;    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;i+=<span class="number">2</span>)   phi[i]&gt;&gt;=<span class="number">1</span>;    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;        <span class="keyword">if</span>(phi[i]!=i)	<span class="keyword">continue</span>;        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j+=i)	phi[j]=phi[j]/i*(i-<span class="number">1</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="24_5Cpi_28x_29_24__u51FD_u6570"><a href="#24_5Cpi_28x_29_24__u51FD_u6570" class="headerlink" title="$\pi(x)$ 函数"></a>$\pi(x)$ 函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span>*<span class="number">3</span>*<span class="number">5</span>*<span class="number">7</span>*<span class="number">11</span>*<span class="number">13</span>*<span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM+<span class="number">1</span>][M+<span class="number">1</span>],sz[M+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    getprime();</span><br><span class="line">    sz[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=PM;++i)  phi[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        sz[i]=p[i]*sz[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=PM;++j)&#123;</span><br><span class="line">            phi[j][i]=phi[j][i-<span class="number">1</span>]-phi[j/p[i]][i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getphi</span><span class="params">(LL x,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">0</span>)  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(s &lt;= M)  <span class="keyword">return</span> phi[x%sz[s]][s]+(x/sz[s])*phi[sz[s]][s];</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= p[s]*p[s])   <span class="keyword">return</span> pi[x]-s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= p[s]*p[s]*p[s] &amp;&amp; x&lt; N)&#123;</span><br><span class="line">        <span class="keyword">int</span> s2x = pi[sqrt2(x)];</span><br><span class="line">        LL ans = pi[x]-(s2x+s-<span class="number">2</span>)*(s2x-s+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>;i&lt;=s2x;++i)&#123;</span><br><span class="line">            ans += pi[x/p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getphi(x,s-<span class="number">1</span>)-getphi(x/p[s],s-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">lehmer_pi</span><span class="params">(LL x)</span></span>&#123; <span class="comment">// x &lt; N*N</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; N)   <span class="keyword">return</span> pi[x];</span><br><span class="line">    <span class="keyword">int</span> a = (<span class="keyword">int</span>)lehmer_pi(sqrt2(sqrt2(x)));</span><br><span class="line">    <span class="keyword">int</span> b = (<span class="keyword">int</span>)lehmer_pi(sqrt2(x));</span><br><span class="line">    <span class="keyword">int</span> c = (<span class="keyword">int</span>)lehmer_pi(sqrt3(x));</span><br><span class="line">    LL sum = getphi(x, a) + LL(b + a - <span class="number">2</span>) * (b - a + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a + <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        LL w = x / p[i];</span><br><span class="line">        sum -= lehmer_pi(w);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; c) <span class="keyword">continue</span>;</span><br><span class="line">        LL lim = lehmer_pi(sqrt2(w));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= lim; j++) &#123;</span><br><span class="line">            sum -= lehmer_pi(w / p[j]) - (j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line">LL L[N],R[N];</span><br><span class="line"><span class="function">LL <span class="title">getans</span><span class="params">(LL n)</span></span>&#123; <span class="comment">// n*n &lt; 1e14</span></span><br><span class="line">    LL rn = sqrt2(n);</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=rn;++i)   R[i]=n/i-<span class="number">1</span>;</span><br><span class="line">    LL ln = n/(rn+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=ln;++i)   L[i]=i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL p=<span class="number">2</span>;p&lt;=rn;++p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L[p]==L[p-<span class="number">1</span>])    <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(LL i=<span class="number">1</span>,tn=min(n/(p*p),rn);i&lt;=tn;++i)&#123;</span><br><span class="line">            R[i] -= (i*p&lt;=rn?R[i*p]:L[n/(i*p)])-L[p-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(LL i=ln;i&gt;=p*p;--i)&#123;</span><br><span class="line">            L[i] -= L[i/p]-L[p-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = L[sqrt3(n)];</span><br><span class="line">    <span class="keyword">for</span>(LL p=<span class="number">2</span>;p&lt;=rn;++p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L[p] == L[p-<span class="number">1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">        ans += R[p]-L[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="u6C42_u5947_u7D20_u6570_u7684_u4E00_u4E2A_u539F_u6839"><a href="#u6C42_u5947_u7D20_u6570_u7684_u4E00_u4E2A_u539F_u6839" class="headerlink" title="求奇素数的一个原根"></a>求奇素数的一个原根</h4><p>首先，模 $m$ 有原根的充要条件是：$m=2,4,p^a,2p^a$，其中$p$为奇素数。<br>对于求模$p$的原根方法：对 $p-1$ 素因子分解：$p-1 = p_1^{a_1} \cdots p_s^{a_s}$ 若恒有<br>$$ g^{\frac{p-1}{p_i}} \neq 1(mod \; p) $$<br>则 $g$ 是 模$p$的原根。对于 $p^a$ 可以用 $p$ 的原根简单构造，而 $2p^a$ 的原根为 $p^a$ 的原根 与 $p^a$ 的原根和 $p^a$的和中奇数者。(证明见P150《数论基础》潘承洞)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">LL fact[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factor</span><span class="params">(LL n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;LL(p[i])*p[i]&lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%p[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            fact[cnt++] = p[i];</span><br><span class="line">            <span class="keyword">while</span>(n%p[i]==<span class="number">0</span>) n /= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) fact[cnt++] = n;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">proot</span><span class="params">(LL p)</span></span>&#123; <span class="comment">// p must be odd prime</span></span><br><span class="line">    <span class="keyword">int</span> cnt = factor(p-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>; i&lt;p;++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pow_mod(i,(p-<span class="number">1</span>)/fact[j],p)==<span class="number">1</span>)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)    <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>求所有原根见<a href="http://dna049.com/2016/02/16/Quadratic-residue-and-Guass-reciprocity/">我之前的博文</a></p>
</blockquote>
<h4 id="u6570_u8BBA_u51FD_u6570_u7684Dirichlet_u4E58_u79EF"><a href="#u6570_u8BBA_u51FD_u6570_u7684Dirichlet_u4E58_u79EF" class="headerlink" title="数论函数的Dirichlet乘积"></a>数论函数的Dirichlet乘积</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Dirichlet&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> a[N],n;</span><br><span class="line">    Dirichlet(<span class="keyword">int</span> _n = <span class="number">0</span>)&#123;</span><br><span class="line">        n=_n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            a[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Dirichlet <span class="keyword">operator</span>*(<span class="keyword">const</span> Dirichlet&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="function">Dirichlet <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i*j&lt;=n;++j)&#123;</span><br><span class="line">                R.a[i*j]=a[i]*A.a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">LL <span class="title">Dirichlet</span><span class="params">(<span class="keyword">int</span> n,LL a[],LL b[])</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;<span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">for</span>(s=<span class="number">1</span>;s*s&lt;n;++s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%s==<span class="number">0</span>)&#123;</span><br><span class="line">            ans + = a[s]*b[n/s]+b[s]*a[n/s];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s*s==n)  ans + = a[s]*b[s];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u7EBF_u6027_u540C_u4F59_u65B9_u7A0B"><a href="#u7EBF_u6027_u540C_u4F59_u65B9_u7A0B" class="headerlink" title="线性同余方程"></a>线性同余方程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modeq</span><span class="params">(LL a,LL b,LL n)</span></span>&#123; <span class="comment">// a*x=b mod n return x</span>    LL x,y,d;    d=exgcd(a,n,x,y);    <span class="keyword">if</span>(b%d!=<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;    a/=d;n/=d;b/=d;    <span class="keyword">return</span> ((x*b)%n+n)%n;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u4E2D_u56FD_u5269_u4F59_u5B9A_u7406"><a href="#u4E2D_u56FD_u5269_u4F59_u5B9A_u7406" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">chinaRemain</span><span class="params">(<span class="keyword">int</span> n,LL a[],LL m[])</span></span>&#123;<span class="comment">//x=a[i] mod m[i]</span>    LL x,y,a1,a2,m1,m2,d;    a1=a[<span class="number">0</span>],m1=m[<span class="number">0</span>];    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;        a2=a[i],m2=m[i];        d=exgcd(m1,m2,x,y);        <span class="keyword">if</span>((a2-a1)%d!=<span class="number">0</span>)    <span class="keyword">return</span> -<span class="number">1</span>;        a1+=(((a2-a1)/d*x)%m2+m2)%m2*m1;        m1=m1/d*m2;        a1=(a1%m1+m1)%m1;    &#125;    <span class="keyword">return</span> a1;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">double</span> *x,<span class="keyword">double</span> *y,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=i,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;loglen;++j,t&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            k=(k&lt;&lt;<span class="number">1</span>)|(t&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;i)&#123;</span><br><span class="line">            <span class="keyword">double</span> tmp=x[i];x[i]=x[k];x[k]=tmp;</span><br><span class="line">            tmp=y[i];y[i]=y[k];y[k]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(<span class="keyword">double</span> *x,<span class="keyword">double</span> *y,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen,<span class="keyword">bool</span> isInverse)</span></span>&#123;</span><br><span class="line">    change(x,y,len,loglen);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">2</span>;step&lt;=len;step&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> half=step&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> theta=PI/half;</span><br><span class="line">        <span class="keyword">double</span> wmx=<span class="built_in">cos</span>(theta),wmy=<span class="built_in">sin</span>(theta);</span><br><span class="line">        <span class="keyword">if</span>(isInverse)   wmy=-wmy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=step)&#123;</span><br><span class="line">            <span class="keyword">double</span> wx=<span class="number">1</span>,wy=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;half;++j)&#123;</span><br><span class="line">                <span class="keyword">double</span> cx=x[i+j],cy=y[i+j];</span><br><span class="line">                <span class="keyword">double</span> dx=x[i+j+half],dy=y[i+j+half];</span><br><span class="line">                <span class="keyword">double</span> ex=dx*wx-dy*wy,ey=dx*wy+dy*wx;</span><br><span class="line">                x[i+j]=cx+ex;y[i+j]=cy+ey;</span><br><span class="line">                x[i+j+half]=cx-ex;y[i+j+half]=cy-ey;</span><br><span class="line">                <span class="keyword">double</span> tmp=wx*wmx-wy*wmy;</span><br><span class="line">                wy=wx*wmy+wy*wmx;wx=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isInverse) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        x[i]/=len;y[i]/=len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5229_u7528FFT_u7684_u591A_u9879_u5F0F_u4E58_u6CD5"><a href="#u5229_u7528FFT_u7684_u591A_u9879_u5F0F_u4E58_u6CD5" class="headerlink" title="利用FFT的多项式乘法"></a>利用FFT的多项式乘法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen,<span class="keyword">bool</span> same)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">        ax[i]=a[i];bx[i]=b[i];</span><br><span class="line">        ay[i]=by[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fft(ax,ay,len,loglen,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!same) fft(bx,by,len,loglen,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">            bx[i]=ax[i];by[i]=ay[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">        <span class="keyword">double</span> cx=ax[i]*bx[i]-ay[i]*by[i];</span><br><span class="line">        <span class="keyword">double</span> cy=ax[i]*by[i]+ay[i]*bx[i];</span><br><span class="line">        ax[i]=cx;ay[i]=cy;</span><br><span class="line">    &#125;</span><br><span class="line">    fft(ax,ay,len,loglen,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">        a[i]=(<span class="keyword">int</span>)(ax[i]+<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=q-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        a[i+q-p]=(a[i+q-p]+ta*a[q+i])%M;</span><br><span class="line">        a[i]=(a[i]+tb*a[q+i])%M;</span><br><span class="line">        a[i+q]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5FEB_u901F_u6570_u8BBA_u53D8_u6362_NFT"><a href="#u5FEB_u901F_u6570_u8BBA_u53D8_u6362_NFT" class="headerlink" title="快速数论变换 NFT"></a>快速数论变换 NFT</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(LL *x,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=i,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;loglen;++j,t&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            k=(k&lt;&lt;<span class="number">1</span>)|(t&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;i) swap(x[i],x[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL FM = <span class="number">479</span>&lt;&lt;<span class="number">21</span>|<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(LL *x,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen,<span class="keyword">bool</span> isInverse)</span></span>&#123;</span><br><span class="line">    LL g = pow_mod(<span class="number">3</span>,(FM-<span class="number">1</span>)&gt;&gt;loglen,FM);</span><br><span class="line">    <span class="keyword">if</span>(isInverse)&#123;</span><br><span class="line">        g=inv(g,FM);</span><br><span class="line">        LL invlen = inv(len,FM);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">            x[i]=x[i]*invlen%FM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    change(x,len,loglen);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">2</span>;step&lt;=len;step&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> half = step&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        LL wn = pow_mod(g,len/step,FM);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=step)&#123;</span><br><span class="line">            LL w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;i+half;++j)&#123;</span><br><span class="line">                LL t=(w*x[j+half])%FM;</span><br><span class="line">                x[j+half]=(x[j]-t+FM)%FM;</span><br><span class="line">                x[j]=(x[j]+t)%FM;</span><br><span class="line">                w = w*wn%FM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(LL *a,LL *b,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen,<span class="keyword">bool</span> same)</span></span>&#123;</span><br><span class="line">    nft(a,len,loglen,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(same)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)  a[i]=a[i]*a[i]%FM;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        nft(b,len,loglen,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)  a[i]=a[i]*b[i]%FM;</span><br><span class="line">    &#125;</span><br><span class="line">    nft(a,len,loglen,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u591A_u9879_u5F0F_u7C7B"><a href="#u591A_u9879_u5F0F_u7C7B" class="headerlink" title="多项式类"></a>多项式类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Node&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c,d;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> _c,<span class="keyword">int</span> _d):c(_c),d(_d)&#123;next=<span class="literal">NULL</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Poly&#123;     <span class="comment">// a0+a1*x+...+an*x^n</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="keyword">const</span> Poly&amp; A)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.head-&gt;c==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A.head-&gt;d==<span class="number">0</span>)    os&lt;&lt;<span class="string">"-1"</span>;</span><br><span class="line">            <span class="keyword">if</span>(A.head-&gt;d==<span class="number">1</span>)    os&lt;&lt;<span class="string">"-x"</span>;</span><br><span class="line">            <span class="keyword">if</span>(A.head-&gt;d&gt;<span class="number">1</span>)     os&lt;&lt;<span class="string">"-x^"</span>&lt;&lt;(A.head-&gt;d);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            os&lt;&lt;A.head-&gt;c;</span><br><span class="line">            <span class="keyword">if</span>(A.head-&gt;d==<span class="number">1</span>)    os&lt;&lt;<span class="string">"x"</span>;</span><br><span class="line">            <span class="keyword">if</span>(A.head-&gt;d&gt;<span class="number">1</span>)     os&lt;&lt;<span class="string">"x^"</span>&lt;&lt;(A.head-&gt;d);</span><br><span class="line">        &#125;</span><br><span class="line">        Node* p=A.head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;c&gt;<span class="number">0</span>)      os&lt;&lt;<span class="string">"+"</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;c==-<span class="number">1</span>)    os&lt;&lt;<span class="string">"-"</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;c!=<span class="number">1</span>)     os&lt;&lt;(p-&gt;c);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;d&gt;<span class="number">1</span>)  os&lt;&lt;<span class="string">"x^"</span>&lt;&lt;(p-&gt;d);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;d==<span class="number">1</span>) os&lt;&lt;<span class="string">"x"</span>;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> Size;</span><br><span class="line">    Node *head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Poly()&#123;</span><br><span class="line">        head=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        Size=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        head=<span class="keyword">new</span> Node(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(x)   Size=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>    Size=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly(<span class="keyword">int</span>* a,<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>) &#123;Poly();<span class="keyword">return</span>;&#125;</span><br><span class="line">        head=<span class="literal">NULL</span>;</span><br><span class="line">        Node* p;</span><br><span class="line">        <span class="keyword">for</span>(Size=n-<span class="number">1</span>;Size!=-<span class="number">1</span>&amp;&amp;a[Size]==<span class="number">0</span>;--Size);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Size;i!=-<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i])&#123;</span><br><span class="line">                p=<span class="keyword">new</span> Node(a[i],i);</span><br><span class="line">                p-&gt;next=head;</span><br><span class="line">                head=p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)  head=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//  if(head==NULL) new (this)poly();</span></span><br><span class="line">    &#125;</span><br><span class="line">    Poly(<span class="keyword">const</span> Poly&amp; A)&#123;</span><br><span class="line">        head=<span class="keyword">new</span> Node(A.head-&gt;c,A.head-&gt;d);</span><br><span class="line">        Size=A.Size;</span><br><span class="line">        Node *Ap=A.head-&gt;next,*p=head,*tp;</span><br><span class="line">        <span class="keyword">while</span>(Ap!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tp=<span class="keyword">new</span> Node(Ap-&gt;c,Ap-&gt;d);</span><br><span class="line">            p-&gt;next=tp;p=tp;</span><br><span class="line">            Ap=Ap-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Poly()&#123;</span><br><span class="line">        del();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node* p;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p=head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span>(head);</span><br><span class="line">            head=p;</span><br><span class="line">        &#125;</span><br><span class="line">        Size=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Poly&amp; A)&#123;</span><br><span class="line">        del();</span><br><span class="line">        Size=A.Size;</span><br><span class="line">        head=<span class="keyword">new</span> Node(A.head-&gt;c,A.head-&gt;d);</span><br><span class="line">        Node *Ap=A.head-&gt;next,*p=head,*tp;</span><br><span class="line">        <span class="keyword">while</span>(Ap!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tp=<span class="keyword">new</span> Node(Ap-&gt;c,Ap-&gt;d);</span><br><span class="line">            p-&gt;next=tp;p=tp;</span><br><span class="line">            Ap=Ap-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly <span class="keyword">operator</span>+(<span class="keyword">const</span> Poly&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Size&lt;A.Size) <span class="keyword">return</span> add(A,*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span>            <span class="keyword">return</span> add(*<span class="keyword">this</span>,A);</span><br><span class="line">    &#125;</span><br><span class="line">    Poly <span class="keyword">operator</span>-()<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="function">Poly <span class="title">R</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        Node *Rp=R.head;</span><br><span class="line">        <span class="keyword">while</span>(Rp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Rp-&gt;c=-Rp-&gt;c;</span><br><span class="line">            Rp=Rp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly <span class="keyword">operator</span>-(<span class="keyword">const</span> Poly&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Size&lt;A.Size) <span class="keyword">return</span> add(-A,*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span>            <span class="keyword">return</span> add(*<span class="keyword">this</span>,-A);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">mul</span><span class="params">(<span class="keyword">int</span> tc,<span class="keyword">int</span> td)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tc==<span class="number">0</span>)       <span class="keyword">return</span> Poly();</span><br><span class="line">        <span class="keyword">if</span>(Size==-<span class="number">1</span>)    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="function">Poly <span class="title">R</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        Node *Rp=R.head;</span><br><span class="line">        <span class="keyword">while</span>(Rp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Rp-&gt;c*=tc;</span><br><span class="line">            Rp-&gt;d+=td;</span><br><span class="line">            R.Size=Rp-&gt;d;</span><br><span class="line">            Rp=Rp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly <span class="keyword">operator</span>*(Poly&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Poly R;</span><br><span class="line">        Node *Ap=A.head;</span><br><span class="line">        <span class="keyword">while</span>(Ap!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            R=R+mul(Ap-&gt;c,Ap-&gt;d);</span><br><span class="line">            Ap=Ap-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> td)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        Node *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;d&lt;td) p=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>||p-&gt;d&gt;td)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> td)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        Node *p=head;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;d&lt;=td)&#123;</span><br><span class="line">            ans+=p-&gt;c;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Poly <span class="title">add</span><span class="params">(<span class="keyword">const</span> Poly&amp; A,<span class="keyword">const</span> Poly&amp; B)</span></span>&#123;    <span class="comment">//A.Size&gt;=B.Size</span></span><br><span class="line">        <span class="function">Poly <span class="title">R</span><span class="params">(A)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(B.Size==-<span class="number">1</span>)   <span class="keyword">return</span> R;</span><br><span class="line">        Node *Bp=B.head,*Rp=R.head,*tp;</span><br><span class="line">        <span class="keyword">if</span>(R.head-&gt;d&gt;B.head-&gt;d)&#123;</span><br><span class="line">            tp=<span class="keyword">new</span> Node(B.head-&gt;c,B.head-&gt;d);</span><br><span class="line">            tp-&gt;next=R.head;</span><br><span class="line">            Rp=R.head=tp;</span><br><span class="line">            Bp=Bp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Bp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Rp-&gt;d==Bp-&gt;d)&#123;</span><br><span class="line">                Rp-&gt;c+=Bp-&gt;c;</span><br><span class="line">                Bp=Bp-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(Rp-&gt;next-&gt;d&gt;Bp-&gt;d)&#123;</span><br><span class="line">                    tp=<span class="keyword">new</span> Node(Bp-&gt;c,Bp-&gt;d);</span><br><span class="line">                    tp-&gt;next=Rp-&gt;next;</span><br><span class="line">                    Rp-&gt;next=tp;Rp=tp;</span><br><span class="line">                    Bp=Bp-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> Rp=Rp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(R.head-&gt;next!=<span class="literal">NULL</span>&amp;&amp;R.head-&gt;c==<span class="number">0</span>)&#123;</span><br><span class="line">            Rp=R.head;</span><br><span class="line">            R.head=Rp-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span>(Rp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(R.head-&gt;c==<span class="number">0</span>)    R.Size=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>                R.Size=R.head-&gt;d;</span><br><span class="line">        Rp=R.head;</span><br><span class="line">        <span class="keyword">while</span>(Rp-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Rp-&gt;next-&gt;c==<span class="number">0</span>)&#123;</span><br><span class="line">                tp=Rp-&gt;next;</span><br><span class="line">                Rp-&gt;next=tp-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span>(tp);</span><br><span class="line">            &#125;</span><br><span class="line">            Rp=Rp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u5927_u6570_u52A0_u4E58_u7C7B"><a href="#u5927_u6570_u52A0_u4E58_u7C7B" class="headerlink" title="大数加乘类"></a>大数加乘类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BigInt&#123; <span class="comment">// without nft and we won't set B=10000 in nft</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N=<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> B=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len,a[N]; <span class="comment">// keep the inverse order of int &gt; 0</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt()&#123;</span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt(<span class="keyword">int</span> x)&#123; <span class="comment">// construct function use c.f. brings mistake in clang</span></span><br><span class="line">        clear();</span><br><span class="line">        <span class="keyword">while</span>(x&gt;=B)&#123;</span><br><span class="line">            a[len++] = x%B;</span><br><span class="line">            x/=B;</span><br><span class="line">        &#125;</span><br><span class="line">        a[len++]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt(LL x)&#123; <span class="comment">// construct function use c.f. brings mistake in clang</span></span><br><span class="line">        clear();</span><br><span class="line">        <span class="keyword">while</span>(x&gt;=B)&#123;</span><br><span class="line">            a[len++] = x%B;</span><br><span class="line">            x/=B;</span><br><span class="line">        &#125;</span><br><span class="line">        a[len++]=(<span class="keyword">int</span>)x;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt(<span class="keyword">const</span> <span class="keyword">char</span> *s)&#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="keyword">int</span> slen=(<span class="keyword">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">while</span>(slen&gt;<span class="number">0</span>&amp;&amp;a[slen-<span class="number">1</span>]==<span class="string">'0'</span>)  --slen;</span><br><span class="line">        <span class="keyword">if</span>(slen==<span class="number">0</span>) a[len++] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(slen&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--slen&gt;=<span class="number">0</span>) a[len]=s[slen]-<span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(--slen&gt;=<span class="number">0</span>) a[len]+=<span class="number">10</span>*(s[slen]-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span>(--slen&gt;=<span class="number">0</span>) a[len]+=<span class="number">100</span>*(s[slen]-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span>(--slen&gt;=<span class="number">0</span>) a[len]+=<span class="number">1000</span>*(s[slen]-<span class="string">'0'</span>);</span><br><span class="line">                ++len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt(<span class="keyword">const</span> BigInt&amp; A):len(A.len)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i) a[i]=A.a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInt&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        BigInt R;</span><br><span class="line">        R.len=max(len,A.len);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=R.len;++i)&#123;</span><br><span class="line">            res+=a[i]+A.a[i];</span><br><span class="line">            R.a[i]=res%B;res/=B;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res) R.a[R.len++]=res%B;</span><br><span class="line">        <span class="keyword">while</span>(R.len&gt;<span class="number">1</span>&amp;&amp;R.a[R.len-<span class="number">1</span>]==<span class="number">0</span>) --R.len;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInt&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        BigInt R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j!=A.len;++j)&#123;</span><br><span class="line">                res+=a[i]*A.a[j]+R.a[i+j];</span><br><span class="line">                R.a[i+j]=res%B;res/=B;</span><br><span class="line">            &#125;</span><br><span class="line">            R.a[i+A.len]+=res;</span><br><span class="line">        &#125;</span><br><span class="line">        R.len = len + A.len;</span><br><span class="line">        <span class="keyword">while</span>(R.len&gt;<span class="number">1</span>&amp;&amp;R.a[R.len-<span class="number">1</span>]==<span class="number">0</span>) --R.len;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> BigInt&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;A.len)   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(len&gt;A.len)   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> tn = len;</span><br><span class="line">        <span class="keyword">while</span>(--tn&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[tn]&lt;A.a[tn])   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[tn]&gt;A.a[tn])   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[len-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%04d"</span>,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u77E9_u9635_u7C7B"><a href="#u77E9_u9635_u7C7B" class="headerlink" title="矩阵类"></a>矩阵类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">LL mod;</span><br><span class="line"><span class="keyword">class</span> Matrix&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">3</span>; <span class="comment">//col</span></span><br><span class="line">    LL a[N][N];</span><br><span class="line">    Matrix()&#123;</span><br><span class="line">        all(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        all(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            a[i][i]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">all</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                a[i][j]=x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                R.a[i][j]=a[i][j]+A.a[i][j];</span><br><span class="line">                <span class="keyword">if</span>(R.a[i][j]&gt;=mod)   R.a[i][j]-=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                    R.a[i][j] = (R.a[i][j]+a[i][k]*A.a[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;a[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix A,LL n)</span></span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">R</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) R=R*A;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h2><h4 id="u5E76_u67E5_u96C6"><a href="#u5E76_u67E5_u96C6" class="headerlink" title="并查集"></a>并查集</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = x;</span><br><span class="line">    <span class="keyword">while</span>(ans!=p[ans])  ans=p[ans];</span><br><span class="line">    <span class="keyword">while</span>(x!=ans)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = p[x];</span><br><span class="line">        p[x] = ans;</span><br><span class="line">        x = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6570_u72B6_u6570_u7EC4"><a href="#u6570_u72B6_u6570_u7EC4" class="headerlink" title="数状数组"></a>数状数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeArray&#123;</span><br><span class="line">    LL s[N];</span><br><span class="line">    <span class="keyword">int</span> Size;</span><br><span class="line">    TreeArray()&#123;&#125;</span><br><span class="line">    TreeArray(<span class="keyword">int</span> _S):Size(_S)&#123;clr(s,<span class="number">0</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n&amp;(-n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(id&lt;=Size)&#123;</span><br><span class="line">            s[id]+=p;</span><br><span class="line">            id+=lowbit(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        LL r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(id)&#123;</span><br><span class="line">            r+=s[id];</span><br><span class="line">            id-=lowbit(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="u7EBF_u6BB5_u6811"><a href="#u7EBF_u6BB5_u6811" class="headerlink" title="线段树"></a>线段树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=B5;</span><br><span class="line">LL sum[N&lt;&lt;<span class="number">2</span>],col[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    sum[rt]=sum[lrt]+sum[rrt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(col[rt])&#123;</span><br><span class="line">        col[lrt]+=col[rt];</span><br><span class="line">        col[rrt]+=col[rt];</span><br><span class="line">        sum[lrt]+=(m-(m&gt;&gt;<span class="number">1</span>))*col[rt];</span><br><span class="line">        sum[rrt]+=(m&gt;&gt;<span class="number">1</span>)*col[rt];</span><br><span class="line">        col[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;sum[rt]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    col[rt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;R&gt;=r)&#123;</span><br><span class="line">        sum[rt]+=p*(r-l+<span class="number">1</span>);</span><br><span class="line">        col[rt]+=p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(rt,r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=m)      update(L,R,p,lson);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;m)       update(L,R,p,rson);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;R&gt;=r)  <span class="keyword">return</span> sum[rt];</span><br><span class="line">    PushDown(rt,r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=m)    ans+=query(L,R,lson);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;m)     ans+=query(L,R,rson);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RMQ__u6C42_u533A_u95F4_u6700_u5C0F_u503C"><a href="#RMQ__u6C42_u533A_u95F4_u6700_u5C0F_u503C" class="headerlink" title="RMQ 求区间最小值"></a>RMQ 求区间最小值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> RMQ&#123;<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10004</span>;<span class="keyword">public</span>:    <span class="keyword">int</span> n;    <span class="keyword">int</span> a[N][<span class="number">20</span>]; <span class="comment">//a[i][j]=max(a[i][0]---a[i+2^j-1])</span>    RMQ(<span class="keyword">int</span>* s,<span class="keyword">int</span> _n):n(_n)&#123;        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;++i)   a[i][<span class="number">0</span>]=s[i];        <span class="keyword">int</span> len=(<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(n))/<span class="built_in">log</span>(<span class="number">2.0</span>))+<span class="number">2</span>;        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=len;++i)&#123;            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n-(<span class="number">1</span>&lt;&lt;i);++j)&#123;                a[j][i]=max(a[j][i-<span class="number">1</span>],a[j+(<span class="number">1</span>&lt;&lt;(i-<span class="number">1</span>))][i-<span class="number">1</span>]);            &#125;        &#125;    &#125;    <span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;        <span class="keyword">if</span>(r&gt;=n)    r=n-<span class="number">1</span>;        <span class="keyword">if</span>(l&lt;<span class="number">0</span>) l=<span class="number">0</span>;        <span class="keyword">int</span> len=(<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(r-l+<span class="number">1</span>))/<span class="built_in">log</span>(<span class="number">2.0</span>));        <span class="keyword">return</span> max(a[l][len],a[r-(<span class="number">1</span>&lt;&lt;len)+<span class="number">1</span>][len]);    &#125;&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u6700_u957F_uFF08_u4E25_u683C_uFF09_u9012_u589E_u5B50_u5E8F_u5217"><a href="#u6700_u957F_uFF08_u4E25_u683C_uFF09_u9012_u589E_u5B50_u5E8F_u5217" class="headerlink" title="最长（严格）递增子序列"></a>最长（严格）递增子序列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// longest increasing subsquence</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    b[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;b[k]) b[++k]=a[i];</span><br><span class="line">        <span class="keyword">else</span>    b[lower_bound(b,b+k,a[i])-b]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lower_bound(first,end,val) 表示在单增 [frist,end) 中首次大于等于 val 的位置</span></span><br><span class="line"><span class="comment">// upper_bound(first,end,val) 表示在单增 [frist,end) 中首次大于 val 的位置</span></span><br></pre></td></tr></table></figure>
<h4 id="u6700_u5927_u5B50_u5E8F_u5217_u548C"><a href="#u6700_u5927_u5B50_u5E8F_u5217_u548C" class="headerlink" title="最大子序列和"></a>最大子序列和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MSCS</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// maximal sum of continue subsquence,mind overflow</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r=a[<span class="number">0</span>],s=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;++i)&#123;</span><br><span class="line">        s = max(s,<span class="number">0</span>);</span><br><span class="line">        s += a[i];</span><br><span class="line">        r = max(r,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u80CC_u5305"><a href="#u80CC_u5305" class="headerlink" title="背包"></a>背包</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=B5;</span><br><span class="line"><span class="keyword">int</span> r[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pack</span><span class="params">(<span class="keyword">int</span> cash,<span class="keyword">int</span> num,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">0</span>||w==<span class="number">0</span>||v==<span class="number">0</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>)&#123; <span class="comment">//  0-1背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=cash;i&gt;=v;--i)</span><br><span class="line">            r[i]=max(r[i],r[i-v]+w);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num*v&gt;=cash-v+<span class="number">1</span>)&#123; <span class="comment">//完全背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=v;i&lt;=cash;++i)</span><br><span class="line">            r[i]=max(r[i],r[i-v]+w);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q[MAX],s[MAX],head,tail;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;v;++j)&#123;   <span class="comment">//多重背包</span></span><br><span class="line">        q[<span class="number">0</span>]=r[j];s[<span class="number">0</span>]=head=tail=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,k=j+v;k&lt;=cash;++i,k+=v)&#123;</span><br><span class="line">            q[i]=r[k]-i*w;</span><br><span class="line">            <span class="keyword">while</span>(s[head]&lt;i-num)    ++head;</span><br><span class="line">            <span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[tail]&lt;q[i]) --tail;</span><br><span class="line">            s[++tail]=i;</span><br><span class="line">            q[tail]=q[i];</span><br><span class="line">            r[k]=q[head]+i*w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5B57_u7B26_u4E32_u5339_u914D_u7684Sunday_u7B97_u6CD5"><a href="#u5B57_u7B26_u4E32_u5339_u914D_u7684Sunday_u7B97_u6CD5" class="headerlink" title="字符串匹配的Sunday算法"></a>字符串匹配的Sunday算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ASSIZE=<span class="number">256</span>;</span><br><span class="line"><span class="keyword">int</span> tp[ASSIZE];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getTp</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sLen=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=ASSIZE;++i)&#123;</span><br><span class="line">        tp[i]=sLen+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p=s;*p;++p)&#123;</span><br><span class="line">        tp[*p]=sLen-(p-s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sunday</span><span class="params">(<span class="keyword">char</span> *ps,<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    getTp(s);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *t,*p,*tx=ps;</span><br><span class="line">    <span class="keyword">int</span> pLen=<span class="built_in">strlen</span>(ps);</span><br><span class="line">    <span class="keyword">int</span> sLen=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(tx+sLen&lt;=ps+pLen)&#123;</span><br><span class="line">        <span class="keyword">for</span>(t=tx,p=s;*p;++p,++t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*p!=*t)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*p==<span class="string">'\0'</span>)    <span class="keyword">return</span> tx-ps;</span><br><span class="line">        tx+=tp[tx[sLen]];       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5B57_u7B26_u4E32_u5339_u914D_u7684KMP_u7B97_u6CD5"><a href="#u5B57_u7B26_u4E32_u5339_u914D_u7684KMP_u7B97_u6CD5" class="headerlink" title="字符串匹配的KMP算法"></a>字符串匹配的KMP算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> *next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>,k=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sLen=<span class="built_in">strlen</span>(s)-<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;sLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==-<span class="number">1</span>||s[j]==s[k])&#123;</span><br><span class="line">            next[++j]=++k;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k=next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *p,<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pLen=<span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">int</span> sLen=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> *next=<span class="keyword">new</span> <span class="keyword">int</span>[sLen];</span><br><span class="line">    getNext(s,next);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;pLen&amp;&amp;j&lt;sLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==-<span class="number">1</span>||p[i]==s[j])&#123;</span><br><span class="line">            ++i;++j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] next;</span><br><span class="line">    <span class="keyword">if</span>(j==sLen) <span class="keyword">return</span> i-j;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6574_u6570_u5B57_u5178_u6811_Trie"><a href="#u6574_u6570_u5B57_u5178_u6811_Trie" class="headerlink" title="整数字典树 Trie"></a>整数字典树 Trie</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Trie&#123;</span><br><span class="line">    Trie *nt[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    Trie() &#123; nt[<span class="number">0</span>] = nt[<span class="number">1</span>] = <span class="literal">NULL</span>; cnt = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxb = <span class="number">31</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Trie* root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ++root-&gt;cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Maxb-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;nt[(x&gt;&gt;i)&amp;<span class="number">1</span>]==<span class="literal">NULL</span>)  root-&gt;nt[(x&gt;&gt;i)&amp;<span class="number">1</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">        root = root-&gt;nt[(x&gt;&gt;i)&amp;<span class="number">1</span>];</span><br><span class="line">        ++root-&gt;cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(Trie* root,<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Maxb-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        Trie* t = root-&gt;nt[((x&gt;&gt;i)^<span class="number">1</span>)&amp;<span class="number">1</span>];</span><br><span class="line">        root = root-&gt;nt[((k^x)&gt;&gt;i)&amp;<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(!((k&gt;&gt;i)&amp;<span class="number">1</span>) &amp;&amp; t != <span class="literal">NULL</span>)   ans += t-&gt;cnt;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)    ans += root-&gt;cnt;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5B57_u6BCD_u5B57_u5178_u6811_Trie"><a href="#u5B57_u6BCD_u5B57_u5178_u6811_Trie" class="headerlink" title="字母字典树 Trie"></a>字母字典树 Trie</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Trie&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX=<span class="number">26</span>;</span><br><span class="line">    <span class="keyword">bool</span> isStr;</span><br><span class="line">    Trie *next[MAX];</span><br><span class="line">    Trie()&#123;</span><br><span class="line">        isStr=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=MAX;++i) next[i]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Trie *root,<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>||*s==<span class="string">'\0'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(*s!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;next[*s-<span class="string">'a'</span>]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            root-&gt;next[*s-<span class="string">'a'</span>]=<span class="keyword">new</span> Trie;</span><br><span class="line">        &#125;</span><br><span class="line">        root=root-&gt;next[*s-<span class="string">'a'</span>];</span><br><span class="line">        ++s;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;isStr=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(Trie *root,<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root!=<span class="literal">NULL</span>&amp;&amp;*s!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">        root=root-&gt;next[*s-<span class="string">'a'</span>];</span><br><span class="line">        ++s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (root!=<span class="literal">NULL</span>&amp;&amp;root-&gt;isStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(Trie *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=Trie::MAX;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;next[i]!=<span class="literal">NULL</span>)</span><br><span class="line">            del(root-&gt;next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u4F18_u5148_u961F_u5217_u548C_u5355_u8C03_u6808"><a href="#u4F18_u5148_u961F_u5217_u548C_u5355_u8C03_u6808" class="headerlink" title="优先队列和单调栈"></a>优先队列和单调栈</h4><p>可以使用<a href="http://www.cplusplus.com/reference/" target="_blank" rel="external">C++ STL</a> 的 priority_queue，查找可用 lower_bound 和 upper_bound 。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],L[N],R[N],stk[N]; <span class="comment">//L[i]: max x&lt;i s.t. h[x]&lt;x;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monoStack</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; h[stk[top-<span class="number">1</span>]] &gt;= h[j]) --top;</span><br><span class="line">        L[j] = (top == <span class="number">0</span>?<span class="number">0</span>:stk[top-<span class="number">1</span>]);</span><br><span class="line">        stk[top++] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; h[stk[top-<span class="number">1</span>]] &gt;= h[j]) --top;</span><br><span class="line">        R[j] = top == <span class="number">0</span>?n+<span class="number">1</span>:stk[top-<span class="number">1</span>];</span><br><span class="line">        stk[top++] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>详见<a href="http://dna049.com/2016/04/10/POJ2559-monostack/">我的博文</a>。</p>
</blockquote>
<h2 id="u56FE_u8BBA"><a href="#u56FE_u8BBA" class="headerlink" title="图论"></a>图论</h2><h4 id="u6700_u5927_u6D41"><a href="#u6700_u5927_u6D41" class="headerlink" title="最大流"></a>最大流</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node&#123;</span><br><span class="line">    <span class="keyword">int</span> t,w,next;</span><br><span class="line">&#125;a[N*N];</span><br><span class="line"><span class="keyword">int</span> n,ss,head[N],p[N],flow[N],c[N],h[N],numh[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    a[ss].t=y;</span><br><span class="line">    a[ss].w=w;</span><br><span class="line">    a[ss].next=head[x];</span><br><span class="line">    head[x]=ss++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow,ans=<span class="number">0</span>,neck,k;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(numh,<span class="number">0</span>,<span class="keyword">sizeof</span>(numh));</span><br><span class="line">    <span class="built_in">memset</span>(p,-<span class="number">1</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)   c[i]=head[i];</span><br><span class="line">    numh[<span class="number">0</span>]=n;</span><br><span class="line">    <span class="keyword">int</span> u=s;</span><br><span class="line">    <span class="keyword">while</span>(h[s]&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==t)&#123;</span><br><span class="line">            flow=<span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i!=t;i=a[c[i]].t)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flow&gt;a[c[i]].w)&#123;</span><br><span class="line">                    neck=i;flow=a[c[i]].w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i!=t;i=a[c[i]].t)&#123;</span><br><span class="line">                a[c[i]].w-=flow;</span><br><span class="line">                a[c[i]^<span class="number">1</span>].w+=flow;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=flow;</span><br><span class="line">            u=neck;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(k=c[u];k!=-<span class="number">1</span>;k=a[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k].w&amp;&amp;h[u]==h[a[k].t]+<span class="number">1</span>)   <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k!=-<span class="number">1</span>)&#123;</span><br><span class="line">            c[u]=k;</span><br><span class="line">            p[a[k].t]=u;</span><br><span class="line">            u=a[k].t;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>==--numh[h[u]]) <span class="keyword">break</span>;</span><br><span class="line">            c[u]=head[u];</span><br><span class="line">            k=n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=-<span class="number">1</span>;i=a[i].next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i].w)  k=min(k,h[a[i].t]);</span><br><span class="line">            &#125;</span><br><span class="line">            h[u]=k+<span class="number">1</span>;</span><br><span class="line">            ++numh[h[u]];</span><br><span class="line">            <span class="keyword">if</span>(u!=s)    u=p[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Stoer-Wagner__u6700_u5C0F_u5272"><a href="#Stoer-Wagner__u6700_u5C0F_u5272" class="headerlink" title="Stoer-Wagner 最小割"></a>Stoer-Wagner 最小割</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">102</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],dis[N],<span class="built_in">map</span>[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mincut</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;++i)   p[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">1</span>,s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;++i)&#123;</span><br><span class="line">            dis[p[i]]=<span class="built_in">map</span>[p[<span class="number">0</span>]][p[i]];</span><br><span class="line">            <span class="keyword">if</span>(dis[p[i]]&gt;dis[p[t]]) t=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        vis[p[<span class="number">0</span>]]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ret&gt;dis[p[t]]) ret=dis[p[t]];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j!=n;++j)&#123;</span><br><span class="line">                    <span class="built_in">map</span>[p[j]][p[s]]+=<span class="built_in">map</span>[p[j]][p[t]];</span><br><span class="line">                    <span class="built_in">map</span>[p[s]][p[j]]=<span class="built_in">map</span>[p[j]][p[s]];</span><br><span class="line">                &#125;</span><br><span class="line">                p[t]=p[--n];</span><br><span class="line">            &#125;</span><br><span class="line">            vis[p[t]]=<span class="literal">true</span>;</span><br><span class="line">            s=t;t=-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j!=n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[p[j]])&#123;</span><br><span class="line">                    dis[p[j]]+=<span class="built_in">map</span>[p[j]][p[s]];</span><br><span class="line">                    <span class="keyword">if</span>(t==-<span class="number">1</span>||dis[p[j]]&gt;dis[p[t]])  t=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6700_u77ED_u8DEFSPFA"><a href="#u6700_u77ED_u8DEFSPFA" class="headerlink" title="最短路SPFA"></a>最短路SPFA</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1004</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],rehead[N],dist[N],sc,v[N];</span><br><span class="line"><span class="keyword">struct</span> A&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> g;</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> x,<span class="keyword">int</span> y):id(x),g(y)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> A&amp; a)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> g+dist[id]&gt;a.g+dist[a.id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> Node&#123;</span><br><span class="line">    <span class="keyword">int</span> ed;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    e[sc].ed=y;</span><br><span class="line">    e[sc].w=z;</span><br><span class="line">    e[sc].next=head[x];</span><br><span class="line">    head[x]=sc++;</span><br><span class="line">    e[sc].ed=x;</span><br><span class="line">    e[sc].w=z;</span><br><span class="line">    e[sc].next=rehead[y];</span><br><span class="line">    rehead[y]=sc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    v[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=rehead[u];i!=-<span class="number">1</span>;i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> ed=e[i].ed;</span><br><span class="line">            <span class="keyword">if</span>(dist[ed]&gt;dist[u]+e[i].w)&#123;</span><br><span class="line">                dist[ed]=dist[u]+e[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!v[ed])&#123;</span><br><span class="line">                    v[ed]=<span class="literal">true</span>;</span><br><span class="line">                    q.push(ed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v[u]=<span class="literal">false</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u51E0_u4F55"><a href="#u51E0_u4F55" class="headerlink" title="几何"></a>几何</h2><h4 id="u4E8C_u7EF4_u51F8_u5305"><a href="#u4E8C_u7EF4_u51F8_u5305" class="headerlink" title="二维凸包"></a>二维凸包</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const int N=501;</span><br><span class="line">int vc[N];</span><br><span class="line">struct Node&#123;</span><br><span class="line">    int x,y,id;</span><br><span class="line">    bool operator!=(const Node&amp; A)const&#123;</span><br><span class="line">        return x!=A.x||y!=A.y;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&lt;(const Node&amp; A)const&#123;</span><br><span class="line">        if(y==A.y)  return x&lt;A.x;</span><br><span class="line">        return y&lt;A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N],q[N];</span><br><span class="line">bool crossLeft(const Node&amp; op,const Node&amp; sp,const Node&amp; ep)&#123;</span><br><span class="line">    return (sp.x-op.x)*(ep.y-op.y)&gt;(sp.y-op.y)*(ep.x-op.x);</span><br><span class="line">&#125;</span><br><span class="line">int graham(int n)&#123;</span><br><span class="line">    sort(p,p+n);</span><br><span class="line">    if(n==0)    return 0;q[0]=p[0];</span><br><span class="line">    if(n==1)    return 1;q[1]=p[1];</span><br><span class="line">    if(n==2)    return 2;q[2]=p[2];</span><br><span class="line">    int top=1;</span><br><span class="line">    for(int i=2;i!=n;++i)&#123;</span><br><span class="line">        while(top&amp;&amp;crossLeft(q[top],p[i],q[top-1])) --top;</span><br><span class="line">        q[++top]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int len=top;</span><br><span class="line">    q[++top]=p[n-2];</span><br><span class="line">    for(int i=n-3;i!=-1;--i)&#123;</span><br><span class="line">        while(top!=len&amp;&amp;crossLeft(q[top],p[i],q[top-1]))    --top;</span><br><span class="line">        q[++top]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u51E0_u7C7B_u6839_u53F7_u7B97_u6CD5"><a href="#u51E0_u7C7B_u6839_u53F7_u7B97_u6CD5" class="headerlink" title="几类根号算法"></a>几类根号算法</h2><h4 id="1-_24s_28n_29__3D__5Csum__7Bi_3D1_7D_5E_7Bn_7D__5Clfloor__5Cfrac_7Bn_7D_7Bi_7D__5Crfloor__24"><a href="#1-_24s_28n_29__3D__5Csum__7Bi_3D1_7D_5E_7Bn_7D__5Clfloor__5Cfrac_7Bn_7D_7Bi_7D__5Crfloor__24" class="headerlink" title="1.$s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $"></a>1.$s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(LL n)</span></span>&#123; </span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123; </span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        sum += (j-i+<span class="number">1</span>)*(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-_24_5Csum__7Bi_3D1_7D_5En__5Clfloor__5Cfrac_7Bn_7D_7Bi_7D__5Crfloor__5Clfloor__5Cfrac_7Bm_7D_7Bi_7D__5Crfloor_f_28i_29_24"><a href="#2-_24_5Csum__7Bi_3D1_7D_5En__5Clfloor__5Cfrac_7Bn_7D_7Bi_7D__5Crfloor__5Clfloor__5Cfrac_7Bm_7D_7Bi_7D__5Crfloor_f_28i_29_24" class="headerlink" title="2.$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$"></a>2.$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123; <span class="comment">// g[i]=f[i]+g[i-1]</span></span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j;i&lt;=min(n,m);i=j+<span class="number">1</span>)&#123;</span><br><span class="line">		j=min(n/(n/i),m/(m/i)</span><br><span class="line">		sum += LL(n/i)*(m/i)*(g[j]-g[i-<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-_24h_28n_29__3D__5Cfrac_7Bn_28n-1_29_28n-2_29_7D_7B3_7D_-__5Csum__7Bi_3D2_7D_5En_h_28_5Clfloor__5Cfrac_7Bn_7D_7Bi_7D__5Crfloor_29_24"><a href="#3-_24h_28n_29__3D__5Cfrac_7Bn_28n-1_29_28n-2_29_7D_7B3_7D_-__5Csum__7Bi_3D2_7D_5En_h_28_5Clfloor__5Cfrac_7Bn_7D_7Bi_7D__5Crfloor_29_24" class="headerlink" title="3.$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$"></a>3.$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it = mp.find(n);</span><br><span class="line">    <span class="keyword">if</span> (it != mp.end())  <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    <span class="keyword">int</span> r = LL(n)*(n-<span class="number">1</span>)%M*(n-<span class="number">2</span>)%M*inv3%M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        r -= LL(j-i+<span class="number">1</span>)*getans(n/i)%M;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>) r+=M;</span><br><span class="line">    &#125;</span><br><span class="line">    mp.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(n,r));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="To_Be_Continue"><a href="#To_Be_Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>突然想到在此留点模板貌似是个不错的选择也 0.0</p>
<blockquote>
<p>虽说程序需求千变万化，但是一些短小精湛的函数块还是很值得整理收藏的。<br>在此提醒自己：找到一种慢的解法可能是找到最终解法的一步。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Composed by dna049 at <span class="number">2016</span>-<span class="number">4</span>-<span class="number">10</span> in FDU</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网站推荐]]></title>
    <link href="http://dna049.com/2020/02/02/Recommended-Site/"/>
    <id>http://dna049.com/2020/02/02/Recommended-Site/</id>
    <published>2020-02-01T18:02:00.000Z</published>
    <updated>2016-05-05T23:40:45.000Z</updated>
    <content type="html"><![CDATA[<p>这里记录一些有用的，有趣的网站。一来便于查阅，二来用于分享。长期更新。<br>本人博客：<a href="http://dna049.com">dna049</a> 本质是指向域名<a href="http://dna049.github.io" target="_blank" rel="external">dna049.github.io</a> 的。 </p>
<blockquote>
<p>不具名的博主不管有没有观众，谢谢侬 0.0</p>
</blockquote>
<h4 id="1-__u6570_u5B66_u3001_u8BA1_u7B97_u673A__u63A8_u8350_u535A_u5BA2"><a href="#1-__u6570_u5B66_u3001_u8BA1_u7B97_u673A__u63A8_u8350_u535A_u5BA2" class="headerlink" title="1. 数学、计算机 推荐博客"></a>1. 数学、计算机 推荐博客</h4><ol>
<li><a href="http://www.miskcoo.com" target="_blank" rel="external">miskcoo</a> </li>
<li><a href="http://zimpha.github.io" target="_blank" rel="external">zimpha</a></li>
<li><a href="http://matrix67.com" target="_blank" rel="external">matrix67</a></li>
<li><a href="http://blog.csdn.net/acdreamers" target="_blank" rel="external">ACdreamer</a></li>
<li><a href="http://picks.logdown.com" target="_blank" rel="external">Pick</a></li>
<li><a href="http://97littleleaf11.xyz" target="_blank" rel="external">littleleaf</a></li>
</ol>
<a id="more"></a>
<h4 id="2-__u6570_u5B66_u5DE5_u5177"><a href="#2-__u6570_u5B66_u5DE5_u5177" class="headerlink" title="2. 数学工具"></a>2. 数学工具</h4><ol>
<li><a href="http://gen.lib.rus.ec" target="_blank" rel="external">数学书下载神器</a></li>
<li><a href="http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/" target="_blank" rel="external">Example of Latex and Mathjax</a></li>
<li><a href="http://detexify.kirelabs.org/classify.html" target="_blank" rel="external">不知道如何输入Latex时</a></li>
<li><a href="http://www.ideone.com" target="_blank" rel="external">ideone 在线集成开发环境</a></li>
<li><a href="http://web2.0calc.com" target="_blank" rel="external">在线计算器</a></li>
<li><a href="http://visualgo.net" target="_blank" rel="external">算法可视化</a></li>
<li><a href="http://tool.oschina.net" target="_blank" rel="external">前端工具</a></li>
<li><a href="http://www.wolframalpha.com" target="_blank" rel="external">你要的它都知道: Wolframalpha</a></li>
</ol>
<h4 id="3-__u6742_u7C7B"><a href="#3-__u6742_u7C7B" class="headerlink" title="3. 杂类"></a>3. 杂类</h4><ol>
<li><a href="http://clonezone.link" target="_blank" rel="external">在线修改任意网页的内容</a> </li>
<li><a href="http://cn.diywz.com" target="_blank" rel="external">常用文件转换1</a></li>
<li><a href="http://www.docspal.com" target="_blank" rel="external">常用文件转换2</a></li>
<li><a href="http://www.tineye.com" target="_blank" rel="external">类似图片 搜索</a></li>
<li><a href="http://www.midomi.com" target="_blank" rel="external">哼歌识曲</a></li>
<li><a href="http://chineseposters.net" target="_blank" rel="external">又红又专的图集</a></li>
<li><a href="http://www.makepic.com" target="_blank" rel="external">制作印章</a></li>
<li><a href="http://www.freeroms.com/nes_roms_NUM.htm" target="_blank" rel="external">黑白机nes游戏资源和素材</a></li>
<li><a href="https://www.fodey.com/generators/animated/ninjatext.asp" target="_blank" rel="external">英文文本用小忍着的动画画出</a></li>
<li><a href="http://wigflip.com/signbot/" target="_blank" rel="external">在线生成液晶字幕</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里记录一些有用的，有趣的网站。一来便于查阅，二来用于分享。长期更新。<br>本人博客：<a href="http://dna049.com">dna049</a> 本质是指向域名<a href="http://dna049.github.io">dna049.github.io</a> 的。 </p>
<blockquote>
<p>不具名的博主不管有没有观众，谢谢侬 0.0</p>
</blockquote>
<h4 id="1-__u6570_u5B66_u3001_u8BA1_u7B97_u673A__u63A8_u8350_u535A_u5BA2"><a href="#1-__u6570_u5B66_u3001_u8BA1_u7B97_u673A__u63A8_u8350_u535A_u5BA2" class="headerlink" title="1. 数学、计算机 推荐博客"></a>1. 数学、计算机 推荐博客</h4><ol>
<li><a href="http://www.miskcoo.com">miskcoo</a> </li>
<li><a href="http://zimpha.github.io">zimpha</a></li>
<li><a href="http://matrix67.com">matrix67</a></li>
<li><a href="http://blog.csdn.net/acdreamers">ACdreamer</a></li>
<li><a href="http://picks.logdown.com">Pick</a></li>
<li><a href="http://97littleleaf11.xyz">littleleaf</a></li>
</ol>]]>
    
    </summary>
    
      <category term="个人" scheme="http://dna049.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最长递增子序列与连续子序列最大和]]></title>
    <link href="http://dna049.com/2016/05/08/nondecrase-subsequence/"/>
    <id>http://dna049.com/2016/05/08/nondecrase-subsequence/</id>
    <published>2016-05-08T11:27:50.000Z</published>
    <updated>2016-05-08T13:01:11.000Z</updated>
    <content type="html"><![CDATA[<p>最长递增子序列最常规的做法是 $O(n^2)$ 的动态规划（dp） 做法（很容易想到不多说了）。这里可以维护一个单调的数列使其复杂度降至 $O(n \log n)$。相应的最长递减、不升、不降子序列完全类似，相应修改即可。另外，这个问题让我想起另一个降低复杂度的经典例子：连续子序列最大和。从 $O(n^3)$ 到 $O(n^2)$ 再到 $O(n)$.<br><a id="more"></a></p>
<h2 id="u6700_u957F_u9012_u589E_u5B50_u5E8F_u5217"><a href="#u6700_u957F_u9012_u589E_u5B50_u5E8F_u5217" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><h4 id="u5047_u8BBE"><a href="#u5047_u8BBE" class="headerlink" title="假设"></a>假设</h4><p>我们用数组 $a$ 表示原始数列。用 $b[k]$ 表示长度为 $k$ 的不降子序列中尾数最小值。那么显然数组 $b$ 是单调递增的。初始状态 $b[1]=a[1],k=1$</p>
<h4 id="u7EF4_u62A4"><a href="#u7EF4_u62A4" class="headerlink" title="维护"></a>维护</h4><p>若 $a[i]&gt;b[k]$，则 $k=k+1,b[k]=a[i]$；否则,找到二分最小的 $j$ 使得 $b[j] \geq a[i]$ 然后 $b[j]=a[i]$。最终答案就是 $k$。</p>
<h4 id="u4F8B_u9898_uFF1APOJ_2533"><a href="#u4F8B_u9898_uFF1APOJ_2533" class="headerlink" title="例题：POJ 2533"></a>例题：POJ 2533</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// longest increasing subsquence</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    b[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;b[k]) b[++k]=a[i];</span><br><span class="line">        <span class="keyword">else</span>    b[lower_bound(b,b+k,a[i])-b]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// lower_bound(first,end,val) 表示在单增 [frist,end) 中首次大于等于 val 的位置</span></span><br><span class="line"><span class="comment">// upper_bound(first,end,val) 表示在单增 [frist,end) 中首次大于 val 的位置</span></span><br></pre></td></tr></table></figure>
<h2 id="u8FDE_u7EED_u5B50_u5E8F_u5217_u6700_u5927_u548C"><a href="#u8FDE_u7EED_u5B50_u5E8F_u5217_u6700_u5927_u548C" class="headerlink" title="连续子序列最大和"></a>连续子序列最大和</h2><p>$O(n^3)$ 实在不值一提。$O(n^2)$ 就是先预处理前 $m$ 项和。这里具体讲两种 O(n) 的做法。</p>
<ol>
<li>遍历序列对s进行累加，如果$s&lt;0$，将 $s$ 重置为$0$,每次更新Sum的最大值。最后便能求出最大值(注意序列中全为负数的情况)</li>
<li>设 $dp[i]$ 表示尾为 $i$ 的最大和。那么 $dp[i]=\max (dp[i-1],a[i])$ 。</li>
</ol>
<p>上述两种做法本质上是一致的，做法2可能更好理解。并且其实实现的时候我们没必要去用数组标记。</p>
<h4 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MSCS</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// maximal sum of continue subsquence,mind overflow</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r=a[<span class="number">0</span>],s=a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;++i)&#123;</span><br><span class="line">        s = max(s,<span class="number">0</span>);</span><br><span class="line">        s += a[i];</span><br><span class="line">        r = max(r,s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>最长递增子序列最常规的做法是 $O(n^2)$ 的动态规划（dp） 做法（很容易想到不多说了）。这里可以维护一个单调的数列使其复杂度降至 $O(n \log n)$。相应的最长递减、不升、不降子序列完全类似，相应修改即可。另外，这个问题让我想起另一个降低复杂度的经典例子：连续子序列最大和。从 $O(n^3)$ 到 $O(n^2)$ 再到 $O(n)$.<br>]]>
    
    </summary>
    
      <category term="dp" scheme="http://dna049.com/tags/dp/"/>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[模二次方程有解的充要条件]]></title>
    <link href="http://dna049.com/2016/05/06/mod-quadratic-equation/"/>
    <id>http://dna049.com/2016/05/06/mod-quadratic-equation/</id>
    <published>2016-05-06T12:41:26.000Z</published>
    <updated>2016-05-06T12:55:13.000Z</updated>
    <content type="html"><![CDATA[<p>设 $f(x) = ax^2+bx+c$, 在域 $\mathbb{F}_p$ 中何时有根。我们不妨只考虑 $0<a<p$ 的情形。因为="" $$="" 4af(x)="(2ax+b)^2" -="" (b^2-4ac)="" 因此我们设="" $d="b^2-4ac$" ，="" 显然可知="" $f(x)$="" 有根当且仅当="" $d$="" 是模="" $p$="" 二次剩余。至于求解也是很简单的事。="" <a="" id="more"><br>一个小的推广<br>$f(x,y) = ax^2+bxy+cy^2=0$ 显然有解 $(x,y)=(0,0)$ 。那么何时有非平凡解呢？其实非平方解等价于说 $x,y$ 在域 $\mathbb{F}_p$    中可逆，因此又回到上面单变量的情形了。</a<p$></p>
<blockquote>
<p>写这么短的博文确实0.0<br>虽然这个很简单，但是具体实现的时候会有很多trick。例如 $a=0,d=0,p=2$ 这些都是需要特判的。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>设 $f(x) = ax^2+bx+c$, 在域 $\mathbb{F}_p$ 中何时有根。我们不妨只考虑 $0<a<p$ 的情形。因为
$$ 4af(x) = (2ax+b)^2 - (b^2-4ac) $$
因此我们设 $d = b^2-4ac$ ， 显然可知 $f(x)$ 有根当且仅当 $d$ 是模 $p$ 二次剩余。至于求解也是很简单的事。]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Lucas定理及其在递推关系式中的作用]]></title>
    <link href="http://dna049.com/2016/04/23/Lucas-Theorem-and-its-Application-in-array/"/>
    <id>http://dna049.com/2016/04/23/Lucas-Theorem-and-its-Application-in-array/</id>
    <published>2016-04-23T01:47:27.000Z</published>
    <updated>2016-04-26T09:04:22.000Z</updated>
    <content type="html"><![CDATA[<p>在 ACM 竞赛中，由于 C++ 库中没有大数类，手写大数类有些麻烦且写好类接口再应用仍然很麻烦，因此我们经常在有限域 $\mathbb{Z}/\mathbb{Z}_p$ 中考虑问题。这里介绍一下 Lucas 定理，及在一类递推关系式中的应用。<br><a id="more"></a></p>
<h2 id="Lucas_u5B9A_u7406"><a href="#Lucas_u5B9A_u7406" class="headerlink" title="Lucas定理"></a>Lucas定理</h2><p>对任意非负整数 $m,n$ 和素数 $p$，我们有：<br>$$ C_{m} ^ n = \prod_{i=0} ^k C_{m_i} ^{n_i} \mod p$$<br>其中 $m = \sum_{i=0} ^k m_i p^i,n = \sum_{i=0} ^k n_i p^i$。<br><strong>Proof</strong>: 由组合数的定义<br>$$ C_{p} ^ n = \frac{p(p-1) \cdots (p-n+1)}{n(n-1) \cdots 1} $$<br>容易看出 $p \mid n! \, C_{p} ^ n $, 因此当 $n&lt;p$ 时，$p \mid C_{n} ^ p $。即我们有<br>$$ (1+x)^p = 1 + x^p \mod p$$<br>因此<br>$$ \begin{align}<br>\sum_{n=0}^m C_{m}^n x^n &amp;= (1+x)^m = \prod_{i=0} ^k \left( (1+x)^{p^i} \right)^{m_i} \\<br>&amp;=  \prod_{i=0}^k \left( 1+x^{p^i} \right)^{m_i} = \prod_{i=0}^k \left( \sum_{n_i=0}^{m_i} C_{n_i}^{m_i} x^{n_ip^i} \right) \\<br>&amp;= \sum_{n=0}^m \left(\prod_{i=0} ^k C_{m_i} ^{n_i} \right) x^n \mod p<br>\end{align} $$<br>由多项式对应系数相等，证毕。</p>
<h2 id="u4E00_u7C7B_u9012_u63A8_u5173_u7CFB_u51B3_u5B9A_u7684_u6570_u5217"><a href="#u4E00_u7C7B_u9012_u63A8_u5173_u7CFB_u51B3_u5B9A_u7684_u6570_u5217" class="headerlink" title="一类递推关系决定的数列"></a>一类递推关系决定的数列</h2><p>已知 $f(n) = (a+\sqrt{b})^n + (a-\sqrt{b})^n$ 则容易知道其可由 $f(0)=2,f(1)=2a$, $f(n)=2af(n-1)+(b-a^2)f(n-2)$ 相互决定。现在我们要计算 $f(n) \mod p$，其中 $p$ 是素数，如果 $b$ 是 $p$ 的二次剩余，就可以直接计算，并且可以看出此时 $f(n)$ 的周期是 $p-1$。否则，我们用矩阵的策略来计算，这个已经是套路了，可看<a href="http://dna049.com/2016/03/12/The-application-of-fast-pow-of-matrix-hdu5451/">我之前的博文</a>。<br>令 $ A = \left[ \begin{matrix} 2a &amp; b-a^2 \\ 1 &amp; 0 \end{matrix} \right] $ 则<br>$$ \left( \begin{matrix} f(n+1) \\ f(n) \end{matrix} \right) = A \left( \begin{matrix} f(n) \\ f(n-1) \end{matrix} \right) = A^n \left( \begin{matrix} 2a \\ 2 \end{matrix} \right) $$</p>
<p>即我们只需计算 $A^n$ 即可。并且<a href="http://dna049.com/2016/03/12/The-application-of-fast-pow-of-matrix-hdu5451/">我们知道</a> 可逆矩阵 $A^n$ 的周期是 $(p^2-1)(p^2-p)$。问题在于若 $p=1e9+7$ 这个周期要用 $__int128$ 来存储（其实这也是可以的，但是如果 $p=1e18+9$ 呢）。对于刚过所说的这种特殊情况。其实此时 $A$ 的周期（不一定是最小）为 $p^2-1$。实际上我们只要说明 $f(n)$ 的周期是 $p^2-1$ 即可。但对于一般的 $A$ 并不清楚。</p>
<p>因为 $f(p^2)$ 展开后不含 $\sqrt{b}$ 项，且由 Lucas 定理知道，$C_{p^2}^i,0 \leq i \leq p^2$ 中，非0数仅有 $C_{p^2}^0 = C_{p^2}^{p^2} = 1 \mod p$。因此 $f(p^2) = 2a^{p^2} = 2a \mod p$。<br>类似地，$C_{p^2+1}^i,0 \leq i \leq p^2+1$ 中，非0数仅有 $C_{p^2+1}^0,C_{p^2+1}^1,C_{p^2+1}^{p^2},C_{p^2+1}^{p^2+1} \mod p$。因此：<br>$$ f(p^2+1) = 2(a^{p^2+1} + (\sqrt{b})^{p^2+1})= 2(a^2+b) = f(2)$$<br>由$f(n)$的取值由前两项（相邻两项，后两项）唯一确定，因此$f(n+p^2-1) = f(n),n&gt;=0$。</p>
<h4 id="u6CE8_u610F_u4E8B_u9879"><a href="#u6CE8_u610F_u4E8B_u9879" class="headerlink" title="注意事项"></a>注意事项</h4><p>这类问题精彩需要注意的是：</p>
<ol>
<li>矩阵中元素本身是p的倍数时很容易出问题。</li>
<li>不要溢出，不要出现负数</li>
</ol>
<h2 id="HDU_5674"><a href="#HDU_5674" class="headerlink" title="HDU 5674"></a>HDU 5674</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">//#pragma comment(linker,"/STACK:10240000,10240000")</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">typedef pair&lt;LL,LL&gt; PLL;</span><br><span class="line">#define clr(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define PB push_back</span><br><span class="line">#define lrt rt&lt;&lt;1</span><br><span class="line">#define rrt rt&lt;&lt;1|1</span><br><span class="line">#define lson l,m,lrt</span><br><span class="line">#define rson m+1,r,rrt</span><br><span class="line">/*------ Welcome to visit blog of dna049: http://dna049.com ------*/</span><br><span class="line">const LL M = 1e9+7;</span><br><span class="line">LL mod = M;</span><br><span class="line">class Matrix&#123;</span><br><span class="line">public:</span><br><span class="line">    const static int N = 2; //col</span><br><span class="line">    LL a[N][N];</span><br><span class="line">    Matrix(LL a00=0,LL a01=0,LL a10=0,LL a11=0)&#123;</span><br><span class="line">        a[0][0]=a00;a[0][1]=a01;</span><br><span class="line">        a[1][0]=a10;a[1][1]=a11;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix operator+(const Matrix&amp; A)const&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">            for(int j=0;j&lt;N;++j)&#123;</span><br><span class="line">                R.a[i][j]=a[i][j]+A.a[i][j];</span><br><span class="line">                if(R.a[i][j]&gt;=mod)   R.a[i][j]-=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return R;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix operator*(const Matrix&amp; A)const&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">            for(int k=0;k&lt;N;++k)&#123;</span><br><span class="line">                for(int j=0;j&lt;N;++j)&#123;</span><br><span class="line">                    R.a[i][j] = (R.a[i][j]+a[i][k]*A.a[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Matrix pow(Matrix A,LL n)&#123;</span><br><span class="line">    Matrix R(1,0,0,1);</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) R=R*A;</span><br><span class="line">        n&gt;&gt;=1;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    return R;</span><br><span class="line">&#125;</span><br><span class="line">LL mul_mod(LL x,LL n,LL p)&#123;</span><br><span class="line">    LL r=0;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) r=(r+x)%p;</span><br><span class="line">        n&gt;&gt;=1;  x=(x+x)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line">LL pow_mod(LL x,LL n,LL p)&#123;</span><br><span class="line">    LL r=1;</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) r=mul_mod(r,x,p);</span><br><span class="line">        n&gt;&gt;=1;  x=mul_mod(x,x,p);</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span><br><span class="line">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span><br><span class="line">    int T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        LL a,b,x,y;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        Matrix A((a*2)%mod,((b-a*a)%mod+mod)%mod,1,0);</span><br><span class="line">        A = pow(A,pow_mod(x,y,M*M-1));</span><br><span class="line">        cout&lt;&lt;(A.a[1][0]*a*2+A.a[1][1]*2)%mod&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 ACM 竞赛中，由于 C++ 库中没有大数类，手写大数类有些麻烦且写好类接口再应用仍然很麻烦，因此我们经常在有限域 $\mathbb{Z}/\mathbb{Z}_p$ 中考虑问题。这里介绍一下 Lucas 定理，及在一类递推关系式中的应用。<br>]]>
    
    </summary>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速数论变换]]></title>
    <link href="http://dna049.com/2016/04/22/Fast-number-translation/"/>
    <id>http://dna049.com/2016/04/22/Fast-number-translation/</id>
    <published>2016-04-22T08:26:59.000Z</published>
    <updated>2016-05-05T04:31:11.000Z</updated>
    <content type="html"><![CDATA[<p>快速数论变换（FNT）是环 $\mathbb{Z}/\mathbb{Z}_m$ 上的 Fourier 变换（FFT）。<br>至于 快速 Fourier 变换是怎样的有什么用处，这里就不多说了，可参考<a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform#i-15" target="_blank" rel="external">这里</a>。<br><a id="more"></a></p>
<h2 id="NFT__u7684_u6838_u5FC3_u95EE_u9898"><a href="#NFT__u7684_u6838_u5FC3_u95EE_u9898" class="headerlink" title="NFT 的核心问题"></a>NFT 的核心问题</h2><p>无论是 FNT 还是 FFT 其本质其关键就是寻找一个 $w$ 使得 $w^{2^n} = 1$。在复数域中这个问题是显然的，而在一个环那就不那么简单了，这里我们考虑环 $R = \mathbb{Z}/\mathbb{Z}_m$。$R$ 为域当且仅当 $m$ 为素数。我们的问题是 </p>
<ol>
<li>我们选取 $R$ 中找比较大（满足我们的需求）的 $n$ 使得 $w^{2^n} = 1$ ；</li>
<li>找出对应的“原根“；</li>
<li>类似 FFT 的处理</li>
<li>应用时各种可能出错的情形，最常见的是溢出,还有只适用于数据范围不超过P的非负整数。</li>
</ol>
<h2 id="NFT__u95EE_u9898_u89E3_u51B3"><a href="#NFT__u95EE_u9898_u89E3_u51B3" class="headerlink" title="NFT 问题解决"></a>NFT 问题解决</h2><p>  为使得分析问题更为简单，我们考虑在$m = p$ 为素数的情形，此时，我们有 $2^n \mid p-1$ 即 $p=k 2^n+1$ 为(Fermat)素数，例如：</p>
<ol>
<li>$p=479 \times 2^{21} +1 = 1004535809,g = 3$</li>
<li>$p= 13 \times 2^{20} + 1 = 13631489,g = 15$</li>
<li>$p= 17 \times 2^{27} + 1 = 2281701377,g=3$<br>更多常数选择可见<a href="http://blog.miskcoo.com/2014/07/fft-prime-table" target="_blank" rel="external">这里</a>。</li>
</ol>
<p>最终我们选择了 $FM = 1004535809$ 它的优势在于,它的两倍不超过 int 它的乘积不超过 long long 很有利于我们的运算，如果使用刚好不超过 long long 的数使用时很容易出现溢出并不方便。并且它恰好比较大。避免了做完 FFT 出现溢出。另外它可以取到的最大的 $N&gt;2e6$ 也很不错。例如现在如果我们要做 $2^k,k \leq 21$ 的 NFT。那么我们取 $w = g^{\frac{p-1}{2^k}}$ 即可。</p>
<h2 id="HDU_1402"><a href="#HDU_1402" class="headerlink" title="HDU 1402"></a>HDU 1402</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------ Welcome to visit blog of dna049: http://dna049.com ------*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">132005</span>;</span><br><span class="line"><span class="keyword">char</span> sa[N&gt;&gt;<span class="number">1</span>],sb[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line">LL a[N],b[N];</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;</span><br><span class="line">    LL r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%p;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=x*x%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a,LL p)</span></span>&#123; <span class="comment">// 0&lt;a&lt;p and gcd(a,p)=1</span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (p-p/a)*inv(p%a,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(LL *x,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=i,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;loglen;++j,t&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            k=(k&lt;&lt;<span class="number">1</span>)|(t&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;i) swap(x[i],x[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> LL FM = <span class="number">479</span>&lt;&lt;<span class="number">21</span>|<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nft</span><span class="params">(LL *x,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen,<span class="keyword">bool</span> isInverse)</span></span>&#123;</span><br><span class="line">    LL g = pow_mod(<span class="number">3</span>,(FM-<span class="number">1</span>)&gt;&gt;loglen,FM);</span><br><span class="line">    <span class="keyword">if</span>(isInverse)&#123;</span><br><span class="line">        g=inv(g,FM);</span><br><span class="line">        LL invlen = inv(len,FM);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">            x[i]=x[i]*invlen%FM;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    change(x,len,loglen);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">2</span>;step&lt;=len;step&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> half = step&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        LL wn = pow_mod(g,len/step,FM);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=step)&#123;</span><br><span class="line">            LL w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&lt;i+half;++j)&#123;</span><br><span class="line">                LL t=(w*x[j+half])%FM;</span><br><span class="line">                x[j+half]=(x[j]-t+FM)%FM;</span><br><span class="line">                x[j]=(x[j]+t)%FM;</span><br><span class="line">                w = w*wn%FM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,sa,sb))&#123;</span><br><span class="line">        <span class="keyword">int</span> alen=(<span class="keyword">int</span>)<span class="built_in">strlen</span>(sa);</span><br><span class="line">        <span class="keyword">int</span> blen=(<span class="keyword">int</span>)<span class="built_in">strlen</span>(sb);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>,loglen=<span class="number">0</span>,tmp=alen+blen+<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(len&lt;tmp)&#123;</span><br><span class="line">            len&lt;&lt;=<span class="number">1</span>;++loglen;</span><br><span class="line">        &#125;</span><br><span class="line">        clr(a,<span class="number">0</span>);clr(b,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=alen;++i)    a[i]=sa[alen-i-<span class="number">1</span>]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=blen;++i)    b[i]=sb[blen-i-<span class="number">1</span>]-<span class="string">'0'</span>;</span><br><span class="line">        nft(a,len,loglen,<span class="number">0</span>);</span><br><span class="line">        nft(b,len,loglen,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">            a[i] = a[i]*b[i]%FM;</span><br><span class="line">        &#125;</span><br><span class="line">        nft(a,len,loglen,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt&lt;len)&#123;</span><br><span class="line">            a[cnt+<span class="number">1</span>]+=a[cnt]/<span class="number">10</span>;</span><br><span class="line">            a[cnt]%=<span class="number">10</span>;++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt=alen+blen;</span><br><span class="line">        <span class="keyword">while</span>(cnt&gt;<span class="number">1</span>&amp;&amp;a[cnt-<span class="number">1</span>]==<span class="number">0</span>)    --cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>((<span class="keyword">int</span>)a[i]+<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>快速数论变换（FNT）是环 $\mathbb{Z}/\mathbb{Z}_m$ 上的 Fourier 变换（FFT）。<br>至于 快速 Fourier 变换是怎样的有什么用处，这里就不多说了，可参考<a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform#i-15">这里</a>。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[$\pi(x)$ 的计算]]></title>
    <link href="http://dna049.com/2016/04/21/The-computer-of-pi-x/"/>
    <id>http://dna049.com/2016/04/21/The-computer-of-pi-x/</id>
    <published>2016-04-21T08:37:56.000Z</published>
    <updated>2016-05-05T04:36:33.000Z</updated>
    <content type="html"><![CDATA[<p>$\pi(x)$ 表示不超过 $x$ 的素数个数。容易看出可以在 $O(N)$时间复杂度，$O(N)$ 空间复杂度离线预处理求出小于 $N$ 的素数全体。但是如果 $N=10^{12}$ 或者更大，这种做法必然是不现实的。因此下面给出高效的求解方法…<br><a id="more"></a></p>
<h2 id="1-__24_5Cphi_28x_2Cs_29_24"><a href="#1-__24_5Cphi_28x_2Cs_29_24" class="headerlink" title="1. $\phi(x,s)$"></a>1. $\phi(x,s)$</h2><p>设 $p_i$ 为第 $i$ 个素数，$\phi(x,s)$ 表示不超过 $x$ 且能不能被 $p_i,(1 \leq i \leq s)$ 整除的正整数个数。即<br>$$ \phi(x,s) = \sum_{n \leq x} \sum_{d|(n,p)} \mu(d) = \sum_{d|p} u(d)\lfloor \frac{x}{d} \rfloor $$<br>其中 $p = p_1 \cdots p_s$。</p>
<p>另一方面，显然我们有<br>$$ \phi(x,s) = \phi(x,s-1) - \phi(\frac{x}{p_s},s-1) $$</p>
<h2 id="2-__24_5Cpi_28x_29_24"><a href="#2-__24_5Cpi_28x_29_24" class="headerlink" title="2. $\pi(x)$"></a>2. $\pi(x)$</h2><p>我们知道一个数 $n&gt;1$ 是素数当且仅当不存在 $p \leq \sqrt{n}$ 使得 $p \mid n$。因此当 $s \geq \pi(\sqrt{x})$ 时，<br>$$\phi(x,s) = \pi(x) - s + 1$$</p>
<h2 id="3-__24P_k_28x_2Cs_29_24"><a href="#3-__24P_k_28x_2Cs_29_24" class="headerlink" title="3. $P_k(x,s)$"></a>3. $P_k(x,s)$</h2><p>设 $P_k(x,s)$ 为不大于 $x$ 且正好有 $k$ 个大于 $p_s$ 的素因子(按重根计)的整数个数（方法属于 Lehmer）。进一步设 $P_0(x,s)=1$。则<br>$$ \phi(x,s) = \sum_{k=0} ^{\infty} P_k(x,s) $$<br>显然 $P_1(x,s) = \pi(x)-s$。</p>
<p>若 $\pi(\sqrt[3]{x}) \leq s \leq \pi(\sqrt{x})$ 则 $P_k(x,s)=0,k \geq 3$ 此时<br>$$ \phi(x,s) = 1 + \pi(x)-s + P_2(x,s) $$<br>其中<br>$$ P_2(x,s) = \sum_{k=s+1}^{\pi(\sqrt{x})} \left( \pi(\frac{x}{p_k}) - k + 1 \right) $$<br>即<br>$$ \phi(x,s) = \pi(x)  + \sum_{k=s+1}^{\pi(\sqrt{x})} \pi(\frac{x}{p_k}) - \frac{(\pi(\sqrt{x})+s-2)(\pi(\sqrt{x})-s+1)}{2} $$</p>
<h2 id="4-__24_5Cpi_28x_29_24__u7684_u8BA1_u7B97_u516C_u5F0F"><a href="#4-__24_5Cpi_28x_29_24__u7684_u8BA1_u7B97_u516C_u5F0F" class="headerlink" title="4. $\pi(x)$ 的计算公式"></a>4. $\pi(x)$ 的计算公式</h2><p>$$ \pi(x) = \phi(x,\pi(\sqrt[3]{x})) - \sum_{k=\pi(\sqrt[3]{x})+1}^{\pi(\sqrt{x})} \pi(\frac{x}{p_k}) + \frac{(\pi(\sqrt{x})+\pi(\sqrt[3]{x})-2)(\pi(\sqrt{x})-\pi(\sqrt[3]{x})+1)}{2} $$<br>因此问题最终转化成求 $\phi(x,\pi(\sqrt[3]{x}))$。它可以利用</p>
<ol>
<li>$\phi(x,0) = \lfloor x \rfloor$</li>
<li>$\phi(x,s) = \phi(x,s-1) - \phi(\frac{x}{p_s},s-1)$</li>
</ol>
<p>至此问题貌似就这么解决了。但是由于这个递归会使得程序效率大大降低，因此需要一些预处理操作。</p>
<ol>
<li>若 $x&lt;p_s$ 则 $\phi(x,s) ＝ 1$</li>
<li>给定一个小整数M，预处理出 $\phi(x,s)$,其中 $x &lt; PS=p_1 \cdots p_s,s&lt;=M$<br>则 $\phi(x,s) = \phi(x\%PS,s) + \lfloor \frac{x}{PS} \rfloor \phi(PS,s) $</li>
</ol>
<h2 id="5-__u66F4_u4E3A_u5B9E_u7528_u7684lehmer_u8BA1_u7B97_u516C_u5F0F"><a href="#5-__u66F4_u4E3A_u5B9E_u7528_u7684lehmer_u8BA1_u7B97_u516C_u5F0F" class="headerlink" title="5. 更为实用的lehmer计算公式"></a>5. 更为实用的lehmer计算公式</h2><p>令 $s = \pi(\sqrt[4]{x}),t=\pi(\sqrt[2]{x}),m=\pi(\sqrt[3]{x})$。则<br>$$ \begin{align}<br>\phi(x,s) &amp;= 1 + \pi(x) - s + P_2(x,s) + P_3(x,s) \\<br>&amp;= 1+ \pi(x) - s + \sum_{k=s+1}^{t} \left( \pi(\frac{x}{p_k}) - k +1 \right) + \sum_{k=s+1}^{m} P_2(\frac{x}{p_k},k-1) \\<br>&amp;= \pi(x) - \frac{(t-s+1)(t+s-2)}{2} + \sum_{k=s+1}^{t} \pi(\frac{x}{p_k}) \sum_{k=s+1}^{m} P_2(\frac{x}{p_k},k-1)<br>\end{align}<br>$$<br>即<br>$$ \pi(x) = \phi(x,s) + \frac{(t-s+1)(t+s-2)}{2} -\sum_{k=s+1}^{t}  \pi(\frac{x}{p_k}) - \sum_{k=s+1}^{m} P_2(\frac{x}{p_k},k-1)<br>$$</p>
<h2 id="6-__u4F8B_u9898_uFF1ACodeforce_665F"><a href="#6-__u4F8B_u9898_uFF1ACodeforce_665F" class="headerlink" title="6. 例题：Codeforce 665F"></a>6. 例题：Codeforce 665F</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e6</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> np[N];</span><br><span class="line"><span class="keyword">int</span> p[N],pi[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    np[<span class="number">0</span>]=np[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    pi[<span class="number">0</span>]=pi[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt &amp;&amp; i * p[j] &lt; N; ++j) &#123;</span><br><span class="line">            np[i * p[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>)	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PM = <span class="number">2</span>*<span class="number">3</span>*<span class="number">5</span>*<span class="number">7</span>*<span class="number">11</span>*<span class="number">13</span>*<span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> phi[PM+<span class="number">1</span>][M+<span class="number">1</span>],sz[M+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    getprime();</span><br><span class="line">    sz[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=PM;++i)  phi[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;++i)&#123;</span><br><span class="line">        sz[i]=p[i]*sz[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=PM;++j)&#123;</span><br><span class="line">            phi[j][i]=phi[j][i-<span class="number">1</span>]-phi[j/p[i]][i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrt2</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL r = (LL)<span class="built_in">sqrt</span>(x-<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">while</span>(r*r&lt;=x)   ++r;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(r-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrt3</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL r = (LL)cbrt(x-<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">while</span>(r*r*r&lt;=x)   ++r;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(r-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getphi</span><span class="params">(LL x,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">0</span>)  <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(s &lt;= M)  <span class="keyword">return</span> phi[x%sz[s]][s]+(x/sz[s])*phi[sz[s]][s];</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= p[s]*p[s])   <span class="keyword">return</span> pi[x]-s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= p[s]*p[s]*p[s] &amp;&amp; x&lt; N)&#123;</span><br><span class="line">        <span class="keyword">int</span> s2x = pi[sqrt2(x)];</span><br><span class="line">        LL ans = pi[x]-(s2x+s-<span class="number">2</span>)*(s2x-s+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s+<span class="number">1</span>;i&lt;=s2x;++i)&#123;</span><br><span class="line">            ans += pi[x/p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getphi(x,s-<span class="number">1</span>)-getphi(x/p[s],s-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getpi</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; N)   <span class="keyword">return</span> pi[x];</span><br><span class="line">    LL ans = getphi(x,pi[sqrt3(x)])+pi[sqrt3(x)]-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pi[sqrt3(x)]+<span class="number">1</span>,ed=pi[sqrt2(x)];i&lt;=ed;++i)&#123;</span><br><span class="line">        ans -= getpi(x/p[i])-i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">lehmer_pi</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; N)   <span class="keyword">return</span> pi[x];</span><br><span class="line">    <span class="keyword">int</span> a = (<span class="keyword">int</span>)lehmer_pi(sqrt2(sqrt2(x)));</span><br><span class="line">    <span class="keyword">int</span> b = (<span class="keyword">int</span>)lehmer_pi(sqrt2(x));</span><br><span class="line">    <span class="keyword">int</span> c = (<span class="keyword">int</span>)lehmer_pi(sqrt3(x));</span><br><span class="line">    LL sum = getphi(x, a) + LL(b + a - <span class="number">2</span>) * (b - a + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a + <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        LL w = x / p[i];</span><br><span class="line">        sum -= lehmer_pi(w);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; c) <span class="keyword">continue</span>;</span><br><span class="line">        LL lim = lehmer_pi(sqrt2(w));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= lim; j++) &#123;</span><br><span class="line">            sum -= lehmer_pi(w / p[j]) - (j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getans</span><span class="params">(LL x)</span></span>&#123; <span class="comment">// x &lt; 1e11</span></span><br><span class="line">    LL ans = pi[sqrt3(x)];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,ed=pi[sqrt2(x-<span class="number">1</span>)];i&lt;=ed;++i)&#123;</span><br><span class="line">        ans += lehmer_pi(x/p[i])-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;getans(n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7B80_u6D01_u7684DP_u505A_u6CD5_u3002"><a href="#u7B80_u6D01_u7684DP_u505A_u6CD5_u3002" class="headerlink" title="简洁的DP做法。"></a>简洁的DP做法。</h2><p>我们令 $dp(x,s) = \phi(x,s)-s+1$ 它的意义是，$2～x$ 中被前$s$ 个素数筛完后的伪素数个数。因此我们有 $dp(0,0)=0,dp(x,0)=x-1,x&gt;1,dp(x,\pi(\sqrt{x})) = \pi(x)$ 且有状态转移<br>$$ dp(x,s) = dp(x,s-1)-dp(\frac{x}{p_s},s-1)+s-1 $$<br>因为 $dp(p_{s-1},s) = s-1$,最后一项可以写成 $dp(p_{s-1},s)$。虽然上面需要二维数组，但是实际上我们可以优化成一维数组的情绪。因为<br>$$ dp(x,s) = dp(x,s-1)-dp(\frac{x}{p_s},s-1)+ dp(p_{s-1},s) $$<br>另外我们也不可能开 $O(n)$ 的数组，但是可以利用一种黑科技开 $O(\sqrt{n})$ 的数组即可达到我们的目的。<br>即我们用 $L[x]$ 表示 $dp(x,s)$ 用 $R[x]$ 表示 $dp(\frac{n}{x},s)$。</p>
<p>但是上述做法的复杂度为 $\frac{O(n)}{\log n}$。但是常数特别小，代码十分简洁。也可以<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">sqrt2</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL r = (LL)<span class="built_in">sqrt</span>(x-<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">while</span>(r*r&lt;=x)   ++r;</span><br><span class="line">    <span class="keyword">return</span> r-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sqrt3</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL r = (LL)cbrt(x-<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">while</span>(r*r*r&lt;=x)   ++r;</span><br><span class="line">    <span class="keyword">return</span> r-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">2</span>;</span><br><span class="line">LL L[N],R[N];</span><br><span class="line"><span class="function">LL <span class="title">getans</span><span class="params">(LL n)</span></span>&#123; <span class="comment">// n &lt; 1e12</span></span><br><span class="line">    LL rn = sqrt2(n);</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=rn;++i)   R[i]=n/i-<span class="number">1</span>;</span><br><span class="line">    LL ln = n/(rn+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=ln;++i)   L[i]=i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL p=<span class="number">2</span>;p&lt;=rn;++p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L[p]==L[p-<span class="number">1</span>])    <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(LL i=<span class="number">1</span>,tn=min(n/(p*p),rn);i&lt;=tn;++i)&#123;</span><br><span class="line">            R[i] -= (i*p&lt;=rn?R[i*p]:L[n/(i*p)])-L[p-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(LL i=ln;i&gt;=p*p;--i)&#123;</span><br><span class="line">            L[i] -= L[i/p]-L[p-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = L[sqrt3(n)];</span><br><span class="line">    <span class="keyword">for</span>(LL p=<span class="number">2</span>;p&lt;=rn;++p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L[p] == L[p-<span class="number">1</span>])  <span class="keyword">continue</span>;</span><br><span class="line">        ans += R[p]-L[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;getans(n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>$\pi(x)$ 表示不超过 $x$ 的素数个数。容易看出可以在 $O(N)$时间复杂度，$O(N)$ 空间复杂度离线预处理求出小于 $N$ 的素数全体。但是如果 $N=10^{12}$ 或者更大，这种做法必然是不现实的。因此下面给出高效的求解方法…<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="初等数论" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[环的素谱Zariski拓扑]]></title>
    <link href="http://dna049.com/2016/04/17/Spectrum-and-Zariski-Topology-of-a-Ring/"/>
    <id>http://dna049.com/2016/04/17/Spectrum-and-Zariski-Topology-of-a-Ring/</id>
    <published>2016-04-17T12:28:36.000Z</published>
    <updated>2016-04-19T03:27:22.000Z</updated>
    <content type="html"><![CDATA[<p>设 $A$ 是(交换)环。令 $X$ 为 $A$ 的素理想全体，定义 $V(E)$ 为 $A$ 中包含 $E$ 的素理想全体，则将所有 $V(E)$ 看做闭集，它满足拓扑空间三条公理，即构成了拓扑，该拓扑称作 Zariski 拓扑，这个拓扑空间叫做环$A$的素谱，记作 $Spec(A)$。<br>有了拓扑，我们自然要考虑 1.集合的内部、闭包。2.拓扑的基，拓扑的分离性，紧性，3.空间的连通性，不可约性，4.拓扑空间的连续函数等等概念在这个具体拓扑下的样子。<br><a id="more"></a></p>
<h2 id="Zariski__u62D3_u6251"><a href="#Zariski__u62D3_u6251" class="headerlink" title="Zariski 拓扑"></a>Zariski 拓扑</h2><p>要证明 $T = \lbrace V(E),E \subset A \rbrace$ 作为闭集确实构成了一个拓扑，即证明 $\emptyset \in T,X \in T$，且 $T$ 中任意并，有限交运算是封闭的。而显然我们有</p>
<ol>
<li>$V(0)=X,V(A)=\emptyset$</li>
<li>$\cap_{i \in I} V(E_i) = V(\cup_{i \in I}E_i)$</li>
<li>为说明 $V(E_1) \cap V(E_2) \in T$ 我们需要一些准备工作。</li>
</ol>
<p>设 $I(E)$ 为由 $E$ 生成的理想，定义<br>$$ \sqrt{\alpha} = \lbrace x\in A : x^n \in \alpha \rbrace$$<br>则显然我们有</p>
<ol>
<li>$\alpha \subset \sqrt{\alpha} = \sqrt{\sqrt{\alpha}}$</li>
<li>$\sqrt{\alpha \beta} = \sqrt{\alpha \cap \beta} = \sqrt{\alpha} \cap \sqrt{\beta}$</li>
<li>$\sqrt{\alpha}=(1) \Leftrightarrow \sqrt{\alpha}$</li>
<li>$\sqrt{\alpha+\beta} = \sqrt{ \sqrt{\alpha}+\sqrt{\beta} }$</li>
<li>若 $p$ 是素理想，$\sqrt{p} = p$。</li>
<li>$V(E)=V(I(E))=V(\sqrt{I(E)})$</li>
<li>$V(\alpha \cap \beta)=V(\alpha \beta)=V(\alpha) \cup V(\beta)$</li>
<li>$\cap_{p \in V(\alpha)} p = \sqrt{\alpha}$ </li>
<li>$V(E_1) = V(E_2) \Leftrightarrow \sqrt{I(E_1)} = \sqrt{I(E_2)}$</li>
</ol>
<p>因此，$V(E_1) \cap V(E_2) = V(I(E_1)) \cap V(I(E_2)) = V(I(E_1) \cap I(E_2)) \in T$。这说明它确实满足拓扑空间的三条公理。</p>
<h2 id="u4F8B_u5B50"><a href="#u4F8B_u5B50" class="headerlink" title="例子"></a>例子</h2><p>有了拓扑之后，我们自然用具体的例子来看一下，这个拓扑大致长什么样子。<br>考虑 $Spec(\mathbb{Z})$ ，此时 $X = \lbrace (p) : p\mbox{ is prime } \rbrace \cup (0)$。可以看出，包含 $(0)$ 闭集仅有 $X$，除 $(0)$ 外，$X$ 中的单点集全是闭集。因此 $Spec(\mathbb{Z})$ 不是 $T_1$ 空间，由此可见，一般地，$Spec(A)$ 不是 $T_1$ 空间，即此拓扑的分离性很差。</p>
<h2 id="u5185_u90E8_u548C_u95ED_u5305"><a href="#u5185_u90E8_u548C_u95ED_u5305" class="headerlink" title="内部和闭包"></a>内部和闭包</h2><p>因为在一般的拓扑理论中我们有 $A^{o} = A^{c-c}$，因此，我们只需搞清楚 $A^{o}$ 和 $A^{-}$( 或记作$\overline{A}$ )中任意一个即可，我们考虑闭包($A^{-}$)。对于 $Y \subset X$。若 $Y \subset V(E)$ 则 $\forall \; p \in Y, E \in p$,即 $ E \in \cap_{p \in Y} p$。因此 $Y \subset V(\cap_{p \in Y}) \subset V(E)$。因此 $Y^{-} = V(\cap_{p \in Y})$。<br>特别地，</p>
<ol>
<li>$\overline{\lbrace p_x \rbrace} = V(p_x)$</li>
<li>$\overline{\lbrace p_x \rbrace} = \lbrace p_x \rbrace \Leftrightarrow p_x$ 是极大理想。</li>
<li>$p_y \in \overline{\lbrace p_x \rbrace} \Leftrightarrow p_x \subset p_y$</li>
<li>$X$ 是 $T_0$ 空间（$p_y \notin \overline{\lbrace p_x \rbrace}$ 或者 $p_x \notin \overline{\lbrace p_y \rbrace}$）。</li>
</ol>
<p>因此，这样就很清楚为何在之前的例子$Spec(\mathbb{Z})$中除$(0)$外单点集都是闭集了。有了之前的结论我们再看一下其他的例子。<br>$Spec(\mathbb{R})$：此时 $X = \lbrace 0 \rbrace$ 只有一个元素拓扑是平凡的。<br>因为 若$A$为域,则$A[x]$为ED为PID，其素理想为 $(f)$ 不可约多项式。且PID中非零素理想就是极大理想。<br>$Spec(\mathbb{C}[x])$: 此时 $X = \lbrace (x+t): t \in \mathbb{C} \rbrace \cup \lbrace (0) \rbrace$<br>$Spec(\mathbb{R}[x])$: 此时 $X = \lbrace (x+t): t \in \mathbb{R} \rbrace \cup \lbrace (x^2+ax+b): a,b \in \mathbb{R},a^2 &lt; 4b \rbrace \cup \lbrace (0) \rbrace$</p>
<h2 id="u57FA_uFF0C_u7D27_u6027"><a href="#u57FA_uFF0C_u7D27_u6027" class="headerlink" title="基，紧性"></a>基，紧性</h2><p>由于 $V(\cup_{i \in I}E_i) = \cap_{i \in I} V(E_i)$ 我们定义 $X_E = X \setminus V(E)$。则 $X_E = \cup_{f \in E} X_f$ 这说明 $X_f,f \in A$ 确实构成了 $X$ 的一组基。$X_f$ 表示不包含 $f$ 的素理想全体。</p>
<ol>
<li>$X_f \cap X_g = X_{fg}$</li>
<li>$X_f = \emptyset \Leftrightarrow f$ 是幂零的。</li>
<li>$X_f = X \Leftrightarrow f$ 是单位。</li>
<li>$X_f = X_g \Leftrightarrow \sqrt{(f)} = \sqrt{(g)}$</li>
</ol>
<h4 id="24X_24__u662F_u62DF_u7D27_u7684"><a href="#24X_24__u662F_u62DF_u7D27_u7684" class="headerlink" title="$X$ 是拟紧的"></a>$X$ 是拟紧的</h4><blockquote>
<p>这里的拟紧,实际上就是一般点集拓扑学中的紧，在代数中紧这个概念是拟紧＋Hausdorff。</p>
</blockquote>
<p>我们只需证明：若 $\cup_{f \in S} X_f = X$ 则存在有限并使上式成立。实际上，<br>$$ \cup_{f \in S} X_f = X \Leftrightarrow V(I(S))=V(S) = \emptyset $$<br>因此 $I(S)=A$，即 $1 = \sum_{i=1}^n a_i s_i$。所以$I(s_1,\cdots,s_n) = A$，即 $\cup_{i=1}^n X_{s_i} = X$。证毕。</p>
<h4 id="24X_f_24__u662F_u62DF_u7D27_u7684"><a href="#24X_f_24__u662F_u62DF_u7D27_u7684" class="headerlink" title="$X_f$ 是拟紧的"></a>$X_f$ 是拟紧的</h4><p>我们只需证明：若 $X_f \subset \cup_{g \in S} X_g$，则存在有限并使上式成立。实际上，<br>$$ X_f \subset \cup_{g \in S} X_g  \Leftrightarrow V(\sqrt{I(S)}) = V(S) \subset V(f)$$<br>因此 $f \in \sqrt{I(S)}$，即 $f^m = \sum_{i=1}^n a_i s_i$。所以 $f^m \in I(s_1,\cdots,s_n)$即。$X_f \subset \cup_{i=1}^n X_{s_i}$。证毕。</p>
<h4 id="u4EFB_u610F_u5F00_u96C6__24Y__5Csubset_X_24__u662F_u62DF_u7D27_u7684_u5F53_u4E14_u4EC5_u5F53_24Y_24_u53EF_u4EE5_u5199_u6210_u6709_u9650_u591A_u4E2A_24X_f_24_u7684_u5E76_u3002"><a href="#u4EFB_u610F_u5F00_u96C6__24Y__5Csubset_X_24__u662F_u62DF_u7D27_u7684_u5F53_u4E14_u4EC5_u5F53_24Y_24_u53EF_u4EE5_u5199_u6210_u6709_u9650_u591A_u4E2A_24X_f_24_u7684_u5E76_u3002" class="headerlink" title="任意开集 $Y \subset X$ 是拟紧的当且仅当$Y$可以写成有限多个$X_f$的并。"></a>任意开集 $Y \subset X$ 是拟紧的当且仅当$Y$可以写成有限多个$X_f$的并。</h4><p>Proof: 由 $X_f$ 是拟紧的知道，“$\Leftarrow$” 是显然的。<br>“$\Rightarrow$” 是因为存在$E \subset A$ 使得<br>$$Y = X_E = \cup_{f \in E} X_f$$<br>是 $Y$ 的一个开覆盖，由于是拟紧的，因此可以写成有限个 $X_f$ 的并，证毕。</p>
<blockquote>
<p>以上结论来自Atiyah <strong>An Introduction to Coummutative Algebra</strong> 习题。内容和叙述方式完全由本人独立完成。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>设 $A$ 是(交换)环。令 $X$ 为 $A$ 的素理想全体，定义 $V(E)$ 为 $A$ 中包含 $E$ 的素理想全体，则将所有 $V(E)$ 看做闭集，它满足拓扑空间三条公理，即构成了拓扑，该拓扑称作 Zariski 拓扑，这个拓扑空间叫做环$A$的素谱，记作 $Spec(A)$。<br>有了拓扑，我们自然要考虑 1.集合的内部、闭包。2.拓扑的基，拓扑的分离性，紧性，3.空间的连通性，不可约性，4.拓扑空间的连续函数等等概念在这个具体拓扑下的样子。<br>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[循环节长度]]></title>
    <link href="http://dna049.com/2016/04/17/Length-of-period-of-fraction/"/>
    <id>http://dna049.com/2016/04/17/Length-of-period-of-fraction/</id>
    <published>2016-04-16T16:23:22.000Z</published>
    <updated>2016-04-19T09:33:36.000Z</updated>
    <content type="html"><![CDATA[<p>我们知道有理数可以写成有限小数和无限循环小数。无理数必然是无限不循环小数。下面对这个问题详细的分析并且给出相应的有理数转化成小数的代码。</p>
<a id="more"></a>
<p>回顾一下我们怎么做除法的，我们设 $p,q$ 为正整数。计算 $\frac{q}{p}$。首先给出两个显然的结论：</p>
<ol>
<li>$\frac{q}{p}$ 是整数，当且仅当 $p|q$；</li>
<li>$\frac{q}{p}$ 是有限小数，当且仅当 $\exists n, s.t p|10^n*q$。<br>我们把注意力放在结果是无限循环小数的情况上。</li>
</ol>
<h2 id="u90A3_u4E48_u4E3A_u4EC0_u4E48_u5206_u6570_u4E00_u5B9A_u53EF_u4EE5_u8868_u793A_u4E3A_u5FAA_u73AF_u5C0F_u6570_u5462_uFF1F"><a href="#u90A3_u4E48_u4E3A_u4EC0_u4E48_u5206_u6570_u4E00_u5B9A_u53EF_u4EE5_u8868_u793A_u4E3A_u5FAA_u73AF_u5C0F_u6570_u5462_uFF1F" class="headerlink" title="那么为什么分数一定可以表示为循环小数呢？"></a>那么为什么分数一定可以表示为循环小数呢？</h2><p>因为我们一直计算后余数总在 $0,p-1$ 之间，那么经过 $p$ 次计算后一定会与之前的的某一个一样，那么自此以后后来的结果自然也就一样了，也就产生了循环的现象。即我们需要找到最小的正整数 $m,n$ 使得 $10^m \equiv 10^(n+m) \mod p$。即 $10^m(10^n-1) \equiv 0 mod p$。由于 $gcd(2,10^n-1)=gcd(5,10^n-1)=1$。因此，除掉 $p$ 中包含 $2,5$ 的因子。则 $10^n-1 \equiv 0 mod p$。此方程一定有解。并且若$p$是素数，且$10$是 $p$ 的原根，则 $n=p-1$。说了这么多其实也是废话，还是看代码吧，代码里包含了所有细节。</p>
<pre><code class="C"><span class="function"><span class="built_in">string</span> <span class="title">rational</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>{
    <span class="keyword">if</span>(m==<span class="number">0</span>)    <span class="keyword">return</span> <span class="string">""</span>;
    <span class="built_in">string</span> r;
    <span class="keyword">if</span>(m&lt;<span class="number">0</span>) n=-n,m=-m;
    <span class="keyword">if</span>(n&lt;<span class="number">0</span>){
        n=-n;
        r.push_back(<span class="string">'-'</span>);
    }
    <span class="keyword">int</span> t = n/m;    <span class="comment">// get the integer part of n/m</span>
    <span class="keyword">if</span>(t==<span class="number">0</span>)    r.push_back(<span class="string">'0'</span>);
    <span class="keyword">while</span>(t){
        r.push_back(t%<span class="number">10</span>+<span class="string">'0'</span>);
        t/=<span class="number">10</span>;
    }
    r.reserve();
    n%=m;
    <span class="keyword">if</span>(n==<span class="number">0</span>)    <span class="keyword">return</span> r;
    r.push_back(<span class="string">'.'</span>);
    t = __gcd(n,m);
    n/=t;m/=t;
    <span class="keyword">while</span>(m%<span class="number">10</span>==<span class="number">0</span>){
        m/=<span class="number">10</span>;
        r.push_back(n/m+<span class="string">'0'</span>);
        n%=m;
    }
    <span class="keyword">while</span>(m%<span class="number">2</span>==<span class="number">0</span>){
        m/=<span class="number">2</span>;n*=<span class="number">5</span>;
        r.push_back(n/m+<span class="string">'0'</span>);
        n%=m;
    }
    <span class="keyword">while</span>(m%<span class="number">5</span>==<span class="number">0</span>){
        m/=<span class="number">5</span>;n*=<span class="number">2</span>;
        r.push_back(n/m+<span class="string">'0'</span>);
        n%=m;
    }
    <span class="keyword">if</span>(m==<span class="number">1</span>)    <span class="keyword">return</span> r;
    r.push_back(<span class="string">'('</span>);
    t=<span class="number">1</span>;
    <span class="keyword">do</span>{
        r.push_back(<span class="number">10</span>*n/m+<span class="string">'0'</span>);
        n=<span class="number">10</span>*n%m;
        t=<span class="number">10</span>*t%m;
    }<span class="keyword">while</span>(t!=<span class="number">1</span>);
    r.push_back(<span class="string">')'</span>);
    <span class="keyword">return</span> r;
}
</code></pre>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们知道有理数可以写成有限小数和无限循环小数。无理数必然是无限不循环小数。下面对这个问题详细的分析并且给出相应的有理数转化成小数的代码。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[POJ2559 单调栈]]></title>
    <link href="http://dna049.com/2016/04/10/POJ2559-monostack/"/>
    <id>http://dna049.com/2016/04/10/POJ2559-monostack/</id>
    <published>2016-04-10T11:27:49.000Z</published>
    <updated>2016-04-10T12:47:36.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2559" target="_blank" rel="external">POJ</a>上有一到有趣的题：求一个柱状图中面积最大的矩阵面积为多少?<br> 最暴力的方法当然0.0不值一提，下面看看如何用单调栈的方法解决<br><a id="more"></a><br><img src="poj2559.png" alt="poj2559"></p>
<h2 id="u5355_u8C03_u6808"><a href="#u5355_u8C03_u6808" class="headerlink" title="单调栈"></a>单调栈</h2><h4 id="u7EF4_u62A4_u5355_u8C03_u6808_uFF1A"><a href="#u7EF4_u62A4_u5355_u8C03_u6808_uFF1A" class="headerlink" title="维护单调栈："></a>维护单调栈：</h4><p>进栈操作：每次入栈前先检验栈顶元素和进栈元素x的大小，如果小于x，就让x直接入栈。如果栈顶元素大于等于x,那么出栈，直到栈空或者栈顶元素小于x</p>
<h4 id="u4F8B_u5B50"><a href="#u4F8B_u5B50" class="headerlink" title="例子"></a>例子</h4><p>$ a[\;] = \lbrace 1, 4, 5, 2, 0 \rbrace $</p>
<ol>
<li>初始栈为空，进栈，栈内元素(1)</li>
<li>4大于1，进栈。栈内元素(1,4)</li>
<li>5大于4，进栈。栈内元素(1,4,5)</li>
<li>2小于5,5出栈，2小于4,4出栈，2大于1,进栈，栈内元素(2)</li>
<li>0要入栈，2出栈，0进栈。栈内元素(0)</li>
</ol>
<h4 id="u7528_u9014_u53EF_u4EE5_u5728__24O_28n_29_24__u65F6_u95F4_u5185_u627E_u5230_24i_24_u4F4D_u7F6E_u5DE6_28_u53F3_29_u8FB9_u9996_u6B21_u6BD4_u5B83_u5C0F_u7684_u4F4D_u7F6E_u3002_u8BE6_u89C1POJ2559_u7684_u4EE3_u7801_u6C42_u89E3"><a href="#u7528_u9014_u53EF_u4EE5_u5728__24O_28n_29_24__u65F6_u95F4_u5185_u627E_u5230_24i_24_u4F4D_u7F6E_u5DE6_28_u53F3_29_u8FB9_u9996_u6B21_u6BD4_u5B83_u5C0F_u7684_u4F4D_u7F6E_u3002_u8BE6_u89C1POJ2559_u7684_u4EE3_u7801_u6C42_u89E3" class="headerlink" title="用途可以在 $O(n)$ 时间内找到$i$位置左(右)边首次比它小的位置。详见POJ2559的代码求解"></a>用途可以在 $O(n)$ 时间内找到$i$位置左(右)边首次比它小的位置。详见POJ2559的代码求解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],L[N],R[N],stk[N]; <span class="comment">//L[i]: max x&lt;i s.t. h[x]&lt;x;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monoStack</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; h[stk[top-<span class="number">1</span>]] &gt;= h[j]) --top;</span><br><span class="line">        L[j] = (top == <span class="number">0</span>?<span class="number">0</span>:stk[top-<span class="number">1</span>]);</span><br><span class="line">        stk[top++] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; h[stk[top-<span class="number">1</span>]] &gt;= h[j]) --top;</span><br><span class="line">        R[j] = top == <span class="number">0</span>?n+<span class="number">1</span>:stk[top-<span class="number">1</span>];</span><br><span class="line">        stk[top++] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,h+i);</span><br><span class="line">        &#125;</span><br><span class="line">        monoStack(n);</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            ans = max(ans,LL(h[i])*(R[i]-L[i]-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://poj.org/problem?id=2559">POJ</a>上有一到有趣的题：求一个柱状图中面积最大的矩阵面积为多少?<br> 最暴力的方法当然0.0不值一提，下面看看如何用单调栈的方法解决<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[love math love gcd]]></title>
    <link href="http://dna049.com/2016/04/10/love-math-love-gcd/"/>
    <id>http://dna049.com/2016/04/10/love-math-love-gcd/</id>
    <published>2016-04-10T06:05:22.000Z</published>
    <updated>2016-04-26T09:05:08.000Z</updated>
    <content type="html"><![CDATA[<p>关于gcd的博文已经写过三篇了，为什么还要写呢？(任意中文输入法下输入gcd)你就懂了0.0<br><a id="more"></a></p>
<h2 id="u8BA1_u7B97__24f_28n_29__3D__5Csum__7Bi_3D1_7D_5En__5Csum__7Bj_3D1_7D_5En__5Bgcd_28i_2Cj_29_3D_3D1_5D_24"><a href="#u8BA1_u7B97__24f_28n_29__3D__5Csum__7Bi_3D1_7D_5En__5Csum__7Bj_3D1_7D_5En__5Bgcd_28i_2Cj_29_3D_3D1_5D_24" class="headerlink" title="计算 $f(n) = \sum_{i=1}^n \sum_{j=1}^n [gcd(i,j)==1]$"></a>计算 $f(n) = \sum_{i=1}^n \sum_{j=1}^n [gcd(i,j)==1]$</h2><p>这里给出 $f(n)$ 的两个计算公式。</p>
<p>$$<br>n^2 = \sum_{d=1}^n \sum_{i=1}^{n} \sum_{j=1}^n [gcd(i,j)==d] =<br>\sum_{d=1}^n \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} [gcd(i,j)==1] = \sum_{d=1}^n f(\lfloor \frac{n}{d} \rfloor)<br>$$<br>因此由<a href="http://dna049.com/2016/01/03/Several-Algorithms-of-root-Complex/">之前的博文</a>可用记忆化搜索的方法求出$f(n)$ </p>
<p>$$<br>f(n) = \sum_{i=1}^n \sum_{j=1}^n [gcd(i,j)==1] =<br>\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor}  \sum_{d|i,d|j} \mu(d) = \sum_{d=1}^n \mu(d) (\lfloor \frac{n}{d} \rfloor)^2<br>$$<br>因此由<a href="http://dna049.com/2016/01/03/Several-Algorithms-of-root-Complex/">博文</a> 在预处理后可根号算法快速求出。<br>实际上，$f(n)$ 还有一个表达式。<br>$$ f(n)= 2 \sum_{i=1}{n} \phi(i) - 1 $$</p>
<p>为什么两个完全不同的式子都可以计算呢。实际上这是由<a href="http://dna049.com/2016/01/20/Dirichlet-product-of-number-function/">广义Dirchilet</a> 性质决定的。</p>
<h2 id="hdu5663_u4E00_u4E2A_u66F4_u590D_u6742_u7684_u4F8B_u5B50"><a href="#hdu5663_u4E00_u4E2A_u66F4_u590D_u6742_u7684_u4F8B_u5B50" class="headerlink" title="hdu5663一个更复杂的例子"></a>hdu5663一个更复杂的例子</h2><p>计算 $r(n,m)=\sum_{i=1}^n \sum_{j=1}^m f(gcd(i,j))$，其中$f(n)＝0$ 若 $n$ 是平方数，否则为 $1$。<br>解：我们不妨设 $n \leq m$。<br>$$<br>\begin{aligned}<br>r(n,m) &amp;=\sum_{i=1}^n \sum_{j=1}^m f(gcd(i,j)) \\<br>&amp;= \sum_{d=1}^n f(d) \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}  \sum_{t|i,t|j} \mu(t) \\<br>&amp;= \sum_{d=1}^n f(d) \sum_{t=1}^{\lfloor \frac{n}{d} \rfloor} \mu(t) \lfloor \frac{n}{dt} \rfloor \lfloor \frac{m}{dt} \rfloor \\<br>&amp;= \sum_{G=1}^n \lfloor \frac{n}{G} \rfloor \lfloor \frac{m}{G} \rfloor \sum_{t|G} \mu(t)f(\frac{G}{t})<br>\end{aligned}<br>$$<br>据此，我们可以给出下面代码。(上面过程技巧性很强，要充分利用 $\mu$ 的强大力量)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------ Welcome to visit blog of dna049: http://dna049.com ------*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N],g[N],p[N],np[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) &#123;</span><br><span class="line">            p[cnt++] = i;</span><br><span class="line">            mu[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt &amp;&amp; i * p[j] &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = i * p[j];</span><br><span class="line">            np[t] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j])   mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i*i*j&lt;N;++j)&#123;</span><br><span class="line">            g[i*i*j] += mu[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)    g[i]+=g[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        LL ans = LL(n)*m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j;i&lt;=min(n,m);i=j+<span class="number">1</span>)&#123;</span><br><span class="line">            j=min(n/(n/i),m/(m/i));</span><br><span class="line">            ans -= LL(n/i)*(m/i)*(g[j]-g[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于gcd的博文已经写过三篇了，为什么还要写呢？(任意中文输入法下输入gcd)你就懂了0.0<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Lie Algebra]]></title>
    <link href="http://dna049.com/2016/04/08/Lie-Algebra/"/>
    <id>http://dna049.com/2016/04/08/Lie-Algebra/</id>
    <published>2016-04-08T10:13:00.000Z</published>
    <updated>2016-05-02T08:55:11.000Z</updated>
    <content type="html"><![CDATA[<p>近期在整理 Lie Algebra 课的笔记，还是很喜欢这门课的，主要是本科时候矩阵玩的特别6，然后 Lie Algebra 可以认为是矩阵的推广版本。里面的证明技巧性相当强。我之所以喜欢数学很大程度与数学技巧有关。但是我的导师说，这些虽然很有技巧，但是你花时间都是可以处理的，会技巧没什么了不起，脑袋稍微好一点就能做这种事，长期技巧的训练其实意义并不大，应该更关注数学内部的东西，具体说就是一个代数对象的结构，分类，不变量，对象之间的同构。一个概念有哪些等价形式，与其它概念之间的关系，搞清楚这些更为重要，它们的证明只要大致知道怎么过来的就行。我们并不要把证明的细节放在心中，因为我们已经经过了多年的训练，相信我们通过大致步骤就能给出详细的证明，只是花的时间多少罢了。当然初学一个东西，去抠它的细节是无可厚非的。<br>以上纯属废话 0.0<br><a id="more"></a> </p>
<h3 id="u5B9A_u4E49"><a href="#u5B9A_u4E49" class="headerlink" title="定义"></a>定义</h3><p>交换环 $K$ 上的模 $L$，以及一个运算 $L \times L \to L,(x,y) \mapsto [x,y]$ 称为 $x,y$ 的 Lie 括号，或交换子，称 $L$ 是 $K$ 上的 <a href="https://en.wikipedia.org/wiki/Lie_algebra" target="_blank" rel="external">Lie Algebra</a> 如果满足如下公理。<br>L1. $[\cdot,\cdot]$ 是双线性的；<br>L2. $[x,x]=0$ 对任意 $x \in L$ 成立；<br>L3. $[x,[y,z]]+[y,[z,x]]+[z,[x,y]]=0$ (Jacobi 恒等式)</p>
<p>若$[L,L]=0$ 则上面结论显然成立，此时称为 Abelian Lie Algebra。令 $Z(L) = \lbrace x \in L \;|\; [x,L] = 0 \rbrace$</p>
<p>我们通常并不考虑如此一般情形下的 Lie 代数，一般我们令交换环 $K$ 是域 $F$，并且域 $F$ 很多时候要求是代数闭域，且特征为0。另外我们大多考虑 $L$ 是 $F$ 上的有限维线性空间。</p>
<p>子，理想，商，同态，表示等一系列的概念和其它代数结构几乎一致。基本上可以划入范畴中。另外单，半单，Radical等这些概念也于环里面的类似。</p>
<h3 id="u6837_u677F_Lie_Algebra"><a href="#u6837_u677F_Lie_Algebra" class="headerlink" title="样板 Lie Algebra"></a>样板 Lie Algebra</h3><p>对于 $V$ 是 $F$ 上有限维线性空间，用 $End V$ 表示 $V$ 到 $V$ 的线性变换全体按照元素的复合构成了 $F$ 上的线性空间且$dim End V = (dim V)^2$。也构成了 $End V$ 是一个结合F-代数。而任何结合代数都可以诱导一个 Lie 代数。定义 $[x,y]=xy-yx$ 即可。为了跟原来的代数区别，我们用 $\mathbb{gl}(V)$ 代替 $End V$，称为 general linear algebra。它在 Lie 代数中充当的角色很类似于置换群在群中的角色。我们知道半单Lie代数同构于$\mathbb{gl}(V)$ 的一个子Lie代数。</p>
<h3 id="u5BFC_u5B50_u548C_u4F34_u968F_u8868_u793A"><a href="#u5BFC_u5B50_u548C_u4F34_u968F_u8868_u793A" class="headerlink" title="导子和伴随表示"></a>导子和伴随表示</h3><p>我们称一个 $F-$代数 $A$（可以非结合）也可以借助导子(derivation)诱导一个Lie代数，称一个导子是指一个线性映射 $\delta: A \to A$ 满足 $\delta(ab)=\delta(a)b+a\delta(b)$。易知导子 $Der A$ 全体构成了 $End A$ 的一个子空间，由于 $[\delta,\delta’] \in Der A$，因此 $Der A$ 构成了 $\mathbb{gl}(V)$的一个子Lie代数。<br>由于Lie代数 $L$ 也是 $F-$代数,因此我们也可以定义 $Der L$。这是的导子本质上就是Jacobi恒等式的变形。<br>定义 $ad_x: L \to L,y \mapsto [x,y]$，实际上 $ad_x \in Der L$。$L \to Der L,x \mapsto ad_x$ 称为 $L$ 的伴随表示(adiont representation)。</p>
<h3 id="u53EF_u89E3_u548C_u5E42_u96F6"><a href="#u53EF_u89E3_u548C_u5E42_u96F6" class="headerlink" title="可解和幂零"></a>可解和幂零</h3><p>对于给定Lie代数 $L$，我们有理想降链<br>$L^{(0)} = L,L^{(1)}=[L^{(0)},L^{(0)}],\cdots,L^{(i)}=[L^{(i-1)},L^{(i-1)}],\cdots$。若存在 $n$ 使得 $L^{(n)} = 0$ 则称 $L$ 可解(slovable)。</p>
<ol>
<li>若$L$ 可解，$L$ 的子代数和同态像可解</li>
<li>$I$ 是 $L$ 的可解理想，若 $L/I$ 可解，则 $L$ 可解。</li>
<li>$I,J$ 是 $J$ 的可解理想，则 $I+J$ 也是。</li>
</ol>
<p>由上述性质可知，$L$ 有唯一的极大可解理想。即为 $Rad L$,若 $Rad L =0$ 则称之为<strong>半单</strong>的，等价于 $L$ 无非零abelian理想(充分性显然，必要性是因为 $Rad L$ 可解，考虑最后一个非0项必然是abelian理想矛盾)。另外 我们称 $x \in End V$ 半单，若 $x$ 的极小多项式无重根。</p>
<p>对于给定Lie代数 $L$，我们有理想降链<br>$L^0 = L,L^1=[L^0,L^0],\cdots,L^i=[L^{i-1},L^{i-1}],\cdots $。若存在 $n$ 使得 $L^{n} = 0$ 则称 $L$ 幂零(nilpotent)。</p>
<ol>
<li>若$L$ 幂零，$L$ 的子代数和同态像幂零。</li>
<li>若 $L/Z(L)$ 幂零。则 $L$ 幂零。</li>
<li>若 $L$ 幂零且非0，则 $Z(L) \neq 0$。</li>
</ol>
<p>显然由于 $L^{(i)} \subset L^i$ 因此幂零一定可解，但是反之则不尽然，例如 $\mathbb{gl}(V)$ 中对应的上三角矩阵全体构成的Lie代数。由Lie定理的推论知：<br>$L$ 可解的充要条件是 $[L,L]$ 幂零。</p>
<h3 id="ad-nilpotent"><a href="#ad-nilpotent" class="headerlink" title="ad-nilpotent"></a>ad-nilpotent</h3><p>$L$ 是一个Lie代数，$x \in L$, 称 $x$ ad-nilpotent 是指 $ad_x$ 幂零。<br>易知若 $x$ 幂零，则 $ad_x$ 幂零，但是反之不尽然。然而我们有Engel 定理：<br>$L$幂零当且仅当$ad L$ 幂零。</p>
<h3 id="u4E00_u4E9B_u91CD_u8981_u7ED3_u679C"><a href="#u4E00_u4E9B_u91CD_u8981_u7ED3_u679C" class="headerlink" title="一些重要结果"></a>一些重要结果</h3><p>这里罗列一些定理实际上就是搞清楚 Lie 代数中的一些问题和一些好的性质。</p>
<p><strong>THM1</strong>. 设 $L$ 是 $\mathbb{gl}(V)$ 的子代数($L$ 中的元素可理解为矩阵)，$V$ 是有限维的，若 $L$ 中元素都幂零，则存在 $v \in V$ 使得 $L(v) = 0$.<br>上面结果是讲，$L$中元素都幂零，则 $L$ 有公共的$0$ 特征向量。证明是很有技巧性的。构造一个 codemension 为1的子代数，并证明它是 $L$ 不变子空间。然后数学归纳法完成证明。上面定理还说明我们可以取定一组基使 $L$ 同时严格上三角。</p>
<p><strong>THM2</strong>. 若 $L$ 幂零，$K$ 是 $L$ 的非零理想,则 $K \cap Z(L) \neq 0$</p>
<p><strong>THM3</strong>. 设 $L$ 是 $\mathbb{gl}(V)$ 可解子代数，$V$ 是有限维的，则存在 $L$ 存在公共特征向量。</p>
<p>上面定理还说明我们可以取定一组基使得 $L$ 同时上三角。</p>
<p><strong>THM4</strong>. 若 $x \in EndV$，则存在唯一的分解 $x = x_s+x_n$，其中 $x_s$ 是半单的， $x_n$ 是幂零的，且 $x_s,x_n$ 都能表示成 $x$ 的无常数项的多项式。将其称之为 Jordan-Chevally 分解。</p>
<p><strong>THM5</strong>. 若 $x$ 半单，则 $ad_x$ 半单。若 $x=x_s+x_n$是Jordan-Chevally 分解，则 $ad_x = ad_{x_s} + ad_ {x_n}$  也是。$Der A$ 包含其元素的 半单部分和幂零部分。</p>
<p><strong>THM6</strong>. $A \subset B \subset End V $，令 $M = \lbrace x \in \mathbb{gl}(V) \;|\; [x,B] \subset A\rbrace$。若 $x \in M$ 满足，$Tr(xy)=0$ 对任意 $y\in M$ 成立，则 $x$ 幂零。</p>
<p><strong>THM7</strong> $L \subset \mathbb{gl}(V)$，$V$ 是有限维的, 则 对任意 $x \in [L,L],\;y \in L$ 有 $Tr(xy)=0$ 当且仅当 $L$ 可解。</p>
<p><strong>THM8</strong> 设 $L$ 是Lie代数，对任意 $x \in [L,L],\;y \in L$ 有 $Tr(ad_x ad_y)=0$ 则 $L$ 可解。</p>
<p><strong>THM9</strong> 若 $L$ 是半单的，则 $L$ 可唯一写成单子理想的直和且$L=[L,L],Z(L)=0$ 且 $L$ 的理想和同态像都是半单的。</p>
<p><strong>THM10</strong> $ad L$ 是 $Der L$ 的理想，且若 $L$ 是半单的，则 $ad L = Der L$。</p>
<h3 id="To_be_continue"><a href="#To_be_continue" class="headerlink" title="To be continue"></a>To be continue</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>近期在整理 Lie Algebra 课的笔记，还是很喜欢这门课的，主要是本科时候矩阵玩的特别6，然后 Lie Algebra 可以认为是矩阵的推广版本。里面的证明技巧性相当强。我之所以喜欢数学很大程度与数学技巧有关。但是我的导师说，这些虽然很有技巧，但是你花时间都是可以处理的，会技巧没什么了不起，脑袋稍微好一点就能做这种事，长期技巧的训练其实意义并不大，应该更关注数学内部的东西，具体说就是一个代数对象的结构，分类，不变量，对象之间的同构。一个概念有哪些等价形式，与其它概念之间的关系，搞清楚这些更为重要，它们的证明只要大致知道怎么过来的就行。我们并不要把证明的细节放在心中，因为我们已经经过了多年的训练，相信我们通过大致步骤就能给出详细的证明，只是花的时间多少罢了。当然初学一个东西，去抠它的细节是无可厚非的。<br>以上纯属废话 0.0<br>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[矩阵的Jordan分解]]></title>
    <link href="http://dna049.com/2016/04/08/Jordan-Composition-of-Matrix/"/>
    <id>http://dna049.com/2016/04/08/Jordan-Composition-of-Matrix/</id>
    <published>2016-04-08T08:20:49.000Z</published>
    <updated>2016-04-08T14:35:10.000Z</updated>
    <content type="html"><![CDATA[<p>最近在整理 Lie Algebra 内容时，里面提到了Jordan分解，这里就详细介绍并证明几个相关结果。</p>
<ol>
<li>若矩阵 $A,B$ 可交换，则它们有公共特征向量。</li>
<li>若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换</li>
<li>每一个矩阵 $A$ 都可以唯一分解成 $A=B+C$, 其中 $B$ 可对角化，$C$ 幂零。且 $B,C$ 都可以写成 $A$ 的无常数项的多项式。</li>
</ol>
<a id="more"></a>
<p>下面证明这三个结果并给出说明其意义。</p>
<h3 id="u82E5_u77E9_u9635__24A_2CB_24__u53EF_u4EA4_u6362_uFF0C_u5219_u5B83_u4EEC_u6709_u516C_u5171_u7279_u5F81_u5411_u91CF_u3002"><a href="#u82E5_u77E9_u9635__24A_2CB_24__u53EF_u4EA4_u6362_uFF0C_u5219_u5B83_u4EEC_u6709_u516C_u5171_u7279_u5F81_u5411_u91CF_u3002" class="headerlink" title="若矩阵 $A,B$ 可交换，则它们有公共特征向量。"></a>若矩阵 $A,B$ 可交换，则它们有公共特征向量。</h3><p><strong>证明</strong>：我们设 $V$ 为 $n$ 阶列向量全体。设 $\lambda$ 为 $B$ 的一个特征值。设<br>$$W = \lbrace x \in V \;|\; Bx = \lambda x \rbrace $$<br>则对任意 $x \in W$,<br>$$B(Ax) = A(Bx)=A(\lambda x)=\lambda(Ax)$$<br>即 $Ax \in W$。即 $W$ 是 $A$ 的不变子空间，因此，$A$ 在 $W$ 中有特征值 $\mu$ 对应的特征向量 $v$ 即为所求。</p>
<h3 id="u82E5_u77E9_u9635__24A_2CB_24__u53EF_u4EE5_u5BF9_u89D2_u5316_uFF0C_u5219_u5B83_u4EEC_u53EF_u4EE5_u540C_u65F6_u5BF9_u89D2_u5316_uFF0C_u5F53_u4E14_u4EC5_u5F53__24A_2CB_24__u4EA4_u6362"><a href="#u82E5_u77E9_u9635__24A_2CB_24__u53EF_u4EE5_u5BF9_u89D2_u5316_uFF0C_u5219_u5B83_u4EEC_u53EF_u4EE5_u540C_u65F6_u5BF9_u89D2_u5316_uFF0C_u5F53_u4E14_u4EC5_u5F53__24A_2CB_24__u4EA4_u6362" class="headerlink" title="若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换."></a>若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换.</h3><p><strong>证明</strong>：$\rightarrow$ 是显然的。现证 $\leftarrow$ 若 $A,B$ 交换。<br>由条件知，存在可逆矩阵 $P$ 使得 $P^{-1}AP = diag(a_1 E_{n_1},\cdots,a_s E_{n_s})$。由 $A,B$ 交换知，$P^{-1}AP P^{-1}BP = P^{-1}BP P^{-1}AP$。因此<br><span>$$P^{-1}BP = \left(\begin{matrix} 
B_1 \\  &amp; B_2 \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; B_s 
\end{matrix}\right)$$</span><!-- Has MathJax --><br>因为 $B$ 可对角化，因此 $B$ 的最小多项式无重根。所以 $B_i$ 的最小多项式也无重根。因此 $B_i$ 可对角化，存在可逆矩阵 $Q_i$ 使得 $Q_i^{-1}B_iQ_i$ 为对角阵。令 $Q = diag(Q_1,\cdots,Q_s)$,$T=PQ$，则 $T^{-1}BT$ 为对角阵。$T^{-1}AT = diag(Q_1^{-1},\cdots,Q_s^{-1})diag(a_1 E_{n_1},\cdots,a_s E_{n_s}) diag(Q_1,\cdots,Q_s) = diag(a_1 E_{n_1},\cdots,a_s E_{n_s})$.<br>即 $T$ 即为所求。</p>
<h3 id="Jodan_u5206_u89E3"><a href="#Jodan_u5206_u89E3" class="headerlink" title="Jodan分解"></a>Jodan分解</h3><p>每一个矩阵 $A$ 都可以唯一分解成 $A=B+C$, 其中 $B$ 可对角化，$C$ 幂零。且 $B,C$ 都可以写成 $A$ 的无常数项的多项式。<br>证明：首先对任意矩阵，我们有Jordan标准型：对任意矩阵 $A$，存在可逆矩阵 $P$ 使得<br><span>$P^{-1} A P = \left(\begin{matrix} J_1(\lambda_1) \\  &amp; J_2(\lambda_2) \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; J_s(\lambda_s) \end{matrix}\right) = \left(\begin{matrix} \lambda_1 E_{n_1} \\  &amp; \lambda_2 E_{n_2} \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; \lambda_s E_{n_s} \end{matrix}\right) + \left(\begin{matrix} J_1(0) \\  &amp; J_2(0) \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; J_s(0) \end{matrix} \right)$</span><!-- Has MathJax --></p>
<p>由于 $ J_i(\lambda_i) $ 的化零多项式为 $f_i(\lambda) = |\lambda -  J_1(\lambda_1)|$。由中国剩余定理知。存在多项式 $f(\lambda)$ 满足 $f(\lambda) = \lambda_i (mod \; f_i),i=1,\cdots,s$ 且 $f(\lambda)= 0 (mod \lambda)$。此时<br><span>$$P^{-1} A P = \left(\begin{matrix} \lambda_1 E_{n_1} \\  &amp; \lambda_2 E_{n_2} \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; \lambda_s E_{n_s} \end{matrix}\right) $$
令 $$B = P \left(\begin{matrix} \lambda_1 E_{n_1} \\  &amp; \lambda_2 E_{n_2} \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; \lambda_s E_{n_s} \end{matrix}\right) P^{-1}$$</span><!-- Has MathJax --><br>则 $B=f(A)，C=A-B$ 即为所求。上面的$B,C$ 是唯一的，因为，若存在$B_1,C_1$ 也满足上述条件，则 $A,B,C,B_1,C_1$彼此交换，$B-B_1 = C_1 - C$ 是幂零的，因此 $B=B_1,C=C_1$。</p>
<p>Jordan 标准型将矩阵化成简单形式使得我们考虑很多问题都只需在标准型的情形分析。很多不明显的结论都能很清楚的给出答案。<br>对于Jordan分解，我们可以将一个矩阵分为所谓的半单部分和幂零部分，而由第二条结论知道，如果 $A_1,A_2$ 可交换，那么$A_1+A_2$ 的半单部分即为 $B_1+B_2$。这是很好的性质。或者说的更明了一点就是，如果 $A,B$ 可交换，且可以对角化，则$A+B$ 也可以对角化。</p>
<blockquote>
<p>想到写这些完全是因为 Lie Algebra 忘掉 Lie 括号本身就是一个线性空间。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在整理 Lie Algebra 内容时，里面提到了Jordan分解，这里就详细介绍并证明几个相关结果。</p>
<ol>
<li>若矩阵 $A,B$ 可交换，则它们有公共特征向量。</li>
<li>若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换</li>
<li>每一个矩阵 $A$ 都可以唯一分解成 $A=B+C$, 其中 $B$ 可对角化，$C$ 幂零。且 $B,C$ 都可以写成 $A$ 的无常数项的多项式。</li>
</ol>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
      <category term="矩阵" scheme="http://dna049.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[格点多边形面积公式 Pick's Theorem]]></title>
    <link href="http://dna049.com/2016/03/29/Pick's-Theorem/"/>
    <id>http://dna049.com/2016/03/29/Pick's-Theorem/</id>
    <published>2016-03-29T13:00:30.000Z</published>
    <updated>2016-03-29T13:52:02.000Z</updated>
    <content type="html"><![CDATA[<p>Pick 定理: 顶点在格点上的简单多边形面积公式为<br>$$ S=i+\frac{j}{2}-1 $$<br>其中 $i,j,S$ 分别表示多边形内部的点数、边界上的点数、面积。下面给出清晰明了的证明方法。<br><a id="more"></a></p>
<h3 id="u4E0E_u5750_u6807_u8F74_u5E73_u884C_u7684_u77E9_u5F62_uFF08_u957F_u65B9_u5F62_uFF09"><a href="#u4E0E_u5750_u6807_u8F74_u5E73_u884C_u7684_u77E9_u5F62_uFF08_u957F_u65B9_u5F62_uFF09" class="headerlink" title="与坐标轴平行的矩形（长方形）"></a>与坐标轴平行的矩形（长方形）</h3><p>不妨设矩形边长为 $a,b$。因此面积: $S = ab$<br>内部格点个数:<br>$$i=(a-1)(b-1)$$<br>边界格点个数为 $j=2(a+b)$, 结论成立。</p>
<h3 id="u76F4_u89D2_u8FB9_u4E0E_u5750_u6807_u8F74_u5E73_u884C_u7684_u76F4_u89D2_u4E09_u89D2_u5F62"><a href="#u76F4_u89D2_u8FB9_u4E0E_u5750_u6807_u8F74_u5E73_u884C_u7684_u76F4_u89D2_u4E09_u89D2_u5F62" class="headerlink" title="直角边与坐标轴平行的直角三角形"></a>直角边与坐标轴平行的直角三角形</h3><p>不妨设直角三角形的直角边分别为 $a,b$，面积 $S=\frac{ab}{2}$。将其补成一个矩形，则两个直角三角形全等，设公共边的格点个数为 $e$,内部格点数 $i=\frac{(a-1)(b-1)-(e-2)}{2}$, 边界总格点数为 $j=e+a-1+b-1$,因此<br>$$ i+ \frac{j}{2} - 1 = (a-1)(b-1)/2 - (e-2) + \frac{e+a-1+b-1}{2} -1 =  \frac{ab}{2}$$</p>
<h3 id="u4E00_u4E2A_u7B80_u5355_u591A_u8FB9_u5F62_u62C6_u9664_u4E24_u4E2A_u7B80_u5355_u591A_u8FB9_u5F62"><a href="#u4E00_u4E2A_u7B80_u5355_u591A_u8FB9_u5F62_u62C6_u9664_u4E24_u4E2A_u7B80_u5355_u591A_u8FB9_u5F62" class="headerlink" title="一个简单多边形拆除两个简单多边形"></a>一个简单多边形拆除两个简单多边形</h3><p>若这两个简单多边形公共边上有 $c$ 个顶点,分别满足 Pick 定理。<br>设 $P$ 的面积为 $P_i + \frac{P_j}{2} - 1$<br>设 $T$ 的面积为 $T_i + \frac{T_j}{2} - 1$<br>则 $PT$ 的面积为:<br>$$ (T_i+P_i+c-2) + \frac{P_j-c+T_j-c+2}{2} - 1$$<br>也满足 Pick 定理。<br>类似地，若 $P,PT$ 满足 Pick 定理，$T$ 也满足。</p>
<h3 id="u4E09_u89D2_u5F62"><a href="#u4E09_u89D2_u5F62" class="headerlink" title="三角形"></a>三角形</h3><p>对于一般三角形ABC，我们可以将其补在一个与坐标轴平行的矩阵(边长设为 $a,b$)中（如下图）<br><img src="pick.png" alt="pick&#39;s Theorem"><br>根据上面的结论，容易知道对于一般三角形，结论也成立。</p>
<h3 id="u7B80_u5355_u591A_u8FB9_u5F62"><a href="#u7B80_u5355_u591A_u8FB9_u5F62" class="headerlink" title="简单多边形"></a>简单多边形</h3><p>需要说明的简单多边形是指，平面上边不相交的多边形。<br>由于每个 $n$ 边形，都可以拆成一个 $n-1$ 边形和一个三角形，因此易用数学归纳法证明结论对简单多边形成立。</p>
<pre><code>传说中这个定理和有关Farey序列。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Pick 定理: 顶点在格点上的简单多边形面积公式为<br>$$ S=i+\frac{j}{2}-1 $$<br>其中 $i,j,S$ 分别表示多边形内部的点数、边界上的点数、面积。下面给出清晰明了的证明方法。<br>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有限整环是域]]></title>
    <link href="http://dna049.com/2016/03/27/Finite-domain-is-Field/"/>
    <id>http://dna049.com/2016/03/27/Finite-domain-is-Field/</id>
    <published>2016-03-27T14:45:40.000Z</published>
    <updated>2016-04-25T13:58:36.000Z</updated>
    <content type="html"><![CDATA[<p>有限整环是域，这是一个相当深刻的结论，该定理这叫 Wedderburn’s little theorem。介绍如下。<br><a id="more"></a></p>
<h3 id="u6709_u9650_u6574_u73AF_u662F_u4F53"><a href="#u6709_u9650_u6574_u73AF_u662F_u4F53" class="headerlink" title="有限整环是体"></a>有限整环是体</h3><p>设 $D$ 是有限整环（不要求交换），下证 $D$ 是体。<br>证明：对任意 $0 \neq a \in D$，考虑 $a,a^2,a^3,..,a^n,…$ 由于 $D$ 是有限环，因此存在 $n,r &gt; 0$ 使得 $a^{n+r} = a^n$ 即 $a^n(a^r-1)=0$ 由于 $D$ 是整环，$a \neq 0$，因此 $a^r =1$ ，所以 $a$ 可逆，证毕。</p>
<h3 id="u6709_u9650_u4F53_u662F_u57DF"><a href="#u6709_u9650_u4F53_u662F_u57DF" class="headerlink" title="有限体是域"></a>有限体是域</h3><p>设 $K$ 是有限体。$Z$ 是它的中心，即<br>$$ Z = \lbrace z \in K \;|\; \forall x \in K, xz = zx \rbrace $$<br>则，$Z$ 是域。令 $|Z|=q$，则 $K$ 是 $q$ 元域上的有限维向量空间，设维数为 $n$，则 $|K|=q^n$。我们需要证明 $K=Z$, 即证明 $n=1$。<br>对任意 $a \in K$，令 $N(a) = \lbrace x \in K \;|\; ax = xa \rbrace$ ，这显然是 $K$ 的一个子体。并且包含 $Z$。因此 $N(a)$ 也是 $Z$ 上的有限维向量空间。从而 $N(a)=q^{n(a)},n(a) \geq 1$。由于 $K^{*}$ 为 $q^n-1$ 阶乘法群，$N(a)^{*}$ 为 $K^{*}$ 的 $q^{n(a)}-1$ 阶子群，因此 $q^{n(a)}-1 \;|\; q^n-1$，因此 $n(a)|n$。<br>将乘法群 $K^{*}$ 中的元素分成共轭类，从群论的角度，与 $a \in K^{*}$ 共轭的元素有 $[K^{*} :N(a)^{*}] = \frac{q^n-1}{q^{n(a)}-1}$，从而每个共轭类取一次，我们有</p>
<p>$$ q^n - 1 = q-1 + \sum_{n(a)|n ,n(a)\neq n} \frac{q^n-1}{q^{n(a)}-1} $$</p>
<p>我们需要证明的是当 $n&gt;1$ 时上式不成立。为此我们先介绍分圆多项式的知识。<br>$$ P_n(x) = \prod_{1 \leq r \leq n,(r,n)=1} (x-e^{\frac{2 \pi i r}{n}}) $$<br>即 $P_n(x)$ 是以全部 $n$ 次本原单位复根（共 $\phi(n)$ 个）为根的首一多项式。易知<br>$$ x^n -1 = \prod_{d|n} P_d(n) $$<br>由数论函数的<a href="http://dna049.com/2016/01/20/Dirichlet-product-of-number-function/">Mobius 变换</a>，再取指数即可知<br>$$ P_n(x) = \prod_{d|n} (x^d-1)^{\mu(n/d)} $$ 于是 $P_n(x)=f(x)/g(x)$ 其中 $f(x),g(x)$ 都为 $\mathbb{Z}[x]$ 中的首一多项式。另一方面，按照定义，$P_n(x) \in \mathbb{C}[x]$ ，从而在 $\mathbb{C}[x]$ 中 $g(x) \;|\; f(x)$。比较系数易知，$P_n(x)$ 为 $\mathbb{Z}[x]$ 中首一多项式。</p>
<p>因为对任意 $d\;|\;n,0&lt;d&lt;n,P_n(x)$ 的每个根都是 $x^n-1$ 的根，但不是 $x^d-1$ 的根，从而 </p>
<p>$$ P_n(x)|\frac{x^n-1}{x^d-1} $$</p>
<p>因此 $P_n(q)\;|\;q-1$, 但当 $n&gt;1$ 时，<br>$$|P_n(q))| &gt; (q-1)^{\phi(n)} \geq q-1 $$<br>矛盾，证毕。</p>
<blockquote>
<p>上面定理是极其深刻的，这个定理也可以这么表达，一个有限环，如果它不是域，那么它必然存在零因子。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>有限整环是域，这是一个相当深刻的结论，该定理这叫 Wedderburn’s little theorem。介绍如下。<br>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[代数知识点]]></title>
    <link href="http://dna049.com/2016/03/26/Knowledge-of-Algebra/"/>
    <id>http://dna049.com/2016/03/26/Knowledge-of-Algebra/</id>
    <published>2016-03-26T12:48:00.000Z</published>
    <updated>2016-04-25T04:32:50.000Z</updated>
    <content type="html"><![CDATA[<p>最近在读 Nathan Jacobson《Basic Algebra I》，理一下知识点。长期更新<br><a id="more"></a></p>
<h3 id="u96C6_u5408_Set"><a href="#u96C6_u5408_Set" class="headerlink" title="集合 Set"></a>集合 Set</h3><ol>
<li>一个集合 $A$ 的幂集 $\mathbb{P}(A)$ 为所有 $A$ 的子集构成的集合，$A$ 有限时，元素个数为 $2^{|A|}$ 。</li>
<li>一个映射自然的诱导了一个等价关系（“根据值是否相同”）。并由此，可以将一个映射自然地写成一个满射和一个单射的复合。</li>
<li>自然数的 Peano 公理。</li>
</ol>
<h3 id="u7FA4_Group"><a href="#u7FA4_Group" class="headerlink" title="群 Group"></a>群 Group</h3><ol>
<li>Monoid 和 Group 的定义，以及对应地考虑 Monoid 和 Group 之间的同态，这是范畴（Category）的思想。另外一切数学中的子、商概念都是一致的，子概念一般是继承原运算，并保持封闭即可。商概念就是除掉子的并且能保证定义合理即可。由于在群和环中作商并不能对任意子群做，把那些可以做的叫做正规子群(normal group)</li>
<li>群有很多等价定义。</li>
<li>一个群不能写成两（有限）个真子群的并。</li>
<li>Cayley 定理：任意有限群，同构于一个对称群（ $S_n$ ）的子群。</li>
<li>任意置换可以写成不相交轮换的复合。</li>
<li>偶置换全体构成了交错群 $A_n$ 是 $S_n$ 的 normal subgroup。</li>
<li>陪集分解和 Lagrange 定理：子群的阶是原有限群的因子。自然推论，元素的阶是群的因子。</li>
<li>Monoid 和 Group 的同态及其同态基本定理，这是范畴的框架。</li>
<li>循环群，Abel 群，自由群，自由 Monoid。</li>
<li>群在集合上的作用，轨道公式和 Burnside 引理，特别的是作用在群的陪集上会产生丰富的结论，例如关于群的中心的一些结论，包含于一个子群的最大 normal subgroup 以及使得该子群称为 normal group 的最大的子群。</li>
<li>Sylow 定理考察的是 Lagrange 的反问题。是群在集合上的作用的完美应用。</li>
</ol>
<h3 id="u73AF_Ring"><a href="#u73AF_Ring" class="headerlink" title="环 Ring"></a>环 Ring</h3><ol>
<li>环的定义，其中加法群中要求的 Abel 群可以由其他公理推出。</li>
<li>环的分类，局部环，交换环，整环，UFP，PID，UD，除环，域等等。</li>
<li>矩阵环，其中矩阵中的元素属于同一环即可。基本运算都有意义。若要求定义行列式，则元素所在的环需要是交换环。在此情况下，矩阵可逆当且仅当其行列式可逆。</li>
<li>一个非交换环的例子就是四元数（Quaternion），很多时候一个环上可以定义范数，会让一些操作更加容易。</li>
<li>理想，商环，素理想，极大理想，生成理想，左理想，右理想，环的单位构成乘法群，素环。</li>
<li>环的同态及其同态基本定理。</li>
<li>反同构，一个重要的例子就是矩阵的转置。</li>
<li>交换整环的分式域，可以推广到交换环的局部化，也能推广到环的 Ore 局部化。</li>
<li>多项式环，代数数，超越数。多项式环的余数定理，域上多项式环是PID，多项式环根的个数，有限域的乘法群是循环群。域中所有非零元之积为－1。</li>
<li>Monoid 和 Ring 的分解，唯一分解中的因子链条件，不可约元是素元的条件，以及 gcd 存在条件。Field 是 ED 是 PID 是 UFD。$D$ 是UFD 则 $D[x]$ 也是。$F[x]$ 是 ED。若 $D[x]$ 是 PID,则 $D$ 是域。</li>
<li>有限整环是除环是域。</li>
<li>Rng 可以嵌入到 Ring 中。</li>
</ol>
<h3 id="u6A21_Module_over_PID"><a href="#u6A21_Module_over_PID" class="headerlink" title="模 Module over PID"></a>模 Module over PID</h3><ol>
<li>类似于对称群 $S_n$，一个 Abel 群 M 上的自同态全体构成了一个环 End M。任何环都同构于一个 End M 的子环。</li>
<li>一个环 $R$ 到 End M 上的环同态，定义了一个 $R$ 上的模。当然还有一种等价的模仿线性空间的定义方法。特别地，一个 Abel 群可以看做是一个 $\mathbb{Z}$模，一个环的理想可以看做该环上的模， $F$上的线性空间外加一个线性变换可以看做 $F[\lambda]$模。</li>
<li>子模，商模，模同态及其同态基本定理。</li>
<li>循环模，零化子，循环模的同构。 </li>
<li>自由模，$R$ 交换时的自由模同构定理。</li>
<li>模的直和，以及线性相关，线性无关。</li>
<li>若 $D$ 是 PID，$D^{(n)}$ 是 $D$ 上秩为 $n$ 的自由模，则 $D^{(n)}$ 的子模都是自由模，且秩不超过 $n$.并且这个子模可以用 $D$ 上矩阵来刻画。</li>
<li>PID 上的矩阵可以相抵等价于对角矩阵,且每一个元素都是后一项的因子。</li>
<li>PID 上有限生成模同构于某个自由模的商模，且可以写成循环模的直和。并且上述分解长度唯一，在同构的意义下唯一。</li>
<li>扭子模以及扭子模可以分解成一些初等循环模的直和。</li>
<li>将上述 PID 上模的结论应用于 Abel 群以及域 $F$ 上线性空间，可以得到一系列结论。</li>
<li>每一个有限生成 Abel 群都是一个有限群和自由群的直和。每个有限 Abel 群都是一些素数幂阶循环群的直和。</li>
<li>域上矩阵环都有有理标准型，并且在代数闭域中有 Jordan 标准型。 </li>
<li>对于 PID 上有限生成模 $M$ 的自同态全体 End $M$ 反同构于一个两个 PID 上矩阵子环的的商。</li>
<li>应用到域上的线性空间可以得到与一个矩阵交换的矩阵全体的维数定理，自然推论是如果一个线性变换是循环的，那么与之交换的变换是它的多项式。</li>
<li>对于 PID 上有限生成模 $M$ 的自同态全体 End $M$，它的中心是 scale transformation。</li>
<li>一个域上的向量空间加上一个线性变换可以看做是 $F[\lambda]$ 模。</li>
</ol>
<h3 id="To_be_Continue"><a href="#To_be_Continue" class="headerlink" title="To be Continue"></a>To be Continue</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>最近在读 Nathan Jacobson《Basic Algebra I》，理一下知识点。长期更新<br>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cartan-Brauer-Hua Theorem]]></title>
    <link href="http://dna049.com/2016/03/23/Cartan-Brauer-Hua-Theorem/"/>
    <id>http://dna049.com/2016/03/23/Cartan-Brauer-Hua-Theorem/</id>
    <published>2016-03-23T15:22:24.000Z</published>
    <updated>2016-03-23T15:32:09.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Cartan-Brauer-Hua</strong> For a proper subset divison ring K of division ring L, if the unit group of K is a normal subgroup of the unit group of L, K is central.<br><a id="more"></a></p>
<p>I will show two similar proof of the Cartan–Brauer–Hua theorem. </p>
<h3 id="First_Proof"><a href="#First_Proof" class="headerlink" title="First Proof"></a>First Proof</h3><p><strong>Definition</strong><br>$ L^*  \equiv L \setminus \lbrace 0 \rbrace $, $[x,y] \equiv xyx^{-1}y^{-1}$ and $c_x(y) \equiv xyx^{-1}$ </p>
<p>Given $g\in K^*$ and $a \in L \setminus K$<br>To prove: $[g,a]=1$</p>
<ol>
<li>It is trival that $[g,a] \;,\; [g,a+1]$ make sense and $$[g,a] = g (ag^{-1}a^{-1}) \in K$$ so is $[g,a+1]$.</li>
<li>we have $$ c_g(a+1) = g(a+1)g^{-1} = c_g(a)+1 $$ hence $$ [g,a+1](a+1) = [g,a]a+1$$ or equivalently $$ [g,a+1]-[g,a])a=(1-[g,a+1])$$</li>
<li>The assumption $[g,a+1] \neq [g,a]$ would lead to a contradiction that $a\in K$.hence<br>$$[g,a+1] \neq [g,a] \Leftrightarrow (a+1)g = aga^{-1}(a+1) \Leftrightarrow ga = ag $$<br>end of our proof of $[g,a]=1$.</li>
</ol>
<p>Let $g,h \in K^*$,take any $a in L \setminus K$.then $h+a \in L \setminus K $. We have $[g,a+h]=[g,a]=1$ hence $gh = hg$,thus every element of $K$ commutes with $L$.</p>
<h3 id="Second_Proof_by_Hua_Luogeng"><a href="#Second_Proof_by_Hua_Luogeng" class="headerlink" title="Second Proof by Hua Luogeng"></a>Second Proof by <a href="https://en.wiki2.org/wiki/Hua_Luogeng" target="_blank" rel="external">Hua Luogeng</a></h3><p><img src="hua.png" alt="Proof"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Cartan-Brauer-Hua</strong> For a proper subset divison ring K of division ring L, if the unit group of K is a normal subgroup of the unit group of L, K is central.<br>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华罗庚恒等式]]></title>
    <link href="http://dna049.com/2016/03/22/Hua's-Indentity/"/>
    <id>http://dna049.com/2016/03/22/Hua's-Indentity/</id>
    <published>2016-03-22T04:06:31.000Z</published>
    <updated>2016-03-23T15:35:12.000Z</updated>
    <content type="html"><![CDATA[<p>华罗庚恒等式有两个，都看似奇怪但都有其深刻的应用(数学内部的)</p>
<ol>
<li>若在一个环中 $a,b,1-ab$ 都可逆，则<br>$$<br>\left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a<br>$$</li>
<li>若在一个环中<br>$$<br>a = \left( b^{-1} - (a-1)^{-1}b^{-1}(a-1) \right) \left (a^{-1} b^{-1}a-(a-1)^{-1}b^{-1}(a-1) \right)^{-1}<br>$$<br>上面两个恒等式直接验算即知，可是 <a href="https://en.wiki2.org/wiki/Hua_Luogeng" target="_blank" rel="external">华老</a> 当初怎么想到这两个很奇怪的恒等式呢，怎么导入的，有什么应用呢？<a id="more"></a>
</li>
</ol>
<p>当然以下也只是我的个人猜测加上 <a href="https://en.wiki2.org/wiki/Hua%27s_identity" target="_blank" rel="external">Wikipedia</a> 的一些参考。</p>
<h3 id="u5728_u73AF_u4E2D_1-ba__u53EF_u9006_uFF0C_u5F53_u4E14_u4EC5_u5F53_1-ab__u53EF_u9006"><a href="#u5728_u73AF_u4E2D_1-ba__u53EF_u9006_uFF0C_u5F53_u4E14_u4EC5_u5F53_1-ab__u53EF_u9006" class="headerlink" title="在环中 1-ba 可逆，当且仅当 1-ab 可逆"></a>在环中 1-ba 可逆，当且仅当 1-ab 可逆</h3><p>$$ (1-ba)^{-1} = 1+ b(1-ab)^{-1}a \label{3}$$</p>
<p>上面恒等式直接证明是显然的，应用却666，6到要吐。<br>问题在于为什么想到这样奇怪的式子呢？思路怎么来的呢？<br>我们知道，当 $0&lt;x&lt;1$ 时，<br>$$ \frac{1}{1-x} = \sum_{n=0}^{\infty} {x^n} $$</p>
<p>因此，形式上我们有<br>$$ (1-ba)^{-1} = \sum_{n=0}^{\infty} {(ba)^n} = 1+ b \sum_{n=0}^{\infty}{(ab)^n} a = 1+ b(1-ab)^{-1}a $$<br>但是这只是给我们的理解提供了思路，证明还是需要按照定义来，即计算<br>$$ (1-ba)(1+ b(1-ab)^{-1}a) = 1 = (1+ b(1-ab)^{-1}a)(1-ba) $$</p>
<p>讲上述不等式应用到矩阵形式即可得到 <a href="https://en.m.wikipedia.org/wiki/Sherman–Morrison_formula" target="_blank" rel="external">Sherman–Morrison恒等式</a></p>
<h3 id="u5728_u73AF_u4E2D_uFF0C_u82E5__24a_2Cb_2Cab-1_24__u53EF_u9006_uFF0C_u5219"><a href="#u5728_u73AF_u4E2D_uFF0C_u82E5__24a_2Cb_2Cab-1_24__u53EF_u9006_uFF0C_u5219" class="headerlink" title="在环中，若 $a,b,ab-1$ 可逆，则"></a>在环中，若 $a,b,ab-1$ 可逆，则</h3><p>由上面恒等式我们知道<br>$$(ab-1)^{-1} = a(ba-1)^{-1}b - 1$$<br>因此<br>$$ \begin{aligned} (a-b^{-1})^{-1} &amp;=<br>\left((ab-1)b^{-1} \right)^{-1} \\<br>&amp;= b\left( a(ba-1)^{-1}b - 1 \right) \\<br>&amp;= ba(ba-1)^{-1}b - b  \\<br>&amp;= (ba-1)^{-1}b<br>\end{aligned}<br>$$<br>注意到<br>$$<br>\begin{align}  (ba-1)^{-1}b - a^{-1} &amp;= (ba-1)^{-1}baa^{-1} - a^{-1} \\<br>&amp;= (ba-1)^{-1}a^{-1} \\<br>&amp;= (aba-a)^{-1}<br>\end{align}<br>$$<br>因此 华罗庚等式 $ \left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a$ 得证。</p>
<h3 id="u4E00_u4E2A_u91CD_u8981_u6052_u7B49_u5F0F"><a href="#u4E00_u4E2A_u91CD_u8981_u6052_u7B49_u5F0F" class="headerlink" title="一个重要恒等式"></a>一个重要恒等式</h3><p>$$ b^{-1} - a^{-1} = ( b+b(a-b)^{-1}b )^{-1} $$</p>
<p>上面恒等式与逆算子连续性有关系。<br>证明：<br>$$<br>\begin{align}  (b^{-1} - a^{-1})^{-1} &amp;= (1-ba^{-1})^{-1}b \\<br>&amp;=(1+b(1-a^{-1}b)^{-1}a^{-1})b \\<br>&amp;= b+b(a-b)^{-1}b<br>\end{align}<br>$$</p>
<h3 id="u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u8BC1_u660E"><a href="#u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u8BC1_u660E" class="headerlink" title="华罗庚恒等式证明"></a>华罗庚恒等式证明</h3><p>$$<br>\begin{align}<br>a \left( a^{-1}b^{-1}a - (a-1)^{-1} b^{-1}(a-1) \right) &amp;=<br>(b^{-1}a- a(a-1)^{-1} b^{-1} (a-1) \\<br>&amp;= ( 1-a(a-1)^{-1} )b^{-1}a + (a-1+1) (a-1)b^{-1} )^{-1} \\<br>&amp;= -(a-1)^{-1}b^{-1}a + b^{-1} + (a-1)b^{-1} \\<br>&amp;= b^{-1} - (a-1)^{-1} b^{-1}(a-1)<br>\end{align}<br>$$</p>
<h3 id="u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u7684_u610F_u4E49"><a href="#u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u7684_u610F_u4E49" class="headerlink" title="华罗庚恒等式的意义"></a>华罗庚恒等式的意义</h3><ol>
<li>华罗庚第一个恒等式可以用来证明一个 Hua’s Theorem：除环间中保持加法和幺元以及逆元的映射必然是除环间的同态或者反同态。</li>
<li>华罗庚第一个恒等式可以证明 Cartan-Brauer-Hua Theorem 即一个除环的真子除环的单位群如果是原除环的单位群的正规子群，则该子除环一定包含于除环的中心。（会在<a href="http://dna049.com/2016/03/23/Cartan-Brauer-Hua-Theorem/">下一篇博文</a>中介绍）</li>
</ol>
<p>最后用一句广为流传的话结尾</p>
<blockquote>
<p>   龙生龙，凤生凤，华罗庚的学生会打洞（矩阵打洞）</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>华罗庚恒等式有两个，都看似奇怪但都有其深刻的应用(数学内部的)</p>
<ol>
<li>若在一个环中 $a,b,1-ab$ 都可逆，则<br>$$<br>\left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a<br>$$</li>
<li>若在一个环中<br>$$<br>a = \left( b^{-1} - (a-1)^{-1}b^{-1}(a-1) \right) \left (a^{-1} b^{-1}a-(a-1)^{-1}b^{-1}(a-1) \right)^{-1}<br>$$<br>上面两个恒等式直接验算即知，可是 <a href="https://en.wiki2.org/wiki/Hua_Luogeng">华老</a> 当初怎么想到这两个很奇怪的恒等式呢，怎么导入的，有什么应用呢？]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自然数的Peano公理]]></title>
    <link href="http://dna049.com/2016/03/19/Peano-axiom-of-natural-number/"/>
    <id>http://dna049.com/2016/03/19/Peano-axiom-of-natural-number/</id>
    <published>2016-03-19T10:58:25.000Z</published>
    <updated>2016-03-20T00:16:58.000Z</updated>
    <content type="html"><![CDATA[<p>虽然我们从小学就开始学习自然数，但是自然数的真正严格的定义归功于1889年<a href="https://en.wikipedia.org/wiki/Giuseppe_Peano" target="_blank" rel="external">Giuseppe Peano</a> 的工作。介绍如下:<br><a id="more"></a></p>
<h3 id="u81EA_u7136_u6570_u7684_u5B9A_u4E49"><a href="#u81EA_u7136_u6570_u7684_u5B9A_u4E49" class="headerlink" title="自然数的定义"></a>自然数的定义</h3><p>我们把满足如下公理的集合叫做自然数 $\mathbb{N}$。<br>$\mathbb{N}$ 中包含一个特殊元素记作 $0$, 以及一个 $\mathbb{N}$ 到自身的映射 $a \mapsto a^+$，称为后继映射。<br>满足如下 Peano 公理:</p>
<ol>
<li>$0 \notin a^+$ 对任意 $a \in \mathbb{N}$ ；</li>
<li>$a \mapsto a^+$ 是单射；</li>
<li>若 $\mathbb{N}$ 的一个子集 $A$ 包含 $0$ 以及它的任何后继元素，则 $A=\mathbb{N}$。</li>
</ol>
<p>上面的公理3是我们常用数学归纳法的依据。下面介绍一个特别重要的定理。</p>
<p><strong>归纳定理</strong>: 设 $S$ 是一个集合，$\phi$ 是 $S$ 到自身的映射， $a\in S$。则存在唯一的映射 $f \colon \mathbb{N} \to S$ 使得<br>$$ f(0) = a, \qquad f(n^+) = \phi(f(n)), n \in \mathbb{N} $$ </p>
<p><strong>证明</strong>: 设<br>$$ \Lambda ＝ \lbrace U \subset \mathbb{N} \times S \colon (0,a)\in U\; | \; \mbox{ if } (n,b) \in U, \mbox{ then } (n^+,\phi(b)) \in U \rbrace$$<br>显然 $\mathbb{N} \times S \in \Lambda$ ，因此 $\Lambda \neq 0$ ,设 $f ＝ \cap_{U \in T} U$ ，下面证明 $f$ 即为所求。<br>由归纳 $\forall a \in \mathbb{N}, \exists b \in S$ 使得 $(n,b) \in f$ ，因此我们只需证明，若$(n,b),(n,b’) \in f$ 则 $b = b’$。令 $T=\lbrace n \in \mathbb{N} \;|\; (n,b),(n,b’) \in f \Rightarrow b=b’ \rbrace$,我们只需证明 $T = \mathbb{N}$。<br>首先 $0 \in T$ ，否则 $\exists a \neq a’$ 使得 $(0,a), (0,a’) \in f$ 。设 $f’$ 为 $f \setminus \lbrace (0,b’) \rbrace$ 易知 $f’ \in \Lambda$ 矛盾于 $f$ 的定义。<br>类似的 若$r \in T$，可证 $r^+ \in T$ 否则 $\exists c \neq \phi(r) $ 使得 $(r^+,c) \in T$ 设 $f’ = f \setminus \lbrace (r^+,c) \rbrace$ 则 $f’ \in \Lambda$ 矛盾于 $f$ 的定义。<br>假设 $g$ 也满足上述条件，则 $g \in \Lambda$ 因此 $f \subset g$ 但是对于两个映射 $f \subset g$ 可知 $f = g$ 证毕。<br>注: 以上的函数用”图像“的方式给出。</p>
<p>有了上面的 <strong>归纳定理</strong> 我们就可以定义自然数的加法和乘法了，注意定义永远是数学最重要的东西。</p>
<h3 id="u52A0_u6CD5_u4E58_u6CD5_u7684_u5B9A_u4E49"><a href="#u52A0_u6CD5_u4E58_u6CD5_u7684_u5B9A_u4E49" class="headerlink" title="加法乘法的定义"></a>加法乘法的定义</h3><p>两个自然数 $m,n$ 的加法被定义为 令 $a=m$ 和 $\phi \colon n \mapsto n^+$ ,则存在唯一的 $f_m$ 使得<br>$$ 0 + m = m \qquad  n^+ + m = (n+m)^+  $$<br>对于乘法，令 $a=0$ 和 $\phi \colon n \mapsto n＋m$ ,则存在唯一的 $g_m$ 使得<br>$$ 0m = 0 \qquad  n^+ m = nm + m $$</p>
<p>可以证明(其实蛮繁琐的)这样定义的加法满足我们平常所使用的各种法则，例如结合律，交换律等等性质。</p>
<p>下面看一下加法结合率的证明（书上并没有，自己补的）</p>
<ol>
<li>由加法定义可知 $(0+y)+z = y+z = 0+(y+z)$</li>
<li>若问题对 $x$ 成立则，$(x^+ +y)+z = (x+y+z)^+ = x^+ +(y+z)$<br>因此由公理3知 上式对任意的$x \in \mathbb{N}$ 成立，证毕。</li>
</ol>
<h3 id="u81EA_u7136_u6570_u7684_u5E8F_u5173_u7CFB"><a href="#u81EA_u7136_u6570_u7684_u5E8F_u5173_u7CFB" class="headerlink" title="自然数的序关系"></a>自然数的序关系</h3><p>称 $a \geq b$ 若存在 $x \in \mathbb{N}$ 使得 $a = b+x$。<br>显然有以下简单性质</p>
<ol>
<li>$x \geq  y$ 且 $y \geq x$ 则 $x = y$</li>
<li>$x \geq  y$ 且 $y \geq z$ 则 $x \geq z$</li>
<li>$\forall (x,y) \in \mathbb{N} \times \mathbb{N}$ $x \geq y$ 和 $y \geq x$ 至少有一个成立。<br>因此上述定义，定义了一个自然数集上的良序关系。另外自然数关于这种序关系有一个广为人知的结论。</li>
</ol>
<h3 id="u6700_u5C0F_u5143_u6027_u8D28"><a href="#u6700_u5C0F_u5143_u6027_u8D28" class="headerlink" title="最小元性质"></a>最小元性质</h3><p>$\mathbb{N}$ 的任何非空子集 $S$ 存在最小值。即 $\exists l \in S$ 使得 $\forall s\in S, s \geq l$。<br><strong>证明</strong>：设 $M = \lbrace m in \mathbb{N} \;|\; \forall s \in S, s \geq m \rbrace$ 。则 $0 \in M$ 且若 $s_0 \in S$ 则 $s_0^+ \notin M$。因此 $M \neq \mathbb{N}$. 因此由归纳法，存在 $s \in M, s^+ \notin M$ 上述 $s$ 即为所求。</p>
<p>按照公理化定义的自然数的性质验算其实还是很有意思的，虽然验算了也并没有什么屌用。另外知道了自然数的公理化体系也并没有什么屌用0.0<br>另外也有人将自然数写成<br>$$ 0 \equiv \emptyset, 1 equiv \lbrace \lbrace \emptyset \rbrace \emptyset \rbrace,\cdots n^+ \equiv  \lbrace \lbrace \emptyset \rbrace \emptyset \rbrace $$</p>
<p>以上内容来自 Nathan Jacobson 《Basic Algebra》。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然我们从小学就开始学习自然数，但是自然数的真正严格的定义归功于1889年<a href="https://en.wikipedia.org/wiki/Giuseppe_Peano">Giuseppe Peano</a> 的工作。介绍如下:<br>]]>
    
    </summary>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[A note about equal-distance point set]]></title>
    <link href="http://dna049.com/2016/03/15/A-note-about-equal-distance-point-set/"/>
    <id>http://dna049.com/2016/03/15/A-note-about-equal-distance-point-set/</id>
    <published>2016-03-14T16:00:28.000Z</published>
    <updated>2016-04-26T09:05:43.000Z</updated>
    <content type="html"><![CDATA[<p>It is evident true that there are at most 4 points are equal-distance in three dimention Euclidean Space.<br>What about other metric space? This ideal was first generated by my student Yilin Liu, and some results were obtained by us together.</p>
<a id="more"></a>
<ol>
<li>In a discrete metric, $X$ is any non-empty set.<br> $$ \rho(x,y) = \left \lbrace \begin{array}{ll} 1 &amp; x \neq y \\ 0 &amp; x=y  \end{array} \right. $$<br>In this metric space,any subset of $X$ is equal-distance.</li>
<li>Suppose that $X$ if we define<br> $$ \rho(A,B) = |x_1 - x_2| + |y_1 - y_2| + |z_1 - z_2| $$,<br>where $A(x_1,y_1,z_1),B(x_2,y_2,z_2)$.<br>we can find six points satisfy every two of them have some distance,for instance,$(\pm 1,0,0)\;(0,\pm 1,0)\;(0,0,\pm 1)$.</li>
<li>Suppose that $X$ if we define<br> $$ \rho(A,B) = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2 }+ |z_1 - z_2| $$,<br>where $A(x_1,y_1,z_1),B(x_2,y_2,z_2)$.<br>It is hard to find more that 4 point which could feed our demand. Fortunately with a skill construction,we finally get five equal-distance point set as follow<br>$$ (1,0,1); \;(-1,0,-1); \;(-\sqrt{2},0,4-\sqrt{2}); \;(-\frac{3\sqrt{2}}{2},2,\frac{\sqrt{2}}{2}); \;(-\frac{3\sqrt{2}}{2},-2,\frac{\sqrt{2}}{2}) $$ </li>
</ol>
<blockquote>
<p>What more, it remains to be considered in n-dimention space,or any metric and topology space.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>It is evident true that there are at most 4 points are equal-distance in three dimention Euclidean Space.<br>What about other metric space? This ideal was first generated by my student Yilin Liu, and some results were obtained by us together.</p>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
