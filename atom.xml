<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[0.肆玖]]></title>
  <subtitle><![CDATA[原谅我一生放荡不羁是傻逼]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://dna049.com/"/>
  <updated>2016-04-08T09:56:07.000Z</updated>
  <id>http://dna049.com/</id>
  
  <author>
    <name><![CDATA[dna049]]></name>
    <email><![CDATA[dna049@foxmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[矩阵的Jordan分解]]></title>
    <link href="http://dna049.com/2016/04/08/%E7%9F%A9%E9%98%B5%E7%9A%84Jordan%E5%88%86%E8%A7%A3/"/>
    <id>http://dna049.com/2016/04/08/矩阵的Jordan分解/</id>
    <published>2016-04-08T08:20:49.000Z</published>
    <updated>2016-04-08T09:56:07.000Z</updated>
    <content type="html"><![CDATA[<p>最近在整理 Lie Algebra 内容时，里面提到了Jordan分解，这里就详细介绍并证明几个相关结果。</p>
<ol>
<li>若矩阵 $A,B$ 可交换，则它们有公共特征向量。</li>
<li>若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换</li>
<li>每一个矩阵 $A$ 都可以唯一分解成 $A=B+C$, 其中 $B$ 可对角化，$C$ 幂零。且 $B,C$ 都可以写成 $A$ 的无常数项的多项式。</li>
</ol>
<a id="more"></a>
<p>下面逐一证明这三个结果并给出说明其意义。</p>
<h3 id="u82E5_u77E9_u9635__24A_2CB_24__u53EF_u4EA4_u6362_uFF0C_u5219_u5B83_u4EEC_u6709_u516C_u5171_u7279_u5F81_u5411_u91CF_u3002"><a href="#u82E5_u77E9_u9635__24A_2CB_24__u53EF_u4EA4_u6362_uFF0C_u5219_u5B83_u4EEC_u6709_u516C_u5171_u7279_u5F81_u5411_u91CF_u3002" class="headerlink" title="若矩阵 $A,B$ 可交换，则它们有公共特征向量。"></a>若矩阵 $A,B$ 可交换，则它们有公共特征向量。</h3><p><strong>证明</strong>：我们设 $V$ 为 $n$ 阶列向量全体。设 $\lambda$ 为 $B$ 的一个特征值。设<br>$$W = \lbrace x \in V \;|\; Bx = \lambda x \rbrace $$<br>则对任意 $x \in W$,<br>$$B(Ax) = A(Bx)=A(\lambda x)=\lambda(Ax)$$<br>即 $Ax \in W$。即 $W$ 是 $A$ 的不变子空间，因此，$A$ 在 $W$ 中有特征值 $\mu$ 对应的特征向量 $v$ 即为所求。</p>
<h3 id="u82E5_u77E9_u9635__24A_2CB_24__u53EF_u4EE5_u5BF9_u89D2_u5316_uFF0C_u5219_u5B83_u4EEC_u53EF_u4EE5_u540C_u65F6_u5BF9_u89D2_u5316_uFF0C_u5F53_u4E14_u4EC5_u5F53__24A_2CB_24__u4EA4_u6362"><a href="#u82E5_u77E9_u9635__24A_2CB_24__u53EF_u4EE5_u5BF9_u89D2_u5316_uFF0C_u5219_u5B83_u4EEC_u53EF_u4EE5_u540C_u65F6_u5BF9_u89D2_u5316_uFF0C_u5F53_u4E14_u4EC5_u5F53__24A_2CB_24__u4EA4_u6362" class="headerlink" title="若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换."></a>若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换.</h3><p><strong>证明</strong>：$”\rightArrow”$ 是显然的。现证 $”\leftArrow”$ 若 $A,B$ 交换。<br>由条件知，存在可逆矩阵 $P$ 使得 $P^{-1}AP = diag(a_1 E_{n_1},\cdots,a_s E_{n_s})$。由 $A,B$ 交换知，$P^{-1}AP P^{-1}BP = P^{-1}BP P^{-1}AP$。因此<br>$$ P^{-1}BP = \left(\begin{matrix} B_1 \\  &amp; B_2 \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; B_s \end{matrix}\right) $$<br>因为 $B$ 可对角化，因此 $B$ 的最小多项式无重根。所以 $B_i$ 的最小多项式也无重根。因此 $B_i$ 可对角化，存在可逆矩阵 $Q_i$ 使得 $Q_i^{-1}B_iQ_i$ 为对角阵。令 $Q = diag(Q_1,\cdots,Q_s)$,$T=PQ$，则 $T^{-1}BT$ 为对角阵。$T^{-1}AT = diag(Q_1^{-1},\cdots,Q_s^{-1})diag(a_1 E_{n_1},\cdots,a_s E_{n_s}) diag(Q_1,\cdots,Q_s) = diag(a_1 E_{n_1},\cdots,a_s E_{n_s})$.<br>即 $T$ 即为所求。</p>
<h3 id="Jodan_u5206_u89E3"><a href="#Jodan_u5206_u89E3" class="headerlink" title="Jodan分解"></a>Jodan分解</h3><p>每一个矩阵 $A$ 都可以唯一分解成 $A=B+C$, 其中 $B$ 可对角化，$C$ 幂零。且 $B,C$ 都可以写成 $A$ 的无常数项的多项式。<br>证明：首先对任意矩阵，我们有Jordan标准型：对任意矩阵 $A$，存在可逆矩阵 $P$ 使得<br>$$ P^{-1} A P = \left(\begin{matrix} J_1(\lambda_1) \\  &amp; J_2(\lambda_2) \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; J_s(\lambda_s) \end{matrix}\right) = \left(\begin{matrix} \lambda<em>1 E\</em>{n_1} \\  &amp; \lambda<em>2 E\</em>{n_2} \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; \lambda_s E_{n_s} \end{matrix}\right) + \left(\begin{matrix} J_1(0) \\  &amp; J_2(0) \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; J_s(0) \end{matrix} \right) $$<br>由于 $ J_i(\lambda_i) $ 的化零多项式为 $f_i(\lambda) = |\lambda -  J_1(\lambda_1)|$。由中国剩余定理知。存在多项式 $f(\lambda)$ 满足 $f = \lambda_i (mod \; f_i),i=1,\cots,s$ 且 $f= 0 (mod \lambda)$。此时<br>$$ P^{-1} A P = \left(\begin{matrix} \lambda<em>1 E\</em>{n_1} \\  &amp; \lambda<em>2 E\</em>{n_2} \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; \lambda<em>s E\</em>{n_s} \end{matrix}\right) $$<br>令 $$B = P \left(\begin{matrix} \lambda<em>1 E\</em>{n_1} \\  &amp; \lambda<em>2 E\</em>{n_2} \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; \lambda<em>s E\</em>{n_s} \end{matrix}\right) P^{-1}$$, 则 $B=f(A)，C=A-B$ 即为所求。上面的$B,C$ 是唯一的，因为，若存在$B_1,C_1$ 也满足上述条件，则 $A,B,C,B_1,C_1$彼此交换，$B-B_1 = C_1 - C$ 是幂零的，因此 $B=B_1,C=C_1$。</p>
<p>Jordan 标准型将矩阵化成简单形式使得我们考虑很多问题都只需在标准型的情形分析。很多不明显的结论都能很清楚的给出答案。<br>对于Jordan分解，我们可以将一个矩阵分为所谓的半单部分和幂零部分，而由第二条结论知道，如果 $A_1,A_2$ 可交换，那么$A_1+A_2$ 的半单部分即为 $B_1+B_2$。这是很好的性质。或者说的更明了一点就是，如果 $A,B$ 可交换，且可以对角化，则$A+B$ 也可以对角化。</p>
<blockquote>
<p>想到写这些完全是因为 Lie Algebra 忘掉李括号本身就是一个线性空间。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在整理 Lie Algebra 内容时，里面提到了Jordan分解，这里就详细介绍并证明几个相关结果。</p>
<ol>
<li>若矩阵 $A,B$ 可交换，则它们有公共特征向量。</li>
<li>若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换</li>
<li>每一个矩阵 $A$ 都可以唯一分解成 $A=B+C$, 其中 $B$ 可对角化，$C$ 幂零。且 $B,C$ 都可以写成 $A$ 的无常数项的多项式。</li>
</ol>]]>
    
    </summary>
    
      <category term="矩阵" scheme="http://dna049.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[格点多边形面积公式 Pick's Theorem]]></title>
    <link href="http://dna049.com/2016/03/29/%E6%A0%BC%E7%82%B9%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F-Pick-s-Theorem/"/>
    <id>http://dna049.com/2016/03/29/格点多边形面积公式-Pick-s-Theorem/</id>
    <published>2016-03-29T13:00:30.000Z</published>
    <updated>2016-03-29T13:52:02.000Z</updated>
    <content type="html"><![CDATA[<p>Pick 定理: 顶点在格点上的简单多边形面积公式为<br>$$ S=i+\frac{j}{2}-1 $$<br>其中 $i,j,S$ 分别表示多边形内部的点数、边界上的点数、面积。下面给出清晰明了的证明方法。<br><a id="more"></a></p>
<h3 id="u4E0E_u5750_u6807_u8F74_u5E73_u884C_u7684_u77E9_u5F62_uFF08_u957F_u65B9_u5F62_uFF09"><a href="#u4E0E_u5750_u6807_u8F74_u5E73_u884C_u7684_u77E9_u5F62_uFF08_u957F_u65B9_u5F62_uFF09" class="headerlink" title="与坐标轴平行的矩形（长方形）"></a>与坐标轴平行的矩形（长方形）</h3><p>不妨设矩形边长为 $a,b$。因此面积: $S = ab$<br>内部格点个数:<br>$$i=(a-1)(b-1)$$<br>边界格点个数为 $j=2(a+b)$, 结论成立。</p>
<h3 id="u76F4_u89D2_u8FB9_u4E0E_u5750_u6807_u8F74_u5E73_u884C_u7684_u76F4_u89D2_u4E09_u89D2_u5F62"><a href="#u76F4_u89D2_u8FB9_u4E0E_u5750_u6807_u8F74_u5E73_u884C_u7684_u76F4_u89D2_u4E09_u89D2_u5F62" class="headerlink" title="直角边与坐标轴平行的直角三角形"></a>直角边与坐标轴平行的直角三角形</h3><p>不妨设直角三角形的直角边分别为 $a,b$，面积 $S=\frac{ab}{2}$。将其补成一个矩形，则两个直角三角形全等，设公共边的格点个数为 $e$,内部格点数 $i=\frac{(a-1)(b-1)-(e-2)}{2}$, 边界总格点数为 $j=e+a-1+b-1$,因此<br>$$ i+ \frac{j}{2} - 1 = (a-1)(b-1)/2 - (e-2) + \frac{e+a-1+b-1}{2} -1 =  \frac{ab}{2}$$</p>
<h3 id="u4E00_u4E2A_u7B80_u5355_u591A_u8FB9_u5F62_u62C6_u9664_u4E24_u4E2A_u7B80_u5355_u591A_u8FB9_u5F62"><a href="#u4E00_u4E2A_u7B80_u5355_u591A_u8FB9_u5F62_u62C6_u9664_u4E24_u4E2A_u7B80_u5355_u591A_u8FB9_u5F62" class="headerlink" title="一个简单多边形拆除两个简单多边形"></a>一个简单多边形拆除两个简单多边形</h3><p>若这两个简单多边形公共边上有 $c$ 个顶点,分别满足 Pick 定理。<br>设 $P$ 的面积为 $P_i + \frac{P_j}{2} - 1$<br>设 $T$ 的面积为 $T_i + \frac{T_j}{2} - 1$<br>则 $PT$ 的面积为:<br>$$ (T_i+P_i+c-2) + \frac{P_j-c+T_j-c+2}{2} - 1$$<br>也满足 Pick 定理。<br>类似地，若 $P,PT$ 满足 Pick 定理，$T$ 也满足。</p>
<h3 id="u4E09_u89D2_u5F62"><a href="#u4E09_u89D2_u5F62" class="headerlink" title="三角形"></a>三角形</h3><p>对于一般三角形ABC，我们可以将其补在一个与坐标轴平行的矩阵(边长设为 $a,b$)中（如下图）<br><img src="pick.png" alt="pick&#39;s Theorem"><br>根据上面的结论，容易知道对于一般三角形，结论也成立。</p>
<h3 id="u7B80_u5355_u591A_u8FB9_u5F62"><a href="#u7B80_u5355_u591A_u8FB9_u5F62" class="headerlink" title="简单多边形"></a>简单多边形</h3><p>需要说明的简单多边形是指，平面上边不相交的多边形。<br>由于每个 $n$ 边形，都可以拆成一个 $n-1$ 边形和一个三角形，因此易用数学归纳法证明结论对简单多边形成立。</p>
<pre><code>传说中这个定理和有关Farey序列。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Pick 定理: 顶点在格点上的简单多边形面积公式为<br>$$ S=i+\frac{j}{2}-1 $$<br>其中 $i,j,S$ 分别表示多边形内部的点数、边界上的点数、面积。下面给出清晰明了的证明方法。<br>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[代数知识点]]></title>
    <link href="http://dna049.com/2016/03/29/%E4%BB%A3%E6%95%B0%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://dna049.com/2016/03/29/代数知识点/</id>
    <published>2016-03-29T10:34:43.000Z</published>
    <updated>2016-03-29T10:34:43.000Z</updated>
    <content type="html"><![CDATA[<p>最近在读 Nathan Jacobson《Basic Algebra I》，理一下知识点。长期更新<br><a id="more"></a></p>
<h3 id="u96C6_u5408_Set"><a href="#u96C6_u5408_Set" class="headerlink" title="集合 Set"></a>集合 Set</h3><ol>
<li>一个集合 $A$ 的幂集 $\mathbb{P}(A)$ 为所有 $A$ 的子集构成的集合，$A$ 有限时，元素个数为 $2^{|A|}$ 。</li>
<li>一个映射自然的诱导了一个等价关系（“根据值是否相同”）。并由此，可以将一个映射自然地写成一个满射和一个单射的复合。</li>
<li>自然数的 Peano 公理。</li>
</ol>
<h3 id="u7FA4_Group"><a href="#u7FA4_Group" class="headerlink" title="群 Group"></a>群 Group</h3><ol>
<li>Monoid 和 Group 的定义，以及对应地考虑 Monoid 和 Group 之间的同态，这是范畴（Category）的思想。另外一切数学中的子、商概念都是一致的，子概念一般是继承原运算，并保持封闭即可。商概念就是除掉子的并且能保证定义合理即可。由于在群和环中作商并不能对任意子群做，把那些可以做的叫做正规子群(normal group)</li>
<li>群有很多等价定义。</li>
<li>一个群不能写成两（有限）个真子群的并。</li>
<li>Cayley 定理：任意有限群，同构于一个对称群（ $S_n$ ）的子群。</li>
<li>任意置换可以写成不相交轮换的复合。</li>
<li>偶置换全体构成了交错群 $A_n$ 是 $S_n$ 的 normal subgroup。</li>
<li>陪集分解和 Lagrange 定理：子群的阶是原有限群的因子。自然推论，元素的阶是群的因子。</li>
<li>Monoid 和 Group 的同态及其同态基本定理，这是范畴的框架。</li>
<li>循环群，Abel 群，自由群，自由 Monoid。</li>
<li>群在集合上的作用，轨道公式和 Burnside 引理，特别的是作用在群的陪集上会产生丰富的结论，例如关于群的中心的一些结论，包含于一个子群的最大 normal subgroup 以及使得该子群称为 normal group 的最大的子群。</li>
<li>Sylow 定理考察的是 Lagrange 的反问题。是群在集合上的作用的完美应用。</li>
</ol>
<h3 id="u73AF_Ring"><a href="#u73AF_Ring" class="headerlink" title="环 Ring"></a>环 Ring</h3><ol>
<li>环的定义，其中加法群中要求的 Abel 群可以由其他公理推出。</li>
<li>环的分类，局部环，交换环，整环，UFP，PID，UD，除环，域等等。</li>
<li>矩阵环，其中矩阵中的元素属于同一环即可。基本运算都有意义。若要求定义行列式，则元素所在的环需要是交换环。在此情况下，矩阵可逆当且仅当其行列式可逆。</li>
<li>一个非交换环的例子就是四元数（Quaternion），很多时候一个环上可以定义范数，会让一些操作更加容易。</li>
<li>理想，商环，素理想，极大理想，生成理想，左理想，右理想，环的单位构成乘法群，素环。</li>
<li>环的同态及其同态基本定理。</li>
<li>反同构，一个重要的例子就是矩阵的转置。</li>
<li>交换整环的分式域，可以推广到交换环的局部化，也能推广到环的 Ore 局部化。</li>
<li>多项式环，代数数，超越数。多项式环的余数定理，域上多项式环是PID，多项式环根的个数，有限域的乘法群是循环群。域中所有非零元之积为－1。</li>
<li>Monoid 和 Ring 的分解，唯一分解中的因子链条件，不可约元是素元的条件，以及 gcd 存在条件。Field 是 ED 是 PID 是 UFD。$D$ 是UFD 则 $D[x]$ 也是。$F[x]$ 是 ED。若 $D[x]$ 是 PID,则 $D$ 是域。</li>
<li>有限整环是除环是域。</li>
<li>Rng 可以嵌入到 Ring 中。</li>
</ol>
<h3 id="u6A21_Module_over_PID"><a href="#u6A21_Module_over_PID" class="headerlink" title="模 Module over PID"></a>模 Module over PID</h3><ol>
<li>类似于对称群 $S_n$，一个 Abel 群 M 上的自同态全体构成了一个环 End M。任何环都同构于一个 End M 的子环。</li>
<li>一个环 $R$ 到 End M 上的环同态，定义了一个 $R$ 上的模。当然还有一种等价的模仿线性空间的定义方法。特别地，一个 Abel 群可以看做是一个 $\mathbb{Z}$模，一个环的理想可以看做该环上的模， $F$上的线性空间外加一个线性变换可以看做 $F[\lambda]$模。</li>
<li>子模，商模，模同态及其同态基本定理。</li>
<li>循环模，零化子，循环模的同构。 </li>
<li>自由模，$R$ 交换时的自由模同构定理。</li>
<li>模的直和，以及线性相关，线性无关。</li>
<li>若 $D$ 是 PID，$D^{(n)}$ 是 $D$ 上秩为 $n$ 的自由模，则 $D^{(n)}$ 的子模都是自由模，且秩不超过 $n$.并且这个子模可以用 $D$ 上矩阵来刻画。</li>
<li>PID 上的矩阵可以相抵等价于对角矩阵,且每一个元素都是后一项的因子。</li>
<li>PID 上有限生成模同构于某个自由模的商模，且可以写成循环模的直和。并且上述分解长度唯一，在同构的意义下唯一。</li>
<li>扭子模以及扭子模可以分解成一些初等循环模的直和。</li>
<li>将上述 PID 上模的结论应用于 Abel 群以及域 $F$ 上线性空间，可以得到一系列结论。</li>
<li>每一个有限生成 Abel 群都是一个有限群和自由群的直和。每个有限 Abel 群都是一些素数幂阶循环群的直和。</li>
<li>域上矩阵环都有有理标准型，并且在代数闭域中有 Jordan 标准型。 </li>
<li>对于 PID 上有限生成模 $M$ 的自同态全体 End $M$ 反同构于一个两个 PID 上矩阵子环的的商。</li>
<li>应用到域上的线性空间可以得到与一个矩阵交换的矩阵全体的维数定理，自然推论是如果一个线性变换是循环的，那么与之交换的变换是它的多项式。</li>
<li>对于 PID 上有限生成模 $M$ 的自同态全体 End $M$，它的中心是 scale transformation。</li>
<li>一个域上的向量空间加上一个线性变换可以看做是 $F[\lambda]$ 模。</li>
</ol>
<h3 id="To_be_Continue"><a href="#To_be_Continue" class="headerlink" title="To be Continue"></a>To be Continue</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>最近在读 Nathan Jacobson《Basic Algebra I》，理一下知识点。长期更新<br>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有限整环是域]]></title>
    <link href="http://dna049.com/2016/03/27/%E6%9C%89%E9%99%90%E6%95%B4%E7%8E%AF%E6%98%AF%E5%9F%9F/"/>
    <id>http://dna049.com/2016/03/27/有限整环是域/</id>
    <published>2016-03-27T14:45:40.000Z</published>
    <updated>2016-03-28T09:55:05.000Z</updated>
    <content type="html"><![CDATA[<p>有限整环是域，这是一个相当深刻的结论，该定理这叫 Wedderburn’s little theorem。介绍如下。<br><a id="more"></a></p>
<h3 id="u6709_u9650_u6574_u73AF_u662F_u4F53"><a href="#u6709_u9650_u6574_u73AF_u662F_u4F53" class="headerlink" title="有限整环是体"></a>有限整环是体</h3><p>设 $D$ 是有限整环（不要求交换），下证 $D$ 是体。<br>证明：对任意 $0 \neq a \in D$，考虑 $a,a^2,a^3,..,a^n,…$ 由于 $D$ 是有限环，因此存在 $n,r &gt; 0$ 使得 $a^{n+r} = a^n$ 即 $a^n(a^r-1)=0$ 由于 $D$ 是整环，$a \neq 0$，因此 $a^r =1$ ，所以 $a$ 可逆，证毕。</p>
<h3 id="u6709_u9650_u4F53_u662F_u57DF"><a href="#u6709_u9650_u4F53_u662F_u57DF" class="headerlink" title="有限体是域"></a>有限体是域</h3><p>设 $K$ 是有限体。$Z$ 是它的中心，即<br>$$ Z = \lbrace z \in K \;|\; \forall x \in K, xz = zx \rbrace $$<br>则，$Z$ 是域。令 $|Z|=q$，则 $K$ 是 $q$ 元域上的有限维向量空间，设维数为 $n$，则 $|K|=q^n$。我们需要证明 $K=Z$, 即证明 $n=1$。<br>对任意 $a \in K$，令 $N(a) = \lbrace x \in K \;|\; ax = xa \rbrace$ ，这显然是 $K$ 的一个子体。并且包含 $Z$。因此 $N(a)$ 也是 $Z$ 上的有限维向量空间。从而 $N(a)=q^{n(a)},n(a) \geq 1$。由于 $K^{*}$ 为 $q^n-1$ 阶乘法群，$N(a)^{*}$ 为 $K^{*}$ 的 $q^{n(a)}-1$ 阶子群，因此 $q^{n(a)}-1 \;|\; q^n-1$，因此 $n(a)|n$。<br>将乘法群 $K^{*}$ 中的元素分成共轭类，从群论的角度，与 $a \in K^{*}$ 共轭的元素有 $[K^{*} :N(a)^{*}] = \frac{q^n-1}{q^{n(a)}-1}$，从而每个共轭类取一次，我们有</p>
<p>$$ q^n - 1 = q-1 + \sum_{n(a)|n ,n(a)\neq n} \frac{q^n-1}{q^{n(a)}-1} $$</p>
<p>我们需要证明的是当 $n&gt;1$ 时上式不成立。为此我们先介绍分圆多项式的知识。<br>$$ P_n(x) = \prod_{1 \leq r \leq n,(r,n)=1} (x-e^{\frac{2 \pi i r}{n}}) $$<br>即 $P_n(x)$ 是以全部 $n$ 次本原单位复根（共 $\phi(n)$ 个）为根的首一多项式。易知<br>$$ x^n -1 = \prod_{d|n} P_d(n) $$<br>由数论函数的<a href="http://dna049.com/2016/01/20/数论函数的Dirichlet积/">Mobius 变换</a>，再取指数即可知<br>$$ P_n(x) = \prod_{d|n} (x^d-1)^{\mu(n/d)} $$ 于是 $P_n(x)=f(x)/g(x)$ 其中 $f(x),g(x)$ 都为 $\mathbb{Z}[x]$ 中的首一多项式。另一方面，按照定义，$P_n(x) \in \mathbb{C}[x]$ ，从而在 $\mathbb{C}[x]$ 中 $g(x) \;|\; f(x)$。比较系数易知，$P_n(x)$ 为 $\mathbb{Z}[x]$ 中首一多项式。</p>
<p>因为对任意 $d\;|\;n,0&lt;d&lt;n,P_n(x)$ 的每个根都是 $x^n-1$ 的根，但不是 $x^d-1$ 的根，从而 </p>
<p>$$ P_n(x)|\frac{x^n-1}{x^d-1} $$</p>
<p>因此 $P_n(q)\;|\;q-1$, 但当 $n&gt;1$ 时，<br>$$|P_n(q))| &gt; (q-1)^{\phi(n)} \geq q-1 $$<br>矛盾，证毕。</p>
<blockquote>
<p>上面定理是极其深刻的，这个定理也可以这么表达，一个有限环，如果它不是域，那么它必然存在零因子。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>有限整环是域，这是一个相当深刻的结论，该定理这叫 Wedderburn’s little theorem。介绍如下。<br>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cartan-Brauer-Hua Theorem]]></title>
    <link href="http://dna049.com/2016/03/23/Cartan-Brauer-Hua-Theorem/"/>
    <id>http://dna049.com/2016/03/23/Cartan-Brauer-Hua-Theorem/</id>
    <published>2016-03-23T15:22:24.000Z</published>
    <updated>2016-03-23T15:32:09.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Cartan-Brauer-Hua</strong> For a proper subset divison ring K of division ring L, if the unit group of K is a normal subgroup of the unit group of L, K is central.<br><a id="more"></a></p>
<p>I will show two similar proof of the Cartan–Brauer–Hua theorem. </p>
<h3 id="First_Proof"><a href="#First_Proof" class="headerlink" title="First Proof"></a>First Proof</h3><p><strong>Definition</strong><br>$ L^*  \equiv L \setminus \lbrace 0 \rbrace $, $[x,y] \equiv xyx^{-1}y^{-1}$ and $c_x(y) \equiv xyx^{-1}$ </p>
<p>Given $g\in K^*$ and $a \in L \setminus K$<br>To prove: $[g,a]=1$</p>
<ol>
<li>It is trival that $[g,a] \;,\; [g,a+1]$ make sense and $$[g,a] = g (ag^{-1}a^{-1}) \in K$$ so is $[g,a+1]$.</li>
<li>we have $$ c_g(a+1) = g(a+1)g^{-1} = c_g(a)+1 $$ hence $$ [g,a+1](a+1) = [g,a]a+1$$ or equivalently $$ [g,a+1]-[g,a])a=(1-[g,a+1])$$</li>
<li>The assumption $[g,a+1] \neq [g,a]$ would lead to a contradiction that $a\in K$.hence<br>$$[g,a+1] \neq [g,a] \Leftrightarrow (a+1)g = aga^{-1}(a+1) \Leftrightarrow ga = ag $$<br>end of our proof of $[g,a]=1$.</li>
</ol>
<p>Let $g,h \in K^*$,take any $a in L \setminus K$.then $h+a \in L \setminus K $. We have $[g,a+h]=[g,a]=1$ hence $gh = hg$,thus every element of $K$ commutes with $L$.</p>
<h3 id="Second_Proof_by_Hua_Luogeng"><a href="#Second_Proof_by_Hua_Luogeng" class="headerlink" title="Second Proof by Hua Luogeng"></a>Second Proof by <a href="https://en.wiki2.org/wiki/Hua_Luogeng" target="_blank" rel="external">Hua Luogeng</a></h3><p><img src="hua.png" alt="Proof"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Cartan-Brauer-Hua</strong> For a proper subset divison ring K of division ring L, if the unit group of K is a normal subgroup of the unit group of L, K is central.<br>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华罗庚恒等式]]></title>
    <link href="http://dna049.com/2016/03/22/%E5%8D%8E%E7%BD%97%E5%BA%9A%E6%81%92%E7%AD%89%E5%BC%8F/"/>
    <id>http://dna049.com/2016/03/22/华罗庚恒等式/</id>
    <published>2016-03-22T04:06:31.000Z</published>
    <updated>2016-03-23T15:35:12.000Z</updated>
    <content type="html"><![CDATA[<p>华罗庚恒等式有两个，都看似奇怪但都有其深刻的应用(数学内部的)</p>
<ol>
<li>若在一个环中 $a,b,1-ab$ 都可逆，则<br>$$<br>\left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a<br>$$</li>
<li>若在一个环中<br>$$<br>a = \left( b^{-1} - (a-1)^{-1}b^{-1}(a-1) \right) \left (a^{-1} b^{-1}a-(a-1)^{-1}b^{-1}(a-1) \right)^{-1}<br>$$<br>上面两个恒等式直接验算即知，可是 <a href="https://en.wiki2.org/wiki/Hua_Luogeng" target="_blank" rel="external">华老</a> 当初怎么想到这两个很奇怪的恒等式呢，怎么导入的，有什么应用呢？<a id="more"></a>
</li>
</ol>
<p>当然以下也只是我的个人猜测加上 <a href="https://en.wiki2.org/wiki/Hua%27s_identity" target="_blank" rel="external">Wikipedia</a> 的一些参考。</p>
<h3 id="u5728_u73AF_u4E2D_1-ba__u53EF_u9006_uFF0C_u5F53_u4E14_u4EC5_u5F53_1-ab__u53EF_u9006"><a href="#u5728_u73AF_u4E2D_1-ba__u53EF_u9006_uFF0C_u5F53_u4E14_u4EC5_u5F53_1-ab__u53EF_u9006" class="headerlink" title="在环中 1-ba 可逆，当且仅当 1-ab 可逆"></a>在环中 1-ba 可逆，当且仅当 1-ab 可逆</h3><p>$$ (1-ba)^{-1} = 1+ b(1-ab)^{-1}a \label{3}$$</p>
<p>上面恒等式直接证明是显然的，应用却666，6到要吐。<br>问题在于为什么想到这样奇怪的式子呢？思路怎么来的呢？<br>我们知道，当 $0&lt;x&lt;1$ 时，<br>$$ \frac{1}{1-x} = \sum_{n=0}^{\infty} {x^n} $$</p>
<p>因此，形式上我们有<br>$$ (1-ba)^{-1} = \sum_{n=0}^{\infty} {(ba)^n} = 1+ b \sum_{n=0}^{\infty}{(ab)^n} a = 1+ b(1-ab)^{-1}a $$<br>但是这只是给我们的理解提供了思路，证明还是需要按照定义来，即计算<br>$$ (1-ba)(1+ b(1-ab)^{-1}a) = 1 = (1+ b(1-ab)^{-1}a)(1-ba) $$</p>
<p>讲上述不等式应用到矩阵形式即可得到 <a href="https://en.m.wikipedia.org/wiki/Sherman–Morrison_formula" target="_blank" rel="external">Sherman–Morrison恒等式</a></p>
<h3 id="u5728_u73AF_u4E2D_uFF0C_u82E5__24a_2Cb_2Cab-1_24__u53EF_u9006_uFF0C_u5219"><a href="#u5728_u73AF_u4E2D_uFF0C_u82E5__24a_2Cb_2Cab-1_24__u53EF_u9006_uFF0C_u5219" class="headerlink" title="在环中，若 $a,b,ab-1$ 可逆，则"></a>在环中，若 $a,b,ab-1$ 可逆，则</h3><p>由上面恒等式我们知道<br>$$(ab-1)^{-1} = a(ba-1)^{-1}b - 1$$<br>因此<br>$$ \begin{aligned} (a-b^{-1})^{-1} &amp;=<br>\left((ab-1)b^{-1} \right)^{-1} \\<br>&amp;= b\left( a(ba-1)^{-1}b - 1 \right) \\<br>&amp;= ba(ba-1)^{-1}b - b  \\<br>&amp;= (ba-1)^{-1}b<br>\end{aligned}<br>$$<br>注意到<br>$$<br>\begin{align}  (ba-1)^{-1}b - a^{-1} &amp;= (ba-1)^{-1}baa^{-1} - a^{-1} \\<br>&amp;= (ba-1)^{-1}a^{-1} \\<br>&amp;= (aba-a)^{-1}<br>\end{align}<br>$$<br>因此 华罗庚等式 $ \left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a$ 得证。</p>
<h3 id="u4E00_u4E2A_u91CD_u8981_u6052_u7B49_u5F0F"><a href="#u4E00_u4E2A_u91CD_u8981_u6052_u7B49_u5F0F" class="headerlink" title="一个重要恒等式"></a>一个重要恒等式</h3><p>$$ b^{-1} - a^{-1} = ( b+b(a-b)^{-1}b )^{-1} $$</p>
<p>上面恒等式与逆算子连续性有关系。<br>证明：<br>$$<br>\begin{align}  (b^{-1} - a^{-1})^{-1} &amp;= (1-ba^{-1})^{-1}b \\<br>&amp;=(1+b(1-a^{-1}b)^{-1}a^{-1})b \\<br>&amp;= b+b(a-b)^{-1}b<br>\end{align}<br>$$</p>
<h3 id="u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u8BC1_u660E"><a href="#u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u8BC1_u660E" class="headerlink" title="华罗庚恒等式证明"></a>华罗庚恒等式证明</h3><p>$$<br>\begin{align}<br>a \left( a^{-1}b^{-1}a - (a-1)^{-1} b^{-1}(a-1) \right) &amp;=<br>(b^{-1}a- a(a-1)^{-1} b^{-1} (a-1) \\<br>&amp;= ( 1-a(a-1)^{-1} )b^{-1}a + (a-1+1) (a-1)b^{-1} )^{-1} \\<br>&amp;= -(a-1)^{-1}b^{-1}a + b^{-1} + (a-1)b^{-1} \\<br>&amp;= b^{-1} - (a-1)^{-1} b^{-1}(a-1)<br>\end{align}<br>$$</p>
<h3 id="u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u7684_u610F_u4E49"><a href="#u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u7684_u610F_u4E49" class="headerlink" title="华罗庚恒等式的意义"></a>华罗庚恒等式的意义</h3><ol>
<li>华罗庚第一个恒等式可以用来证明一个 Hua’s Theorem：除环间中保持加法和幺元以及逆元的映射必然是除环间的同态或者反同态。</li>
<li>华罗庚第一个恒等式可以证明 Cartan-Brauer-Hua Theorem 即一个除环的真子除环的单位群如果是原除环的单位群的正规子群，则该子除环一定包含于除环的中心。（会在<a href="http://dna049.com/2016/03/23/Cartan-Brauer-Hua-Theorem/">下一篇博文</a>中介绍）</li>
</ol>
<p>最后用一句广为流传的话结尾</p>
<blockquote>
<p>   龙生龙，凤生凤，华罗庚的学生会打洞（矩阵打洞）</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>华罗庚恒等式有两个，都看似奇怪但都有其深刻的应用(数学内部的)</p>
<ol>
<li>若在一个环中 $a,b,1-ab$ 都可逆，则<br>$$<br>\left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a<br>$$</li>
<li>若在一个环中<br>$$<br>a = \left( b^{-1} - (a-1)^{-1}b^{-1}(a-1) \right) \left (a^{-1} b^{-1}a-(a-1)^{-1}b^{-1}(a-1) \right)^{-1}<br>$$<br>上面两个恒等式直接验算即知，可是 <a href="https://en.wiki2.org/wiki/Hua_Luogeng">华老</a> 当初怎么想到这两个很奇怪的恒等式呢，怎么导入的，有什么应用呢？]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自然数的Peano公理]]></title>
    <link href="http://dna049.com/2016/03/19/%E8%87%AA%E7%84%B6%E6%95%B0%E7%9A%84Peano%E5%85%AC%E7%90%86/"/>
    <id>http://dna049.com/2016/03/19/自然数的Peano公理/</id>
    <published>2016-03-19T10:58:25.000Z</published>
    <updated>2016-03-20T00:16:58.000Z</updated>
    <content type="html"><![CDATA[<p>虽然我们从小学就开始学习自然数，但是自然数的真正严格的定义归功于1889年<a href="https://en.wikipedia.org/wiki/Giuseppe_Peano" target="_blank" rel="external">Giuseppe Peano</a> 的工作。介绍如下:<br><a id="more"></a></p>
<h3 id="u81EA_u7136_u6570_u7684_u5B9A_u4E49"><a href="#u81EA_u7136_u6570_u7684_u5B9A_u4E49" class="headerlink" title="自然数的定义"></a>自然数的定义</h3><p>我们把满足如下公理的集合叫做自然数 $\mathbb{N}$。<br>$\mathbb{N}$ 中包含一个特殊元素记作 $0$, 以及一个 $\mathbb{N}$ 到自身的映射 $a \mapsto a^+$，称为后继映射。<br>满足如下 Peano 公理:</p>
<ol>
<li>$0 \notin a^+$ 对任意 $a \in \mathbb{N}$ ；</li>
<li>$a \mapsto a^+$ 是单射；</li>
<li>若 $\mathbb{N}$ 的一个子集 $A$ 包含 $0$ 以及它的任何后继元素，则 $A=\mathbb{N}$。</li>
</ol>
<p>上面的公理3是我们常用数学归纳法的依据。下面介绍一个特别重要的定理。</p>
<p><strong>归纳定理</strong>: 设 $S$ 是一个集合，$\phi$ 是 $S$ 到自身的映射， $a\in S$。则存在唯一的映射 $f \colon \mathbb{N} \to S$ 使得<br>$$ f(0) = a, \qquad f(n^+) = \phi(f(n)), n \in \mathbb{N} $$ </p>
<p><strong>证明</strong>: 设<br>$$ \Lambda ＝ \lbrace U \subset \mathbb{N} \times S \colon (0,a)\in U\; | \; \mbox{ if } (n,b) \in U, \mbox{ then } (n^+,\phi(b)) \in U \rbrace$$<br>显然 $\mathbb{N} \times S \in \Lambda$ ，因此 $\Lambda \neq 0$ ,设 $f ＝ \cap_{U \in T} U$ ，下面证明 $f$ 即为所求。<br>由归纳 $\forall a \in \mathbb{N}, \exists b \in S$ 使得 $(n,b) \in f$ ，因此我们只需证明，若$(n,b),(n,b’) \in f$ 则 $b = b’$。令 $T=\lbrace n \in \mathbb{N} \;|\; (n,b),(n,b’) \in f \Rightarrow b=b’ \rbrace$,我们只需证明 $T = \mathbb{N}$。<br>首先 $0 \in T$ ，否则 $\exists a \neq a’$ 使得 $(0,a), (0,a’) \in f$ 。设 $f’$ 为 $f \setminus \lbrace (0,b’) \rbrace$ 易知 $f’ \in \Lambda$ 矛盾于 $f$ 的定义。<br>类似的 若$r \in T$，可证 $r^+ \in T$ 否则 $\exists c \neq \phi(r) $ 使得 $(r^+,c) \in T$ 设 $f’ = f \setminus \lbrace (r^+,c) \rbrace$ 则 $f’ \in \Lambda$ 矛盾于 $f$ 的定义。<br>假设 $g$ 也满足上述条件，则 $g \in \Lambda$ 因此 $f \subset g$ 但是对于两个映射 $f \subset g$ 可知 $f = g$ 证毕。<br>注: 以上的函数用”图像“的方式给出。</p>
<p>有了上面的 <strong>归纳定理</strong> 我们就可以定义自然数的加法和乘法了，注意定义永远是数学最重要的东西。</p>
<h3 id="u52A0_u6CD5_u4E58_u6CD5_u7684_u5B9A_u4E49"><a href="#u52A0_u6CD5_u4E58_u6CD5_u7684_u5B9A_u4E49" class="headerlink" title="加法乘法的定义"></a>加法乘法的定义</h3><p>两个自然数 $m,n$ 的加法被定义为 令 $a=m$ 和 $\phi \colon n \mapsto n^+$ ,则存在唯一的 $f_m$ 使得<br>$$ 0 + m = m \qquad  n^+ + m = (n+m)^+  $$<br>对于乘法，令 $a=0$ 和 $\phi \colon n \mapsto n＋m$ ,则存在唯一的 $g_m$ 使得<br>$$ 0m = 0 \qquad  n^+ m = nm + m $$</p>
<p>可以证明(其实蛮繁琐的)这样定义的加法满足我们平常所使用的各种法则，例如结合律，交换律等等性质。</p>
<p>下面看一下加法结合率的证明（书上并没有，自己补的）</p>
<ol>
<li>由加法定义可知 $(0+y)+z = y+z = 0+(y+z)$</li>
<li>若问题对 $x$ 成立则，$(x^+ +y)+z = (x+y+z)^+ = x^+ +(y+z)$<br>因此由公理3知 上式对任意的$x \in \mathbb{N}$ 成立，证毕。</li>
</ol>
<h3 id="u81EA_u7136_u6570_u7684_u5E8F_u5173_u7CFB"><a href="#u81EA_u7136_u6570_u7684_u5E8F_u5173_u7CFB" class="headerlink" title="自然数的序关系"></a>自然数的序关系</h3><p>称 $a \geq b$ 若存在 $x \in \mathbb{N}$ 使得 $a = b+x$。<br>显然有以下简单性质</p>
<ol>
<li>$x \geq  y$ 且 $y \geq x$ 则 $x = y$</li>
<li>$x \geq  y$ 且 $y \geq z$ 则 $x \geq z$</li>
<li>$\forall (x,y) \in \mathbb{N} \times \mathbb{N}$ $x \geq y$ 和 $y \geq x$ 至少有一个成立。<br>因此上述定义，定义了一个自然数集上的良序关系。另外自然数关于这种序关系有一个广为人知的结论。</li>
</ol>
<h3 id="u6700_u5C0F_u5143_u6027_u8D28"><a href="#u6700_u5C0F_u5143_u6027_u8D28" class="headerlink" title="最小元性质"></a>最小元性质</h3><p>$\mathbb{N}$ 的任何非空子集 $S$ 存在最小值。即 $\exists l \in S$ 使得 $\forall s\in S, s \geq l$。<br><strong>证明</strong>：设 $M = \lbrace m in \mathbb{N} \;|\; \forall s \in S, s \geq m \rbrace$ 。则 $0 \in M$ 且若 $s_0 \in S$ 则 $s_0^+ \notin M$。因此 $M \neq \mathbb{N}$. 因此由归纳法，存在 $s \in M, s^+ \notin M$ 上述 $s$ 即为所求。</p>
<p>按照公理化定义的自然数的性质验算其实还是很有意思的，虽然验算了也并没有什么屌用。另外知道了自然数的公理化体系也并没有什么屌用0.0<br>另外也有人将自然数写成<br>$$ 0 \equiv \emptyset, 1 equiv \lbrace \lbrace \emptyset \rbrace \emptyset \rbrace,\cdots n^+ \equiv  \lbrace \lbrace \emptyset \rbrace \emptyset \rbrace $$</p>
<p>以上内容来自 Nathan Jacobson 《Basic Algebra》。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然我们从小学就开始学习自然数，但是自然数的真正严格的定义归功于1889年<a href="https://en.wikipedia.org/wiki/Giuseppe_Peano">Giuseppe Peano</a> 的工作。介绍如下:<br>]]>
    
    </summary>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[A note about equal-distance point set]]></title>
    <link href="http://dna049.com/2016/03/15/A-note-about-equal-distance-point-set/"/>
    <id>http://dna049.com/2016/03/15/A-note-about-equal-distance-point-set/</id>
    <published>2016-03-14T16:00:28.000Z</published>
    <updated>2016-03-15T04:11:03.000Z</updated>
    <content type="html"><![CDATA[<p>It is evident true that there are at most 4 points are equal-distance in three dimention Euclidean Space.<br>What about other metric space? This ideal was first generated by my student Yilin Liu, and some results were obtained by us together.</p>
<a id="more"></a>
<ol>
<li>In a discrete metric, $X$ is any non-empty set.<br> $$ \rho(x,y) = \left \lbrace \begin{array}{ll} 1 &amp; x \neq y \\ 0 &amp; x=y  \end{array} \right. $$<br>In this metric space,any subset of $X$ is equal-distance.</li>
<li>Suppose that $X$ if we define<br> $$ \rho(A,B) = |x_1 - x_2| + |y_1 - y_2| + |z_1 - z_2| $$,<br>where $A(x_1,y_1,z_1),B(x_2,y_2,z_2)$.<br>we can find six points satisfy every two of them have some distance,for instance,$(\pm 1,0,0)\;(0,\pm 1,0)\;(0,0,\pm 1)$.</li>
<li>Suppose that $X$ if we define<br> $$ \rho(A,B) = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2 }+ |z_1 - z_2| $$,<br>where $A(x_1,y_1,z_1),B(x_2,y_2,z_2)$.<br>It is hard to find more that 4 point which could feed our demand. Fortunately with a skill construction,we finally get five equal-distance point set as follow<br>$$ (1,0,1); \;(-1,0,-1); \;(-\sqrt{2},0,4-\sqrt{2}); \;(-\frac{3\sqrt{2}}{2},2,\frac{\sqrt{2}}{2}); \;(-\frac{3\sqrt{2}}{2},-2,\frac{\sqrt{2}}{2}) $$ </li>
</ol>
<pre><code>What more, it remains to be considered in n-dimention space,or any metric and topology space.
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>It is evident true that there are at most 4 points are equal-distance in three dimention Euclidean Space.<br>What about other metric space? This ideal was first generated by my student Yilin Liu, and some results were obtained by us together.</p>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Several trick elementary conclusions]]></title>
    <link href="http://dna049.com/2016/03/14/Several-trick-elementary-conclusions/"/>
    <id>http://dna049.com/2016/03/14/Several-trick-elementary-conclusions/</id>
    <published>2016-03-14T15:12:35.000Z</published>
    <updated>2016-03-23T14:34:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible"><a href="#In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible" class="headerlink" title="In a Monoid, if an element is left and right invertible, then it is invertible."></a>In a Monoid, if an element is left and right invertible, then it is invertible.</h3><p>Proof: By hypothesis we have<br>$$ a b = ca = 1 $$<br>hence we have<br>$$ b = cab = c$$<br>therefore $a$ is invertible.</p>
<a id="more"></a>
<p><em>Definition</em>: In a semi-group $A$, $z$ is called left(right) quasi-regular if there exists an element $z’$ such that $z’o z \equiv z’+z-z’z = 0\;(z o z’=0 )$.</p>
<p>If A is a Monoid, actually, $z$ is called left(right) quasi-regular if and only if $1-z$ is left invertible.</p>
<h3 id="In_a_semi-group_2C_if__24z_u2019oz__3D_0_24_and__24z_u2019_u2019oz_u2019__3D_0_24_then__24z_u2019_u2019_3Dz_24_2C_thus_both__24z_24_and__24z_u2019_24_are_quasi-regular"><a href="#In_a_semi-group_2C_if__24z_u2019oz__3D_0_24_and__24z_u2019_u2019oz_u2019__3D_0_24_then__24z_u2019_u2019_3Dz_24_2C_thus_both__24z_24_and__24z_u2019_24_are_quasi-regular" class="headerlink" title="In a semi-group, if $z’oz = 0$ and $z’’oz’ = 0$ then $z’’=z$, thus both $z$ and $z’$ are quasi-regular."></a>In a semi-group, if $z’oz = 0$ and $z’’oz’ = 0$ then $z’’=z$, thus both $z$ and $z’$ are quasi-regular.</h3><p>Proof: It is obvious right in a Monoid. Some trick occur while proving it.<br>$$ z’’ = z’’z’-z’ = z’’(z’z-z)-z’ = (z’’z’-z’’)z-z’=z’z-z = z $$<br>end the proof.</p>
<h3 id="In_a_Ring_2C_241-az_24_is_invertible_if_and_only_if__241-za_24_is_invertible"><a href="#In_a_Ring_2C_241-az_24_is_invertible_if_and_only_if__241-za_24_is_invertible" class="headerlink" title="In a Ring,$1-az$ is invertible if and only if $1-za$ is invertible."></a>In a Ring,$1-az$ is invertible if and only if $1-za$ is invertible.</h3><p>Proof: In fact, we have<br>$$ (1-az)^{-1} = 1+a(1-za)^{-1}z$$</p>
<h3 id="In_a_Ring__24M_24_2C__24z__5Cin_M_24-_If__24_5Cforall_a__5Cin_M_2C_5C_3B_1-az_24_is_left_invertible_2C_then__241-az_24_is_invertible_2Cso_is__241-za_24_why_foregoing_conclusion"><a href="#In_a_Ring__24M_24_2C__24z__5Cin_M_24-_If__24_5Cforall_a__5Cin_M_2C_5C_3B_1-az_24_is_left_invertible_2C_then__241-az_24_is_invertible_2Cso_is__241-za_24_why_foregoing_conclusion" class="headerlink" title="In a Ring $M$, $z \in M$. If $\forall a \in M,\; 1-az$ is left invertible, then $1-az$ is invertible,so is $1-za$ why foregoing conclusion."></a>In a Ring $M$, $z \in M$. If $\forall a \in M,\; 1-az$ is left invertible, then $1-az$ is invertible,so is $1-za$ why foregoing conclusion.</h3><p>Proof: $\forall a \in M$,$1-az$ is left invertible.thus there exists $1-y$ such that<br>$$ (1-y)(1-az) = 1 $$<br>hence $y = (ya-a)z$ is left invertible.<br>Hence by forgoing conclusion $1-az$ is invertible,and so is $1-za$.</p>
<p>Note that:</p>
<pre><code>A semi-group is a set which is closed under an associative multiplication.
A Monoid is a semi-group contain an identity element.
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible"><a href="#In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible" class="headerlink" title="In a Monoid, if an element is left and right invertible, then it is invertible."></a>In a Monoid, if an element is left and right invertible, then it is invertible.</h3><p>Proof: By hypothesis we have<br>$$ a b = ca = 1 $$<br>hence we have<br>$$ b = cab = c$$<br>therefore $a$ is invertible.</p>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gcd经典推导 hdu 5382]]></title>
    <link href="http://dna049.com/2016/03/13/gcd%E7%BB%8F%E5%85%B8%E6%8E%A8%E5%AF%BChdu-5382/"/>
    <id>http://dna049.com/2016/03/13/gcd经典推导hdu-5382/</id>
    <published>2016-03-12T16:20:40.000Z</published>
    <updated>2016-03-13T04:41:37.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/blog/2015-multi-university-training-contest-8-solutions-by-绍兴一中/" target="_blank" rel="external">多校训练</a> 中有一道数论题，推导十分强大，特此记录。<br><a id="more"></a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5382" target="_blank" rel="external">题目链接</a> 和推导过程:<br><img src="proof.png" alt="proof"><br>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">258280327</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],g[N],t[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">        g[i]=<span class="number">1</span>;t[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[i] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j+=i)&#123;</span><br><span class="line">                g[j]&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j+=i)&#123;</span><br><span class="line">            t[j]=(t[j]+g[i-<span class="number">1</span>])%M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        a[i]=(a[i-<span class="number">1</span>]+<span class="number">2</span>*i-<span class="number">1</span>-t[i-<span class="number">1</span>])%M;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;<span class="number">0</span>)  a[i]+=M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        a[i]=(a[i]+a[i-<span class="number">1</span>])%M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span></span><br><span class="line">    <span class="comment">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/blog/2015-multi-university-training-contest-8-solutions-by-绍兴一中/">多校训练</a> 中有一道数论题，推导十分强大，特此记录。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[矩阵快速幂的应用 hdu5451]]></title>
    <link href="http://dna049.com/2016/03/12/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84%E5%BA%94%E7%94%A8-hdu5451/"/>
    <id>http://dna049.com/2016/03/12/矩阵快速幂的应用-hdu5451/</id>
    <published>2016-03-12T07:41:44.000Z</published>
    <updated>2016-03-13T04:37:48.000Z</updated>
    <content type="html"><![CDATA[<p>上次已经写过了矩阵快速幂，这次再写的原因是因为此题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5451" target="_blank" rel="external">hdu5451</a>用了很多的黑科技，因此还是值得记录的。<br><a id="more"></a></p>
<p>问题简述如下:<br>$$ y = (5+ 2\sqrt{6})^{1+2^x}$$<br>where $0 \leq x &lt; 2^{32} $ and a prime number $p(p&lt;46337)$,calculate $r = floor(y) \;mod\; p$. </p>
<p>实际上我们需要计算的是<br>$$ r = (5+ 2\sqrt{6})^{1+2^x} + (5 - 2\sqrt{6})^{1+2^x} -1 $$<br>设 $a_n = (5+ 2\sqrt{6})^{1+2^x} + (5 - 2\sqrt{6})^{1+2^x} $ 则我们有<br>$$ a_0=2,a_1=10,a_n = a_{n-1} +a_{n-2}$$<br>最终答案即为<br>$$ (a_{1+2^n} - 1) \;mod\; M $$<br>另一方面，由递推关系式子，我们知道<br>$$ \left( \begin{matrix} a_{n} \\ a_{n-1} \end{matrix} \right) = A \left( \begin{matrix} a_{n-1} \\ a_{n-2} \end{matrix} \right) = A^{n-1} \left( \begin{matrix} a_1 \\ a_0 \end{matrix} \right) $$<br>因此<br>$$ \left( \begin{matrix} r \\ * \end{matrix} \right) = A^{2^x} \left( \begin{matrix} 10 \\ 2 \end{matrix} \right) $$<br>由于我们需要的是最终结果模 $p$.<br>而 $GL(n,p)$可看成 $n$ 阶方针到自身的可逆变换全体。推理易知道<br>$$ |GL(n,p)| =  \prod_{i=0}^{n-1} (p^n-p^i) $$<br>对于此题中 $ mp = |GL(2,p)| = (p^2-1)(p^2-p) $，由群的Lagrange定理知 $A^{|GL(2,p)|}=I_2$。因此我们只需计算 $A^{2^x} \;mod\; mp$ 用快速幂解决即可，但是这里有一个问题就是 mp 有可能很大，导致快速幂乘法的时候会溢出，于是乘法用快速加法来实现，具体见代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line">LL mod;</span><br><span class="line"><span class="keyword">class</span> Matrix&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">2</span>; <span class="comment">//col</span></span><br><span class="line">    LL a[N][N];</span><br><span class="line">    Matrix(<span class="keyword">int</span> a00=<span class="number">0</span>,<span class="keyword">int</span> a01=<span class="number">0</span>, <span class="keyword">int</span> a10=<span class="number">0</span>,<span class="keyword">int</span> a11=<span class="number">0</span>)&#123;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>]=a00;a[<span class="number">0</span>][<span class="number">1</span>]=a01;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">0</span>]=a10;a[<span class="number">1</span>][<span class="number">1</span>]=a11;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                R.a[i][j]=a[i][j]+A.a[i][j];</span><br><span class="line">                <span class="keyword">if</span>(R.a[i][j]&gt;=mod)   R.a[i][j]-=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                    R.a[i][j] = (R.a[i][j]+a[i][k]*A.a[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix A,LL n)</span></span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">R</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) R=R*A;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r+=x;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=p)    r-=p;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=p)    x-=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,<span class="keyword">unsigned</span> <span class="keyword">int</span> n,LL p)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=mul(r,x,p);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=mul(x,x,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=T;++t)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;mod;</span><br><span class="line">        LL p = mod;</span><br><span class="line">        p = (p*p-<span class="number">1</span>)*(p*p-p);</span><br><span class="line">        <span class="function">Matrix <span class="title">A</span><span class="params">(<span class="number">10</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        Matrix R = <span class="built_in">pow</span>(A,pow_mod(<span class="number">2</span>,x,p));</span><br><span class="line">        LL r = (R.a[<span class="number">0</span>][<span class="number">0</span>]*<span class="number">10</span>+R.a[<span class="number">0</span>][<span class="number">1</span>]*<span class="number">2</span>-<span class="number">1</span>)%mod;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>) r+=mod;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>上次已经写过了矩阵快速幂，这次再写的原因是因为此题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5451">hdu5451</a>用了很多的黑科技，因此还是值得记录的。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="矩阵" scheme="http://dna049.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Fermat平方和定理]]></title>
    <link href="http://dna049.com/2016/03/08/Fermat%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86/"/>
    <id>http://dna049.com/2016/03/08/Fermat平方和定理/</id>
    <published>2016-03-08T11:04:45.000Z</published>
    <updated>2016-03-14T16:32:13.000Z</updated>
    <content type="html"><![CDATA[<p>Fermat平方和定理的表述为：奇质数能表示为两个平方数之和的充分必要条件是该质数被4除余1。这个结论首次由 Euler 在 1747年给出证明。详细叙述如下：</p>
<a id="more"></a>
<p>为方便起见,记<br>$$ A = \lbrace a^2 + b^2 \;|\; a,b \in \mathbb{Z} \rbrace $$</p>
<p>证明分五步完成</p>
<ol>
<li>$(a^2+b^2)(c^2+d^2)=(ac \pm bd)^2 +(ad \mp bc)^2 $<br>proof: 计算即知。</li>
<li>若 $a^2+b^2 \;|\; c^2+d^2$, $a^2+b^2$ 为素数，则<br> $$ \frac{c^2+d^2}{a^2+b^2} \in A$$<br>proof: 由于$(ac-bd)(ac+bd) = (a^2+b^2)c^2-(c^2+d^2)b^2$<br>因此 $(a^2+b^2) \;|\; (ac-bd)(ac+bd)$ 而$(c^2+d^2)$ 是素数，因此必然整除其中一个。<br>假设$(a^2+b^2)|(ac-bd)$,则由1知 $(a^2+b^2)｜(ad+bc)$ 因此<br>$$ \frac{c^2+d^2}{a^2+b^2}=(\frac{ac - bd}{a^2+b^2})^2 +(\frac{ad + bc}{a^2+b^2})^2 $$<br>类似的，假设$(a^2+b^2) \;|\; (ac＋bd)$ 则有<br>$$ \frac{c^2+d^2}{a^2+b^2}=(\frac{ac + bd}{a^2+b^2})^2 +(\frac{ad - bc}{a^2+b^2})^2 $$</li>
<li>$x \;|\; a^2+b^2,x \notin A$，则$\exists y| \frac{a^2+b^2}{x}$ 使得 $y \notin A$<br>反证：设 $ a^2+b^2 = x p_1 p_2 \cdots p_n$ 则，若 则$ \forall y| \frac{a^2+b^2}{x},y \in A$ 则由2，经过 $n$ 次除法，最终 $x \in A$ 矛盾。</li>
<li>若 $(a,b)=1$ 则 $\forall x| a^2+b^2 ,x \in A$<br>假设 $\exists x| a^2+b^2,x \notin A$ 则，我们设<br>$a = mx + c,b = mx + d$,其中$|c|&lt;x,|d| &lt;x$。则<br>$a^2+b^2=(mx+c)^2+(mx+d)^2=tx+(c^2+d^2)$，因此$x \;|\; c^2+d^2$。又 $(a,b)=1$ ，因此 $((c,d),x)=1$。因此不妨设 $(c,d)=1$ 则 $\exists z, zx = c^2+d^2 \leq \frac{x^2}{2}$。即 $z\leq \frac{x}{2}$。由引理3知道 $z$ 有一个因子 $w \notin A$。即我们由 $ x \;|\; a^2+b^2,x \notin A$ 得到了 $ w \;|\; c^2+d^2, w \notin A ,w \leq  \frac{x}{2} $ 这样一直下去必然会在有限步结束，矛盾。</li>
<li>若素数$p=4n+1$，则 $p\in A$。<br>由Fermat小定理知$1,2^{4n},\cdots,(4n)^{4n}$除以 $p$ 模1.<br>因此$2^{4n}－1,3^{4n}－2^{4n},\cdots,(4n)^{4n}-(4n-1)^{4n}$都是 $p$ 的倍数。这些差都有分解<br>$$a^{4n} - b^{4n} = (a^{2n}+b^{2n})(a^{2n}-b^{2n})$$<br>由于上述 $a,b$ 相差为1，必然互素，因此若 $p|a^{2n}+b^{2n}$ 则由4命题得证。否则$2^{2n}-1,3^{2n}-2^{2n},\cdots,(2n)^{2n}-(2n-1)^{2n}$都是 $p$ 的倍数。<br>因此1.对上面式子做$2n$阶差得到 $(2n)!$ 是p的倍数，显然是不可能的。<br>或者2.由于上面序列的前 $d$ 项和 $d^{2n}-1$是$p$的倍数，因此素数 $p$ 无原根，矛盾与原根存在定理。</li>
</ol>
<p>当然上述定理也可以利用<br>$$ \mathbb{Z}[i] \simeq \mathbb{Z}[x]/(x^2+1) $$ 转化到 $F_p$ 域上的不可约问题解决。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Fermat平方和定理的表述为：奇质数能表示为两个平方数之和的充分必要条件是该质数被4除余1。这个结论首次由 Euler 在 1747年给出证明。详细叙述如下：</p>]]>
    
    </summary>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[矩阵快速幂的应用 hdu 1588]]></title>
    <link href="http://dna049.com/2016/03/05/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84%E5%BA%94%E7%94%A8-hdu-1588/"/>
    <id>http://dna049.com/2016/03/05/矩阵快速幂的应用-hdu-1588/</id>
    <published>2016-03-05T14:12:33.000Z</published>
    <updated>2016-03-10T09:21:36.000Z</updated>
    <content type="html"><![CDATA[<p>在一个半群中，$a^n$ 的运算可以使用快速幂，即在不超过 $2log_2(n)$ 的运算下完成计算。<br><a id="more"></a></p>
<p>直接用一个实例 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1588" target="_blank" rel="external">hdu1588 Gauss Fibonacci</a> 即可体现其思想。</p>
<h3 id="u95EE_u9898"><a href="#u95EE_u9898" class="headerlink" title="问题"></a>问题</h3><p>设 f 是 Fibonacci 数列满足：</p>
<ol>
<li>$f(0)=0$</li>
<li>$f(1)=1$</li>
<li>$f(n)=f(n-1)+f(n-2) ,\; n \geq 2$</li>
</ol>
<p>求 Gauss Fibonacci 问题<br>$$ \sum_{i=0}^{n-1} f(k*i+b) $$</p>
<h3 id="u6C42_u89E3"><a href="#u6C42_u89E3" class="headerlink" title="求解"></a>求解</h3><p>令 $ A = \left[ \begin{matrix} 1 &amp; 1 \\ 1 &amp; 0 \end{matrix} \right] $ 则<br>$$ \left( \begin{matrix} f(n+1) \\ f(n) \end{matrix} \right) = A \left( \begin{matrix} f(n) \\ f(n-1) \end{matrix} \right) = A^n \left( \begin{matrix} 1 \\ 0 \end{matrix} \right) $$<br>于是求解 $f(n)$ 可转化为求解 $A^n$ 另外 Gauss Fibonacci 问题可转化为求解<br>$$ A^b \cdot \sum_{i=0}^{n-1} A^{ki} $$</p>
<h3 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//#pragma comment(linker,"/STACK:10240000,10240000")</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">typedef pair&lt;LL,LL&gt; PLL;</span><br><span class="line">#define clr(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define PB push_back</span><br><span class="line">#define lrt rt&lt;&lt;1</span><br><span class="line">#define rrt rt&lt;&lt;1|1</span><br><span class="line">#define lson l,m,lrt</span><br><span class="line">#define rson m+1,r,rrt</span><br><span class="line">/*------------------------- template ------------------------------*/</span><br><span class="line">LL mod;</span><br><span class="line">class Matrix&#123;</span><br><span class="line">public:</span><br><span class="line">    const static int N = 2; //col</span><br><span class="line">    LL a[N][N];</span><br><span class="line">    Matrix(int a00=0,int a01=0, int a10=0,int a11=0)&#123;</span><br><span class="line">        a[0][0]=a00;a[0][1]=a01;</span><br><span class="line">        a[1][0]=a10;a[1][1]=a11;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix operator+(const Matrix&amp; A)const&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">            for(int j=0;j&lt;N;++j)&#123;</span><br><span class="line">                R.a[i][j]=a[i][j]+A.a[i][j];</span><br><span class="line">                if(R.a[i][j]&gt;=mod)   R.a[i][j]-=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return R;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix operator*(const Matrix&amp; A)const&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">            for(int k=0;k&lt;N;++k)&#123;</span><br><span class="line">                for(int j=0;j&lt;N;++j)&#123;</span><br><span class="line">                    R.a[i][j] = (R.a[i][j]+a[i][k]*A.a[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix pow(Matrix A,int n)&#123;</span><br><span class="line">    Matrix R(1,0,0,1);</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) R=R*A;</span><br><span class="line">        n&gt;&gt;=1;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    return R;</span><br><span class="line">&#125;</span><br><span class="line">Matrix getsum(Matrix A,int n)&#123;</span><br><span class="line">    Matrix R(1,0,0,1),X(1,0,0,1);</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) R=(R+X*pow(A,n));</span><br><span class="line">        n&gt;&gt;=1;  X=X*(Matrix(1,0,0,1)+pow(A,n));</span><br><span class="line">    &#125;</span><br><span class="line">    return R;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span><br><span class="line">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span><br><span class="line">    int k,b,n,m;</span><br><span class="line">    while(~scanf("%d%d%d%d",&amp;k,&amp;b,&amp;n,&amp;m))&#123;</span><br><span class="line">        mod = m;</span><br><span class="line">        Matrix A(1,1,1,0);</span><br><span class="line">        Matrix R = pow(A,b)*getsum(pow(A,k),n-1);</span><br><span class="line">        cout&lt;&lt;R.a[1][0]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在一个半群中，$a^n$ 的运算可以使用快速幂，即在不超过 $2log_2(n)$ 的运算下完成计算。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="矩阵" scheme="http://dna049.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自然底数e的由来]]></title>
    <link href="http://dna049.com/2016/02/24/%E8%87%AA%E7%84%B6%E5%BA%95%E6%95%B0e%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <id>http://dna049.com/2016/02/24/自然底数e的由来/</id>
    <published>2016-02-24T15:26:27.000Z</published>
    <updated>2016-02-24T15:45:47.000Z</updated>
    <content type="html"><![CDATA[<p>自然底数 $e$ 之所以重要，我想很大程度上是因为，指数函数 $f(x)=e^x$ 是“唯一”(在常数倍意义下)满足导数等于本身的函数。因此 $e$ 被叫做自然底数。<br><a id="more"></a></p>
<p>然而，$e$ 的定义可以由一个常见的重要数列极限来定义。即<br>$$ e \equiv \lim _{n \to \infty}(1+\frac{1}{n})^n $$<br>那么为什么右边有极限呢，我们来仔细分析。<br>令<br>$$ a_n = (1+\frac{1}{n})^n ,\; b_n =(1+\frac{1}{n})^{n+1} $$<br>则,由<a href="http://dna049.com/2016/02/24/均值不等式/">均值不等式</a>易知<br>$$ a_n = (1+\frac{1}{n})^n \cdot 1 \leq [\frac{n(1+\frac{1}{n})+1}{n+1}]^{n+1} =a_{n+1} $$<br>且<br>$$ \frac{1}{b_n} = (\frac{n}{n+1})^n \cdot 1 \leq [\frac{(n+1)\frac{n}{n+1}+1}{n+2}]^{n+2} = \frac{1}{b_{n+1}} $$<br>因此 $2 = a_1 \leq a_n \leq b_n \leq b_1 = 4$。由于单调有界序列必有极限，不妨把这个极限记作 $e$ 且由上面推理知 $2 &lt; e &lt; 4$。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自然底数 $e$ 之所以重要，我想很大程度上是因为，指数函数 $f(x)=e^x$ 是“唯一”(在常数倍意义下)满足导数等于本身的函数。因此 $e$ 被叫做自然底数。<br>]]>
    
    </summary>
    
      <category term="数学分析" scheme="http://dna049.com/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[均值不等式]]></title>
    <link href="http://dna049.com/2016/02/24/%E5%9D%87%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    <id>http://dna049.com/2016/02/24/均值不等式/</id>
    <published>2016-02-24T15:06:23.000Z</published>
    <updated>2016-02-24T15:25:58.000Z</updated>
    <content type="html"><![CDATA[<p>初中就学过最简单的均值不等式 $\frac{a+b}{2} \geq \sqrt{ab},a ,b \geq 0$。它的证明只需配方就知道了，这里介绍一下一般的均值不等式:<br>$$ \frac{ \sum_{i=1} ^n a_i}{n} \geq \sqrt[n]{\Pi_{i=1}^n a_i }$$<br><a id="more"></a><br>当 $n=1$ 时结论是平凡的，$n=2$ 时配方即知。$n=2^k$时不难用数学归纳法知，结论成立，下面主要看 $2^{k-1} &lt;n&lt; 2^k$的情况<br>令 $A = \frac{ \sum_{i=1} ^n a_i}{n} $ 则，应用 $2^k$ 时的结论<br>$$ \frac{ \sum_{i=1} ^n a_i + (2^k-n)A }{2^k} \geq\sqrt[2^k]{\Pi_{i=1}^n a_i A^{2^k -n}} $$<br>化简可得到结论。</p>
<pre><code>上述证明简单优美，第一次在陈纪修《数学分析》(上)看到这个优美的方法。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>初中就学过最简单的均值不等式 $\frac{a+b}{2} \geq \sqrt{ab},a ,b \geq 0$。它的证明只需配方就知道了，这里介绍一下一般的均值不等式:<br>$$ \frac{ \sum_{i=1} ^n a_i}{n} \geq \sqrt[n]{\Pi_{i=1}^n a_i }$$<br>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最强装逼题目0.0]]></title>
    <link href="http://dna049.com/2016/02/24/%E6%9C%80%E5%BC%BA%E8%A3%85%E9%80%BC%E9%A2%98%E7%9B%AE0-0/"/>
    <id>http://dna049.com/2016/02/24/最强装逼题目0-0/</id>
    <published>2016-02-24T13:50:13.000Z</published>
    <updated>2016-02-24T15:05:51.000Z</updated>
    <content type="html"><![CDATA[<p>数学老师想好了两个自然数 $m,n$ 满足 $2 \leq m \leq n \leq 100$ ,他把 $m,n$ 的和 $s$ 告诉了 $S$ 同学，把 $m,n$ 的积 $p$ 告诉了 $P$ 同学，他们都是聪明诚实的学生。进行了下面对话<br>$S$: 我不知道 $m,n$ 的值，但我知道你也不知道。<br>$P$: 现在我知道了。<br>$S$: 现在我也知道了。<br>请问 $m,n$ 的值。<br><a id="more"></a></p>
<ol>
<li>由第一句话，我们知道 $s \geq 6$,且 $p$ 中无大于或者等于 53 的质因数。但是 $S$ 是如何知道的呢，可见 $s \leq 54$。对 数 $6 ~ 54$ 逐一检查发现，除了$A = \lbrace 11,17,23,27,29,35,37,41,47,51,53 \rbrace$的其他元素外，其余每个数都可以表示成两个素数的和，因此从第一句话知道，$ s \in A$。</li>
<li>刚刚推理 $P$ 同学当然也能完成。由于 $A$ 中的元素全是奇数，因此，若 $p = 2^k \cdot (2v+1), k \geq 0, v \geq 0$ 或者 $p = 2^k \cdot (2v+1)(2j+1), k \geq 0, v \geq 0, j \geq 0$ 则 $P$ 同学就能确定的知道答案。</li>
<li><p>$S$ 同学最后也知道了 $m,n$ 的值，说明在 $s$ 所有分解 $s = m+ n, 2 \leq m \leq n \leq 100$ 中，且有一种满足 $xy = 2^k v$。<br>检查 $11 = 4+7 = 3+8$, $23 = 4 + 19 = 7+16$, $27 = 4+23 = 8+19$, $35=4+31=16+19$, $37 = 8+29 = 5+32$, $47= 4 + 43 = 16+31$, $51 = 4+47 = 8+43$。<br>又因为<br>$$ 29 = 4 + 25 = 13 +16,\; 41 = 4+37 = 16 + 25,\; 53 = 16 +37 = 21 + 32 $$<br>其中 $4 \times 25 = 100 = 20 \times 5$, $20+5 =25 \notin A$, $16 \times 25 = 400 = 80 \times 5$, $80+5 =85 \notin A$, $21 \times 32 = 672 = 7 \times 96$ ,$ 7+96 =103 \notin A$。<br>因此，只可能 $s=17$<br>$$ 17 = 2+15 = 3+14 = 4+13 = 5+12 = 6+11 = 7 +10 = 8+9 $$<br>其中只有 $17 =4 + 13$ 满足 $P$ 的断言，因此 $m = 4,n=13$。</p>
<p> 此题是我高三（2011年）在《奥赛金牌之路》中所见，实在很吊，一直铭记于心,特此记录。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>数学老师想好了两个自然数 $m,n$ 满足 $2 \leq m \leq n \leq 100$ ,他把 $m,n$ 的和 $s$ 告诉了 $S$ 同学，把 $m,n$ 的积 $p$ 告诉了 $P$ 同学，他们都是聪明诚实的学生。进行了下面对话<br>$S$: 我不知道 $m,n$ 的值，但我知道你也不知道。<br>$P$: 现在我知道了。<br>$S$: 现在我也知道了。<br>请问 $m,n$ 的值。<br>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[My Math work edited by LaTex]]></title>
    <link href="http://dna049.com/2016/02/23/My-Math-work-edited-by-LaTex/"/>
    <id>http://dna049.com/2016/02/23/My-Math-work-edited-by-LaTex/</id>
    <published>2016-02-23T11:17:02.000Z</published>
    <updated>2016-02-23T11:17:02.000Z</updated>
    <content type="html"><![CDATA[<p>This blog makes a record of my math work and will be update frequently.Click to view or download it.</p>
<a id="more"></a>
<h4 id="Here_are_PDF_version_of_my_math_work"><a href="#Here_are_PDF_version_of_my_math_work" class="headerlink" title="Here are PDF version of my math work"></a>Here are PDF version of my math work</h4><p><a href="1.pdf">Config of ACM-ICPC</a></p>
<p><a href="2.pdf">Some results about matrix</a></p>
<p><a href="3.pdf">Decomposition of 1 by 1/n </a></p>
<p><a href="4.pdf">Nowhere dense set and frist category set</a></p>
<p><a href="5.pdf">Relationship between Spectral Radius ,Numerical Radius and Spectral norm</a></p>
<p><a href="6.pdf">Some results about group</a></p>
<p><a href="7.pdf">The inverse of I-ba and I-ab</a></p>
<p><a href="8.pdf">example of function that only derivable on one point</a></p>
<p><a href="0.pdf">undergraduate graduation paper</a></p>
<h4 id="Here_are_Tex_version_of_my_math_work"><a href="#Here_are_Tex_version_of_my_math_work" class="headerlink" title="Here are Tex version of my math work"></a>Here are Tex version of my math work</h4><p><a href="1.tex">Config of ACM-ICPC.tex</a></p>
<p><a href="2.tex">Some results about matrix.tex</a></p>
<p><a href="3.tex">Decomposition of 1 by 1/n.tex</a></p>
<p><a href="4.tex">Nowhere dense set and frist category set.tex</a></p>
<p><a href="5.tex">Relationship between Spectral Radius ,Numerical Radius and Spectral norm.tex</a></p>
<p><a href="6.tex">Some results about group.tex</a></p>
<p><a href="7.tex">The inverse of I-ba and I-ab.tex</a></p>
<p><a href="8.tex">example of function that only derivable on one point.tex</a></p>
<h3 id="LaTex_is_a_wonderful_tool_for_Mathematics"><a href="#LaTex_is_a_wonderful_tool_for_Mathematics" class="headerlink" title="LaTex is a wonderful tool for Mathematics"></a>LaTex is a wonderful tool for Mathematics</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>This blog makes a record of my math work and will be update frequently.Click to view or download it.</p>]]>
    
    </summary>
    
      <category term="Tex" scheme="http://dna049.com/tags/Tex/"/>
    
      <category term="数学" scheme="http://dna049.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[整数集上的一种奇特拓扑]]></title>
    <link href="http://dna049.com/2016/02/22/%E6%95%B4%E6%95%B0%E9%9B%86%E4%B8%8A%E7%9A%84%E4%B8%80%E7%A7%8D%E5%A5%87%E7%89%B9%E6%8B%93%E6%89%91/"/>
    <id>http://dna049.com/2016/02/22/整数集上的一种奇特拓扑/</id>
    <published>2016-02-22T13:41:23.000Z</published>
    <updated>2016-02-23T11:34:31.000Z</updated>
    <content type="html"><![CDATA[<p>在《Proofs from THE BOOK》里素数无限的六种证明的第五种讲到了一种用点集拓扑学知识证明的方法，其中引入了整数集上的一种奇特拓扑。<br><a id="more"></a></p>
<p>对 $a,b \in \mathbb{Z},b&gt;0$，令<br>$$ N_{a,b} = \lbrace a + nb \colon n \in \mathbb{Z} \rbrace $$<br>我们称集合 $O \subset \mathbb{Z}$ 是开集，若$O = \emptyset$，或者 $ \forall a \in O,\exists b&gt;0,st. N_{a,b} \subset O$,容易验证这样定义的开集族全体构成了 $\mathbb{Z}$ 上的拓扑。<br>并且每个$N_{a,b}$ 都是既开又闭的。这是由于<br>$$ N_{a,b} = \mathbb{Z} \setminus \cup_{i-1}^{b-1} N_{a+i,b}$$</p>
<p>又由<br>$$ \mathbb{Z} \setminus \lbrace -1,1 \rbrace = \cup_{p \in P} N_{0,p} $$<br>若素数只有有限个，则$P$是有限集，从而$\lbrace -1,1 \rbrace$是开集，矛盾。</p>
<p>上述方法脑洞大，形式简洁，不愧是 <a href="0.pdf">《Proofs from THE BOOK》</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在《Proofs from THE BOOK》里素数无限的六种证明的第五种讲到了一种用点集拓扑学知识证明的方法，其中引入了整数集上的一种奇特拓扑。<br>]]>
    
    </summary>
    
      <category term="拓扑" scheme="http://dna049.com/tags/%E6%8B%93%E6%89%91/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hahn-Banach 延拓定理]]></title>
    <link href="http://dna049.com/2016/02/19/Hahn-Banach-%E5%BB%B6%E6%8B%93%E5%AE%9A%E7%90%86/"/>
    <id>http://dna049.com/2016/02/19/Hahn-Banach-延拓定理/</id>
    <published>2016-02-19T00:26:38.000Z</published>
    <updated>2016-02-23T11:34:40.000Z</updated>
    <content type="html"><![CDATA[<p>Hahn-Banach 延拓定理通常分为分析和几何的形式，其中几何形式通常称为凸集分离性定理。<br><a id="more"></a></p>
<h3 id="Hahn-Banach__u5EF6_u62D3_u5B9A_u7406_u7684_u5206_u6790_u5F62_u5F0F"><a href="#Hahn-Banach__u5EF6_u62D3_u5B9A_u7406_u7684_u5206_u6790_u5F62_u5F0F" class="headerlink" title="Hahn-Banach 延拓定理的分析形式"></a>Hahn-Banach 延拓定理的分析形式</h3><p><strong>定义1</strong> 设 $X$ 是线性空间，$p \colon X \to \mathbb{R}$ 是一个泛函，若 $p$ 满足</p>
<ol>
<li>$p(x+y) \leq p(x)+p(y)$ 则称 $p$ 在 $X$ 上是次可加的，若</li>
<li>$p(tx)=tp(x),\; \forall x \in X,t \geq 0$ 则称 $p$ 在 $X$ 上是正齐次的，若 $p$ 满足1和</li>
<li>$p(ax)=|a|p(x),\; \forall x \in X, a \in \Phi $ 则称 $p$ 是 $X$ 上的半范数。</li>
</ol>
<p><strong>定理1</strong> (实情形) 设 $X$ 是实线性空间， $p \colon X \to \mathbb{R}$是正齐性次可加泛函，$Y$ 是 $X$ 的线性子空间。若 $f_0 \colon Y \to \mathbb{R}$ 是 $Y$ 上的线性泛函，满足<br>$$ f_0(x) \leq p(x),\; \forall x \in Y $$<br>则 $X$ 上存在线性泛函 $f \colon X \to \mathbb{R}$使得<br>$$ f|_Y = f_0 ,f(x) \leq p(x),\; \forall x \in X $$</p>
<p>证明: 设 $x_0 \in X \setminus Y$ 记 $ \widetilde{Y} = span\lbrace  x_0,Y\rbrace$,首先将 $Y$ 延拓到 $\widetilde{Y}$ 再利用Zorn引理延拓完成整个证明。<br>$$ f(x) + f(y) =f(x+y) \leq p(x+y) \leq p(x-x_0) + p(x_0+y),\; \forall x,y \in Y $$<br>因此<br>$$ f(x) - p(x-x_0) \leq p(x_0+y) - f(y) $$<br>我们记 $ \alpha \equiv \inf_{y \in Y} p(x_0+y) - f(y)$，则<br>$$ f(x) - \alpha \leq p(x - x_0) ,\; f(y) + \alpha \leq f(y+x_0) ,\; \forall x,y \in Y$$<br>在 $\widetilde{Y}$ 上定义 $ f(tx_0 +y) = t \alpha + f_0(y) $ 显然 $f$ 是 $\widetilde{Y}$ 上的线性泛函且是 $f_0$ 的延拓且满足 $f(x) \leq p(x)$。<br>根据延拓关系建立偏序关系，用Zorn引理即知定理1成立</p>
<p><strong>定理2</strong> (复情形) 设 $X$ 是复线性空间， $p \colon X \to \mathbb{R}$是 $X$ 上的半范数，$Y$ 是 $X$ 的线性子空间。若 $f_0 \colon Y \to \mathbb{C}$ 是 $Y$ 上的线性泛函，满足<br>$$ |f_0(x)| \leq p(x),\; \forall x \in Y $$<br>则 $X$ 上存在线性泛函 $f \colon X \to \mathbb{C}$使得<br>$$ f|_Y = f_0 ,|f(x)| \leq p(x),\; \forall x \in X $$</p>
<p>证明: 考虑实部应用定理1，可以证明定理2. 取 $u = \Re{f_0}$ 则，由定理1，$u$ 可以延拓到 $X$ 上得到实线性泛函 $U$ 使得 $U(x) \leq p(x) ,\; \forall x \in X$ 。定义 $f(x) = U(x) - iU(ix),\; \forall x \in X$ 任意验证 $f$ 即为所求。  </p>
<p><strong>推论1</strong> 设 $X$ 是赋范空间，$x_0 \in X$,则存在连续线性泛函 $f$ 满足 $f(x_0) = ||x_0|| ,||f|| = 1$.<br><strong>推论2</strong> 设 $Y$ 是赋范空间 $X$ 的真闭子空间， 则存在连续线性泛函 $f$ 满足</p>
<ol>
<li>$f(y) = 0,y \in Y$,</li>
<li>$f(x) = dist(x,Y)$</li>
<li>$||f|| = 1$</li>
</ol>
<p><strong>推论3</strong> 设 $X$ 是赋范空间，$x_0,y_0 \in X, x_0 \neq y_0$ ，则存在连续线性泛函 $f$，使得 $f(x_0) \neq f(y_0)$</p>
<h3 id="Hahn-Banach__u5EF6_u62D3_u5B9A_u7406_u7684_u51E0_u4F55_u5F62_u5F0F"><a href="#Hahn-Banach__u5EF6_u62D3_u5B9A_u7406_u7684_u51E0_u4F55_u5F62_u5F0F" class="headerlink" title="Hahn-Banach 延拓定理的几何形式"></a>Hahn-Banach 延拓定理的几何形式</h3><p><strong>定理3</strong> 设 $X$ 是拓扑线性空间， $X^{* }$ 表示其上连续线性泛函全体，$A,B \subset X$ 是非空凸集。</p>
<ol>
<li>若 $A^{o} \neq \emptyset, A^{o} \cap B = \emptyset$ 则 $\exists f \in X^{* },f \neq 0$ 使得<br>$$ \Re f(x) \leq \Re f(y),\; \forall x \in A,y \in B. $$</li>
<li>若 $A$ 是开集，$A \cap B = \emptyset$, 则 $\exists f \in X^{* },r \in \mathbb{R}$ 使得<br>$$ \Re f(x) &lt; r \leq \Re f(y),\; \forall x \in A,y \in B. $$<br>若B也是开集，则可使右端不等式严格成立。</li>
<li>若空间 $X$ 是局部凸的，$A$ 是紧集，$B$ 是闭集，$A \cap B = \emptyset$ 则 $\exists f \in X^{* },r_1,r_2 \in \mathbb{R}$ 使得<br>$$ \Re f(x) \leq r_1 &lt; r_2 \leq \Re f(y),\; \forall x \in A,y \in B. $$</li>
<li>若空间 $X$ 是局部凸的，$A$ 是平衡开集，$A \cap B = \emptyset$ 则 $\exists f \in X^{* },r \in \mathbb{R}$ 使得<br>$$ |f(x)| &lt; r \leq |f(y)|, \; \forall x \in A,y \in B $$</li>
</ol>
<p>证明: 由于复线性泛函 $f$ 可以写成 $f(x) = \Re f(x) - i \Re f(ix)$ ,我们不妨假设 $X$ 是实空间，否则先将复空间视作是空间，得出实线性泛函，然后根据上式构造$X$上的复线性泛函，并不为影响上面的结论。</p>
<ol>
<li>不妨假定(线性泛函平移一下) $0 \in A^{o}$，取 $x_0 \in B$,令 $C = A^{o} - B + x_0$ 则 $C$ 是开凸集，$x_0 \notin C$。若$\mu_C$是$C$的 Minkovski 泛函(是正齐次次可加泛函)，则$\mu_C(x_0) \geq 1$ 定义<br>$$ M = \lbrace t x_0 \colon t \in \mathbb{R} \rbrace , f_0(t x_0) = t$$<br>在 $M$ 上 $f_0(t x_0) = t \leq t\mu_C(x_0) \leq \mu_0(t x_0)$ 由定理1知，存在线性泛函 $f \colon X \to \mathbb{R}$ 使得<br>$$ f|_M = f_0 ,f(x) \leq \mu_C(x),\; \forall x \in X $$<br>注意到在$C \cap (-C)$ 上<br>$$ \pm f(x) = f(\pm x) \leq \mu_C (\pm x) \leq 1$$<br>易知 $f$ 连续。<br>当 $x \in A^{o},y \in B$ 时 $x-y+x_0 \in C$,因此<br>$$f(x-y+x_0) \leq \mu_C(x-y+x_0) \leq 1$$<br>因此 $f(x) &lt; f(y)$,又对于凸集$A$ 有$ \overline{A^{o}} = \overline{A}$，所以 $f(x) \leq f(y),\; \forall x \in A ,y \in B$.</li>
<li>对上述 $f$ 记 $r = \inf_{y \in B} f(y)$,若 $A$ 是开集，则有 $f(x) \leq r, \forall x \in A$，否则设 $x_0 \in A,f(x_0) = r$.因为 $A$ 是开集，因此存在 $z \in X$ 使得$x_0 \pm z \in A,f(z) \neq 0$.于是 $f(x_0 \pm z) = r \pm  f(z)$矛盾，同理 $B$ 为开集时，右端也是严格的。</li>
<li>当 $A$ 紧，$B$ 闭时，取凸邻域 $V \in N(0)$，使得$ (A+V) \cap B = 0 $ ，由1，存在 $f \in X^{* },r \in \mathbb{R}$ 使得<br>$$ \Re f(x) &lt; r \leq \Re f(y),\; \forall x \in A+V,y \in B. $$<br>记 $r_1 = \sup_{x \in A} f(x),r_2 =\inf_{y \in B} f(y)$.因为 $A$ 是紧集，因此 r_1 必然可达到，此时必有 $r_1 \leq  r_2$，否则又会出现类似于2的矛盾。</li>
<li>根据2，存在$f \in X^{* },r&gt;0$ 使得<br>$$ \Re f(x) &lt; r \leq \Re f(y),\; \forall x \in A,y \in B. $$<br>由于 $A$ 是平衡集，故 $x \in A$ 当且仅当 $e^{-i \theta}x \in A, \theta \in \mathbb{R}$,特别的取 $\theta = \arg f(x)$ 则<br>$$ |f(x)| = e^{-i \theta}f(x) = f(e^{i \theta}x) = \Re f(e^{i \theta}x) &lt; r $$<br>这是我们要的不等式左边，右边直接由 $\Re f(y) \leq |f(y)|$ 得到,证毕。</li>
</ol>
<p>欢迎访问和评论 <a href="http://dna049.com">http://dna049.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Hahn-Banach 延拓定理通常分为分析和几何的形式，其中几何形式通常称为凸集分离性定理。<br>]]>
    
    </summary>
    
      <category term="泛函分析" scheme="http://dna049.com/tags/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拓扑线性空间的若干基本定理]]></title>
    <link href="http://dna049.com/2016/02/18/%E6%8B%93%E6%89%91%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/"/>
    <id>http://dna049.com/2016/02/18/拓扑线性空间的若干基本定理/</id>
    <published>2016-02-18T08:02:15.000Z</published>
    <updated>2016-02-23T11:16:57.000Z</updated>
    <content type="html"><![CDATA[<p>在泛函分析中几个基本重要的定理：一致有界原理，开映射定理，闭图像定理等都可以相应的推广到拓扑线性空间中。以下内容来自刘培德《拓扑线性空间与算子谱理论》第二章。<br><a id="more"></a></p>
<p>设 $X,Y$ 是拓扑线性空间，记$L(X,Y)$ 是 $X$ 到 $Y$ 的线性算子全体，而$\mathscr{L}(X,Y)$ 是 $X$ 到 $Y$ 的连续线性算子全体。$N_X(x)$ 表示 $x \in X$ 的邻域全体。除非特别声明，以下$X,Y$都是拓扑线性空间</p>
<h3 id="u7B49_u5EA6_u8FDE_u7EED_u548C_u4E00_u81F4_u6709_u754C"><a href="#u7B49_u5EA6_u8FDE_u7EED_u548C_u4E00_u81F4_u6709_u754C" class="headerlink" title="等度连续和一致有界"></a>等度连续和一致有界</h3><p>等度连续: 称算子族 $\mathscr{H} \subset L(X,Y)$ 是等度连续的，若 $\forall U \in N_Y(0), V \in N_X(0)$ 使得<br><span>$$T(V) \subset U, \; \forall T \in \mathscr{H}
 \; \Leftrightarrow \;
\cup_{T \in \mathscr{H} } T(V) \subset U$$</span><!-- Has MathJax --></p>
<p>一致有界: 称算子族 $\mathscr{H} \subset L(X,Y)$ 是一致有界的，若对 $X$ 中任一有界集 $E$ , $\cup_{T \in \mathscr{H}} T(E)$ 是有界.</p>
<p><strong>定理1</strong> 设 $\mathscr{H}$ 是 $L(X,Y)$ 中的一族算子。</p>
<ol>
<li>若 $\mathscr{H}$ 是等度连续的，则 $\mathscr{H}$ 是一致有界的。</li>
<li>若 $X$ 是可度量化的，$\mathscr{H}$ 是一致有界的，则 $\mathscr{H}$ 是等度连续的</li>
</ol>
<p>证明：</p>
<ol>
<li>若 $\mathscr{H}$ 是等度连续的，则$\forall U \in N_Y(0), \exists V \in N_X(0)$ 使得 $T(V) \subset U, \; \forall T \in \mathscr{H}$ .对 $X$ 中任一有界集 $E$，则 $\exists t &gt; 0$ 使得 $s&gt;t$ 时，$E \subset sV$,于是<span>$$T(E) \subset T(sV) = sT(V) \subset sU , \;
\forall T \in \mathscr{H}$$</span><!-- Has MathJax -->
从而 $\cup _ {T \in \mathscr{H} } T(V) \subset U$ , $\mathscr{H}$ 是一致有界的。</li>
<li>反证，设 $U \in N_Y(0)$ ,若不存在 $V$ 使得 $\cup_{T \in \mathscr{H} } T(V) \subset U$ ,则可取 $T_n \in \mathscr{H},x_n \in X, x_n \to 0$ 但 $Tx_n \notin U$.由于 $d(x_n,0) \to 0$ ,存在 $r_n \to \infty$ 使得 $r_n x_n \to 0$ . $r_n x_n$ 是有界的，从而 $\cup_{T \in \mathscr{H}} T(r_n x_n)$ 有界。但是<br>$$ r_n ^{-1} T(r_n x_n) = T(x_n) \notin U $$<br>矛盾与有界性的等价条件。</li>
</ol>
<h3 id="u4E00_u81F4_u6709_u754C_u6027_u539F_u7406"><a href="#u4E00_u81F4_u6709_u754C_u6027_u539F_u7406" class="headerlink" title="一致有界性原理"></a>一致有界性原理</h3><p><strong>定理2</strong> 设 $\mathscr{H} \subset \mathscr{L}(X,Y)$ , 记$E$为使 $\lbrace Tx:T \in \mathscr{H} \rbrace$ 的点 $x$ 全体。若 $E$ 是第二纲集，则 $\mathscr{H}$ 等度连续，此时必有 $E=X$.</p>
<p>证明：设 $W \in N_Y(0)$ ，取0点的平衡邻域 $U$ 使得 $ \overline{U} + \overline{U} \subset W$ 。记 $B = \cap_{T \in \mathscr{H} } T^{-1} (\overline{U})$，有 $T$ 的连续性知 $B$ 是闭集。$\forall x \in E, \lbrace Tx, T \in mathscr{H} \rbrace$ 有界。因此，$\exists n$ 使得 $Tx \in nU \forall T \in \mathscr{H} $，即 $\frac{x}{n} \in T^{-1} (U) \in T^{-1} (\overline{U})$ 。于是 $x \in nB,E \subset \cup_{n=1}^{\infty} nB$。$E$ 是第二纲集，因此有某个 $(nB)^{o} \neq \emptyset $,从而 $(B)^{o} \neq \emptyset $.<br>设 $x \in B^{o}$,记 $V = x-B^{o}$ ,则 $V \in N_X(0)$.注意到 $T(B) \in \overline{U} ,\forall T \in \mathscr{H} $。因此<br>$$ T(V) \subset Tx - T(B) \subset \overline{U} - \overline{U} \in W ,\forall T \in \mathscr{H} $$<br>这说明 $\mathscr{H}$ 是等度连续的。<br>由定理1知，此时 $\mathscr{H}$ 是一致有界的，又单点集 ${x}$ 有界，因此 $\lbrace Tx:T \in \mathscr{H} \rbrace$ 有界，所以 $E=X$。</p>
<p>定理3 (Banach-Steinhaus) 设 $ T_n\in \mathscr{L}(X,Y)$ , 记$E$为使 $\lim_{n \to \infty} T_n x $ 存在的 $x$ 全体。若 $E$ 是第二纲集，则$E=X$.<br>证明：由于收敛序列是有界的，因此根据定理2，上述结论显然。</p>
<h3 id="u5F00_u6620_u5C04_u5B9A_u7406"><a href="#u5F00_u6620_u5C04_u5B9A_u7406" class="headerlink" title="开映射定理"></a>开映射定理</h3><p>从 $X$ 到 $Y$ 的线性算子称为开算子，如果它把 $X$ 中的每一个开集映成 $Y$ 中的开集。</p>
<p><strong>定理4</strong> (开映射定理) 若 $X,Y$ 是 $F$ 空间(完备的赋准范空间)，$T \in \mathscr{L}(X,Y),T(X)$ 是 $Y$ 中的第二纲集，则 $T$ 是开算子，且此时$Y=T(X)$。</p>
<p>为证明开映射定理，先证明三个引理。</p>
<p><strong>引理1</strong> 设 $T:X \to Y$ 是线性算子，则 $T$ 是开映射，当且仅当 $\forall V \in N_X(0)$,$0 \in Y$ 是 $T(V)$ 的内点。</p>
<p>证明：若$T$ 是开算子，$V \in N_X(0)$,则 $T(V)$开，又 $T0=0$ ,故 $0 \in Y$ 是 $T(V)$ 的内点。<br>反之，若 $T$ 将0点的邻域映成以0为内点的集合。则对每个开集 $B \subset X$ ,$B$ 可以写成 $B = \cup_{x \in B } (x+V_x) $ 于是<br>$$ T(B) = \cup_{x \in B} T(x+V_x) = \cup_{x \in B}(Tx - T(V_x)) $$<br>由于 $T(V_x)$ 是以0为内点，上式表明 $Tx$ 是 $T(B)$ 的内点,从而 $T(B)$ 是 $Y$ 中的开集。</p>
<p><strong>引理2</strong> 设 $T:X \to Y$ 是线性算子，则 $T$ 是开映射，则 $T$ 是到上(满)的。</p>
<p>证明: 若 $T$ 是开映射，则 $\forall V \in X$, $T(V)$ 是 $Y$ 中的开集，$V,T(V)$都是吸收的，所以<br>$$ Y = \cup_{n=1}^{\infty} nT(V) = T(\cup_{n=1}^{\infty} nV) = T(X) $$</p>
<p><strong>引理3</strong> 设 $T:X \to Y$ 是线性算子，若 $T(X)$ 是 $Y$ 中的第二纲集，则 $\forall U \in N_X(0),\exists B \in N_Y(0)$ 使得 $B \in \overline{T(U)}$</p>
<p>证明: $\forall U \in N_X(0)$ ,取 $\forall V \in N_X(0)$ 使得 $V$ 是平衡的且 $V-V \subset U$.<br>$$ T(X) = T(\cup_{n=1}^{\infty} nV) = \cup_{n=1}^{\infty} nT(V)$$ 是第二纲的，所以 $\exists n$ 使得 $\overline{nT(V)}^{o} \neq \emptyset$，因此 $\overline{T(V)}^{o} \neq \emptyset$. 于是存在开集 $B \in N_X(0)$ 使得<br>$$B \subset \overline{T(V)} - \overline{T(V)} \subset \overline{T(V-V)} \subset \overline{T(U)} $$ </p>
<p>开映射定理证明: 设 $p,q$ 分别是 $X,Y$ 上的准范数，取<br>$$ U=\lbrace x \colon p(x)&lt;r \rbrace ,\quad U_n = \lbrace x \colon q(x) &lt; \frac{r}{2^n} \rbrace $$<br>由引理3知，存在$B_n \in N_Y(0)$ 使得 $B_n \subset \overline{T(U_n)}$.由引理1知，我们只需证明 $B_1 \subset U$.记<br>$$ O_n = \lbrace y \in Y \colon q(y) &lt; \frac{1}{n} \rbrace $$<br>任取 $y_1 \in B_1 \subset \overline{T(U_1)}$, 于是 $\exists x_1 \in U_1$ 使得 $y_2 = y_1 - Tx_1 \in B_2 \cap O_2$,类似地做，$\exists x_n \in U_n$ 使得 $y_{n+1} = y_n - Tx_n \in B_{n+1} \cap O_{n+1}$<br>此时<br>$$ y_{n+1} = y_1 -T(\sum_{i=1}^n x_i)$$<br>由于<br>$$ p(\sum_{i=1}^n x_i) \leq \sum_{i=1}^n p(x_i) &lt; \sum_{i=1}^n \frac{r}{2^n} &lt; r $$<br>并且由于 $\lbrace \sum_{i=1}^n x_i \rbrace$ 是Cauchy列，$\exists x_0 \in X, \sum_{i=1}^n x_i \to x_0$ 并且 $p(x_0) &lt; r$,从而 $x_0 \in U$。<br>注意到 $y_n \in O_n$, $y_n \to 0$。由 $T$ 的连续性<br>$$ 0 = \lim_{n \to \infty} y_{n+1} = y_1 - \lim_{n \to \infty} T(\sum_{i=1}^n x_i) = y_1 - Tx_0 $$<br>即 $y_1 = Tx_0 \in T(U)$,故$B \in T(U)$,证毕。</p>
<p><strong>推论1</strong> (Banach逆算子定理的推广) 从 $F$ 空间到　$F$ 空间上的每一个连续线性满算子 $T$ 的开算子，若 $T$ 还是一一的，则 $T$ 是同胚映射。<br><strong>推论2</strong> (范数等价定理的推广) 设 $X$ 上有两种拓扑 $\tau_1,\tau_2$,并且$\tau_1,\tau_2$ 都使 $X$ 成为 $F$ 空间，若$\tau_1,\tau_2$ 是可比较的，则$\tau_1 ＝ \tau_2$ 。</p>
<h3 id="u95ED_u56FE_u50CF_u5B9A_u7406"><a href="#u95ED_u56FE_u50CF_u5B9A_u7406" class="headerlink" title="闭图像定理"></a>闭图像定理</h3><p>设 $X,Y$ 是拓扑线性空间，$X \times Y$ 是乘积空间，$T \colon X \to Y$ 是线性算子，称 $T$ 是闭算子，若 $T$ 的图像 $\mathscr{G}(T) = \lbrace (x,Tx) \colon \forall x \in X \rbrace$ 是 $X \times Y$ 中的闭集。</p>
<p><strong>定理5</strong> 设 $X,Y$ 是拓扑线性空间，$T \colon X \to Y$ 是线性算子</p>
<ol>
<li>若 $T$ 是连续的，则 $T$ 是闭算子</li>
<li>(闭图像定理)若 $T$ 是闭算子，并且 $X,Y$ 都是 $F$ 空间，则 $T$ 是连续的。</li>
</ol>
<p>证明:</p>
<ol>
<li>设$T \colon X \to Y$ 连续，$(x_{\lambda},\lambda \in \Lambda)$ 是 $X$ 中的网，$x_{\lambda} \to x ,Tx_{\lambda} \to y$,则<br>$$ y = \lim_{\lambda \in \Lambda} Tx_{\lambda} =  T(\lim_{\lambda \in \Lambda} x_{\lambda}) = Tx$$<br>因此 $(x,y) \in \mathscr{G}(T)$,因此 $T$ 是闭算子。</li>
<li>注意到此时 $X \times Y$ 也是 $F$ 空间，由于 $\mathscr{G}(T)$ 是 $X \times Y$ 的线性子空间，若 $\mathscr{G}(T)$ 在 $X \times Y$ 中闭，$\mathscr{G}(T)$ 也是 $F$ 空间。由乘积拓扑的定义，两投影<br>$$ \pi_1 \colon \mathscr{G}(T) \to X, (x,Tx) \mapsto x, $$<br>$$ \pi_2 \colon \mathscr{G}(T) \to X, (x,Tx) \mapsto Tx $$<br>都是连续的。特别的 $\pi_1$ 是一一到上的，由推论1知，$\pi_1^{-1} \colon X \to \mathscr{G}(T)$ 连续，此时<br>$$ Tx = \pi_2(x,Tx) = \pi_2 \circ \pi_1^{-1} x,\forall x \in X $$<br>从而$T=\pi_2 \circ \pi_1^{-1}$</li>
</ol>
<pre><code>我发现我喜欢在此记录我学习的东西，反正这里也很少会有人来看，写出来很大的目的是让我自己走一遍过程，写总比看来的深刻。
</code></pre><p>欢迎访问0.0 <a href="http://dna049.com">http://dna049.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在泛函分析中几个基本重要的定理：一致有界原理，开映射定理，闭图像定理等都可以相应的推广到拓扑线性空间中。以下内容来自刘培德《拓扑线性空间与算子谱理论》第二章。<br>]]>
    
    </summary>
    
      <category term="泛函分析" scheme="http://dna049.com/tags/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
