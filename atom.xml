<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[0.肆玖]]></title>
  <subtitle><![CDATA[原谅我一生放荡不羁是傻逼]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://dna049.com/"/>
  <updated>2016-03-23T15:32:09.000Z</updated>
  <id>http://dna049.com/</id>
  
  <author>
    <name><![CDATA[dna049]]></name>
    <email><![CDATA[dna049@foxmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Cartan-Brauer-Hua Theorem]]></title>
    <link href="http://dna049.com/2016/03/23/Cartan-Brauer-Hua-Theorem/"/>
    <id>http://dna049.com/2016/03/23/Cartan-Brauer-Hua-Theorem/</id>
    <published>2016-03-23T15:22:24.000Z</published>
    <updated>2016-03-23T15:32:09.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Cartan-Brauer-Hua</strong> For a proper subset divison ring K of division ring L, if the unit group of K is a normal subgroup of the unit group of L, K is central.<br><a id="more"></a></p>
<p>I will show two similar proof of the Cartan–Brauer–Hua theorem. </p>
<h3 id="First_Proof"><a href="#First_Proof" class="headerlink" title="First Proof"></a>First Proof</h3><p><strong>Definition</strong><br>$ L^*  \equiv L \setminus \lbrace 0 \rbrace $, $[x,y] \equiv xyx^{-1}y^{-1}$ and $c_x(y) \equiv xyx^{-1}$ </p>
<p>Given $g\in K^*$ and $a \in L \setminus K$<br>To prove: $[g,a]=1$</p>
<ol>
<li>It is trival that $[g,a] \;,\; [g,a+1]$ make sense and $$[g,a] = g (ag^{-1}a^{-1}) \in K$$ so is $[g,a+1]$.</li>
<li>we have $$ c_g(a+1) = g(a+1)g^{-1} = c_g(a)+1 $$ hence $$ [g,a+1](a+1) = [g,a]a+1$$ or equivalently $$ [g,a+1]-[g,a])a=(1-[g,a+1])$$</li>
<li>The assumption $[g,a+1] \neq [g,a]$ would lead to a contradiction that $a\in K$.hence<br>$$[g,a+1] \neq [g,a] \Leftrightarrow (a+1)g = aga^{-1}(a+1) \Leftrightarrow ga = ag $$<br>end of our proof of $[g,a]=1$.</li>
</ol>
<p>Let $g,h \in K^*$,take any $a in L \setminus K$.then $h+a \in L \setminus K $. We have $[g,a+h]=[g,a]=1$ hence $gh = hg$,thus every element of $K$ commutes with $L$.</p>
<h3 id="Second_Proof_by_Hua_Luogeng"><a href="#Second_Proof_by_Hua_Luogeng" class="headerlink" title="Second Proof by Hua Luogeng"></a>Second Proof by <a href="https://en.wiki2.org/wiki/Hua_Luogeng" target="_blank" rel="external">Hua Luogeng</a></h3><p><img src="hua.png" alt="Proof"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Cartan-Brauer-Hua</strong> For a proper subset divison ring K of division ring L, if the unit group of K is a normal subgroup of the unit group of L, K is central.<br>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华罗庚恒等式]]></title>
    <link href="http://dna049.com/2016/03/22/%E5%8D%8E%E7%BD%97%E5%BA%9A%E6%81%92%E7%AD%89%E5%BC%8F/"/>
    <id>http://dna049.com/2016/03/22/华罗庚恒等式/</id>
    <published>2016-03-22T04:06:31.000Z</published>
    <updated>2016-03-23T15:35:12.000Z</updated>
    <content type="html"><![CDATA[<p>华罗庚恒等式有两个，都看似奇怪但都有其深刻的应用(数学内部的)</p>
<ol>
<li>若在一个环中 $a,b,1-ab$ 都可逆，则<br>$$<br>\left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a<br>$$</li>
<li>若在一个环中<br>$$<br>a = \left( b^{-1} - (a-1)^{-1}b^{-1}(a-1) \right) \left (a^{-1} b^{-1}a-(a-1)^{-1}b^{-1}(a-1) \right)^{-1}<br>$$<br>上面两个恒等式直接验算即知，可是 <a href="https://en.wiki2.org/wiki/Hua_Luogeng" target="_blank" rel="external">华老</a> 当初怎么想到这两个很奇怪的恒等式呢，怎么导入的，有什么应用呢？<a id="more"></a>
</li>
</ol>
<p>当然以下也只是我的个人猜测加上 <a href="https://en.wiki2.org/wiki/Hua%27s_identity" target="_blank" rel="external">Wikipedia</a> 的一些参考。</p>
<h3 id="u5728_u73AF_u4E2D_1-ba__u53EF_u9006_uFF0C_u5F53_u4E14_u4EC5_u5F53_1-ab__u53EF_u9006"><a href="#u5728_u73AF_u4E2D_1-ba__u53EF_u9006_uFF0C_u5F53_u4E14_u4EC5_u5F53_1-ab__u53EF_u9006" class="headerlink" title="在环中 1-ba 可逆，当且仅当 1-ab 可逆"></a>在环中 1-ba 可逆，当且仅当 1-ab 可逆</h3><p>$$ (1-ba)^{-1} = 1+ b(1-ab)^{-1}a \label{3}$$</p>
<p>上面恒等式直接证明是显然的，应用却666，6到要吐。<br>问题在于为什么想到这样奇怪的式子呢？思路怎么来的呢？<br>我们知道，当 $0&lt;x&lt;1$ 时，<br>$$ \frac{1}{1-x} = \sum_{n=0}^{\infty} {x^n} $$</p>
<p>因此，形式上我们有<br>$$ (1-ba)^{-1} = \sum_{n=0}^{\infty} {(ba)^n} = 1+ b \sum_{n=0}^{\infty}{(ab)^n} a = 1+ b(1-ab)^{-1}a $$<br>但是这只是给我们的理解提供了思路，证明还是需要按照定义来，即计算<br>$$ (1-ba)(1+ b(1-ab)^{-1}a) = 1 = (1+ b(1-ab)^{-1}a)(1-ba) $$</p>
<p>讲上述不等式应用到矩阵形式即可得到 <a href="https://en.m.wikipedia.org/wiki/Sherman–Morrison_formula" target="_blank" rel="external">Sherman–Morrison恒等式</a></p>
<h3 id="u5728_u73AF_u4E2D_uFF0C_u82E5__24a_2Cb_2Cab-1_24__u53EF_u9006_uFF0C_u5219"><a href="#u5728_u73AF_u4E2D_uFF0C_u82E5__24a_2Cb_2Cab-1_24__u53EF_u9006_uFF0C_u5219" class="headerlink" title="在环中，若 $a,b,ab-1$ 可逆，则"></a>在环中，若 $a,b,ab-1$ 可逆，则</h3><p>由上面恒等式我们知道<br>$$(ab-1)^{-1} = a(ba-1)^{-1}b - 1$$<br>因此<br>$$ \begin{aligned} (a-b^{-1})^{-1} &amp;=<br>\left((ab-1)b^{-1} \right)^{-1} \\<br>&amp;= b\left( a(ba-1)^{-1}b - 1 \right) \\<br>&amp;= ba(ba-1)^{-1}b - b  \\<br>&amp;= (ba-1)^{-1}b<br>\end{aligned}<br>$$<br>注意到<br>$$<br>\begin{align}  (ba-1)^{-1}b - a^{-1} &amp;= (ba-1)^{-1}baa^{-1} - a^{-1} \\<br>&amp;= (ba-1)^{-1}a^{-1} \\<br>&amp;= (aba-a)^{-1}<br>\end{align}<br>$$<br>因此 华罗庚等式 $ \left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a$ 得证。</p>
<h3 id="u4E00_u4E2A_u91CD_u8981_u6052_u7B49_u5F0F"><a href="#u4E00_u4E2A_u91CD_u8981_u6052_u7B49_u5F0F" class="headerlink" title="一个重要恒等式"></a>一个重要恒等式</h3><p>$$ b^{-1} - a^{-1} = ( b+b(a-b)^{-1}b )^{-1} $$</p>
<p>上面恒等式与逆算子连续性有关系。<br>证明：<br>$$<br>\begin{align}  (b^{-1} - a^{-1})^{-1} &amp;= (1-ba^{-1})^{-1}b \\<br>&amp;=(1+b(1-a^{-1}b)^{-1}a^{-1})b \\<br>&amp;= b+b(a-b)^{-1}b<br>\end{align}<br>$$</p>
<h3 id="u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u8BC1_u660E"><a href="#u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u8BC1_u660E" class="headerlink" title="华罗庚恒等式证明"></a>华罗庚恒等式证明</h3><p>$$<br>\begin{align}<br>a \left( a^{-1}b^{-1}a - (a-1)^{-1} b^{-1}(a-1) \right) &amp;=<br>(b^{-1}a- a(a-1)^{-1} b^{-1} (a-1) \\<br>&amp;= ( 1-a(a-1)^{-1} )b^{-1}a + (a-1+1) (a-1)b^{-1} )^{-1} \\<br>&amp;= -(a-1)^{-1}b^{-1}a + b^{-1} + (a-1)b^{-1} \\<br>&amp;= b^{-1} - (a-1)^{-1} b^{-1}(a-1)<br>\end{align}<br>$$</p>
<h3 id="u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u7684_u610F_u4E49"><a href="#u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u7684_u610F_u4E49" class="headerlink" title="华罗庚恒等式的意义"></a>华罗庚恒等式的意义</h3><ol>
<li>华罗庚第一个恒等式可以用来证明一个 Hua’s Theorem：除环间中保持加法和幺元以及逆元的映射必然是除环间的同态或者反同态。</li>
<li>华罗庚第一个恒等式可以证明 Cartan-Brauer-Hua Theorem 即一个除环的真子除环的单位群如果是原除环的单位群的正规子群，则该子除环一定包含于除环的中心。（会在<a href="http://dna049.com/2016/03/23/Cartan-Brauer-Hua-Theorem/">下一篇博文</a>中介绍）</li>
</ol>
<p>最后用一句广为流传的话结尾</p>
<blockquote>
<p>   龙生龙，凤生凤，华罗庚的学生会打洞（矩阵打洞）</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>华罗庚恒等式有两个，都看似奇怪但都有其深刻的应用(数学内部的)</p>
<ol>
<li>若在一个环中 $a,b,1-ab$ 都可逆，则<br>$$<br>\left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a<br>$$</li>
<li>若在一个环中<br>$$<br>a = \left( b^{-1} - (a-1)^{-1}b^{-1}(a-1) \right) \left (a^{-1} b^{-1}a-(a-1)^{-1}b^{-1}(a-1) \right)^{-1}<br>$$<br>上面两个恒等式直接验算即知，可是 <a href="https://en.wiki2.org/wiki/Hua_Luogeng">华老</a> 当初怎么想到这两个很奇怪的恒等式呢，怎么导入的，有什么应用呢？]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自然数的Peano公理]]></title>
    <link href="http://dna049.com/2016/03/19/%E8%87%AA%E7%84%B6%E6%95%B0%E7%9A%84Peano%E5%85%AC%E7%90%86/"/>
    <id>http://dna049.com/2016/03/19/自然数的Peano公理/</id>
    <published>2016-03-19T10:58:25.000Z</published>
    <updated>2016-03-20T00:16:58.000Z</updated>
    <content type="html"><![CDATA[<p>虽然我们从小学就开始学习自然数，但是自然数的真正严格的定义归功于1889年<a href="https://en.wikipedia.org/wiki/Giuseppe_Peano" target="_blank" rel="external">Giuseppe Peano</a> 的工作。介绍如下:<br><a id="more"></a></p>
<h3 id="u81EA_u7136_u6570_u7684_u5B9A_u4E49"><a href="#u81EA_u7136_u6570_u7684_u5B9A_u4E49" class="headerlink" title="自然数的定义"></a>自然数的定义</h3><p>我们把满足如下公理的集合叫做自然数 $\mathbb{N}$。<br>$\mathbb{N}$ 中包含一个特殊元素记作 $0$, 以及一个 $\mathbb{N}$ 到自身的映射 $a \mapsto a^+$，称为后继映射。<br>满足如下 Peano 公理:</p>
<ol>
<li>$0 \notin a^+$ 对任意 $a \in \mathbb{N}$ ；</li>
<li>$a \mapsto a^+$ 是单射；</li>
<li>若 $\mathbb{N}$ 的一个子集 $A$ 包含 $0$ 以及它的任何后继元素，则 $A=\mathbb{N}$。</li>
</ol>
<p>上面的公理3是我们常用数学归纳法的依据。下面介绍一个特别重要的定理。</p>
<p><strong>归纳定理</strong>: 设 $S$ 是一个集合，$\phi$ 是 $S$ 到自身的映射， $a\in S$。则存在唯一的映射 $f \colon \mathbb{N} \to S$ 使得<br>$$ f(0) = a, \qquad f(n^+) = \phi(f(n)), n \in \mathbb{N} $$ </p>
<p><strong>证明</strong>: 设<br>$$ \Lambda ＝ \lbrace U \subset \mathbb{N} \times S \colon (0,a)\in U\; | \; \mbox{ if } (n,b) \in U, \mbox{ then } (n^+,\phi(b)) \in U \rbrace$$<br>显然 $\mathbb{N} \times S \in \Lambda$ ，因此 $\Lambda \neq 0$ ,设 $f ＝ \cap_{U \in T} U$ ，下面证明 $f$ 即为所求。<br>由归纳 $\forall a \in \mathbb{N}, \exists b \in S$ 使得 $(n,b) \in f$ ，因此我们只需证明，若$(n,b),(n,b’) \in f$ 则 $b = b’$。令 $T=\lbrace n \in \mathbb{N} \;|\; (n,b),(n,b’) \in f \Rightarrow b=b’ \rbrace$,我们只需证明 $T = \mathbb{N}$。<br>首先 $0 \in T$ ，否则 $\exists a \neq a’$ 使得 $(0,a), (0,a’) \in f$ 。设 $f’$ 为 $f \setminus \lbrace (0,b’) \rbrace$ 易知 $f’ \in \Lambda$ 矛盾于 $f$ 的定义。<br>类似的 若$r \in T$，可证 $r^+ \in T$ 否则 $\exists c \neq \phi(r) $ 使得 $(r^+,c) \in T$ 设 $f’ = f \setminus \lbrace (r^+,c) \rbrace$ 则 $f’ \in \Lambda$ 矛盾于 $f$ 的定义。<br>假设 $g$ 也满足上述条件，则 $g \in \Lambda$ 因此 $f \subset g$ 但是对于两个映射 $f \subset g$ 可知 $f = g$ 证毕。<br>注: 以上的函数用”图像“的方式给出。</p>
<p>有了上面的 <strong>归纳定理</strong> 我们就可以定义自然数的加法和乘法了，注意定义永远是数学最重要的东西。</p>
<h3 id="u52A0_u6CD5_u4E58_u6CD5_u7684_u5B9A_u4E49"><a href="#u52A0_u6CD5_u4E58_u6CD5_u7684_u5B9A_u4E49" class="headerlink" title="加法乘法的定义"></a>加法乘法的定义</h3><p>两个自然数 $m,n$ 的加法被定义为 令 $a=m$ 和 $\phi \colon n \mapsto n^+$ ,则存在唯一的 $f_m$ 使得<br>$$ 0 + m = m \qquad  n^+ + m = (n+m)^+  $$<br>对于乘法，令 $a=0$ 和 $\phi \colon n \mapsto n＋m$ ,则存在唯一的 $g_m$ 使得<br>$$ 0m = 0 \qquad  n^+ m = nm + m $$</p>
<p>可以证明(其实蛮繁琐的)这样定义的加法满足我们平常所使用的各种法则，例如结合律，交换律等等性质。</p>
<p>下面看一下加法结合率的证明（书上并没有，自己补的）</p>
<ol>
<li>由加法定义可知 $(0+y)+z = y+z = 0+(y+z)$</li>
<li>若问题对 $x$ 成立则，$(x^+ +y)+z = (x+y+z)^+ = x^+ +(y+z)$<br>因此由公理3知 上式对任意的$x \in \mathbb{N}$ 成立，证毕。</li>
</ol>
<h3 id="u81EA_u7136_u6570_u7684_u5E8F_u5173_u7CFB"><a href="#u81EA_u7136_u6570_u7684_u5E8F_u5173_u7CFB" class="headerlink" title="自然数的序关系"></a>自然数的序关系</h3><p>称 $a \geq b$ 若存在 $x \in \mathbb{N}$ 使得 $a = b+x$。<br>显然有以下简单性质</p>
<ol>
<li>$x \geq  y$ 且 $y \geq x$ 则 $x = y$</li>
<li>$x \geq  y$ 且 $y \geq z$ 则 $x \geq z$</li>
<li>$\forall (x,y) \in \mathbb{N} \times \mathbb{N}$ $x \geq y$ 和 $y \geq x$ 至少有一个成立。<br>因此上述定义，定义了一个自然数集上的良序关系。另外自然数关于这种序关系有一个广为人知的结论。</li>
</ol>
<h3 id="u6700_u5C0F_u5143_u6027_u8D28"><a href="#u6700_u5C0F_u5143_u6027_u8D28" class="headerlink" title="最小元性质"></a>最小元性质</h3><p>$\mathbb{N}$ 的任何非空子集 $S$ 存在最小值。即 $\exists l \in S$ 使得 $\forall s\in S, s \geq l$。<br><strong>证明</strong>：设 $M = \lbrace m in \mathbb{N} \;|\; \forall s \in S, s \geq m \rbrace$ 。则 $0 \in M$ 且若 $s_0 \in S$ 则 $s_0^+ \notin M$。因此 $M \neq \mathbb{N}$. 因此由归纳法，存在 $s \in M, s^+ \notin M$ 上述 $s$ 即为所求。</p>
<p>按照公理化定义的自然数的性质验算其实还是很有意思的，虽然验算了也并没有什么屌用。另外知道了自然数的公理化体系也并没有什么屌用0.0<br>另外也有人将自然数写成<br>$$ 0 \equiv \emptyset, 1 equiv \lbrace \lbrace \emptyset \rbrace \emptyset \rbrace,\cdots n^+ \equiv  \lbrace \lbrace \emptyset \rbrace \emptyset \rbrace $$</p>
<p>以上内容来自 Nathan Jacobson 《Basic Algebra》。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然我们从小学就开始学习自然数，但是自然数的真正严格的定义归功于1889年<a href="https://en.wikipedia.org/wiki/Giuseppe_Peano">Giuseppe Peano</a> 的工作。介绍如下:<br>]]>
    
    </summary>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[A note about equal-distance point set]]></title>
    <link href="http://dna049.com/2016/03/15/A-note-about-equal-distance-point-set/"/>
    <id>http://dna049.com/2016/03/15/A-note-about-equal-distance-point-set/</id>
    <published>2016-03-14T16:00:28.000Z</published>
    <updated>2016-03-15T04:11:03.000Z</updated>
    <content type="html"><![CDATA[<p>It is evident true that there are at most 4 points are equal-distance in three dimention Euclidean Space.<br>What about other metric space? This ideal was first generated by my student Yilin Liu, and some results were obtained by us together.</p>
<a id="more"></a>
<ol>
<li>In a discrete metric, $X$ is any non-empty set.<br> $$ \rho(x,y) = \left \lbrace \begin{array}{ll} 1 &amp; x \neq y \\ 0 &amp; x=y  \end{array} \right. $$<br>In this metric space,any subset of $X$ is equal-distance.</li>
<li>Suppose that $X$ if we define<br> $$ \rho(A,B) = |x_1 - x_2| + |y_1 - y_2| + |z_1 - z_2| $$,<br>where $A(x_1,y_1,z_1),B(x_2,y_2,z_2)$.<br>we can find six points satisfy every two of them have some distance,for instance,$(\pm 1,0,0)\;(0,\pm 1,0)\;(0,0,\pm 1)$.</li>
<li>Suppose that $X$ if we define<br> $$ \rho(A,B) = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2 }+ |z_1 - z_2| $$,<br>where $A(x_1,y_1,z_1),B(x_2,y_2,z_2)$.<br>It is hard to find more that 4 point which could feed our demand. Fortunately with a skill construction,we finally get five equal-distance point set as follow<br>$$ (1,0,1); \;(-1,0,-1); \;(-\sqrt{2},0,4-\sqrt{2}); \;(-\frac{3\sqrt{2}}{2},2,\frac{\sqrt{2}}{2}); \;(-\frac{3\sqrt{2}}{2},-2,\frac{\sqrt{2}}{2}) $$ </li>
</ol>
<pre><code>What more, it remains to be considered in n-dimention space,or any metric and topology space.
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>It is evident true that there are at most 4 points are equal-distance in three dimention Euclidean Space.<br>What about other metric space? This ideal was first generated by my student Yilin Liu, and some results were obtained by us together.</p>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Several trick elementary conclusions]]></title>
    <link href="http://dna049.com/2016/03/14/Several-trick-elementary-conclusions/"/>
    <id>http://dna049.com/2016/03/14/Several-trick-elementary-conclusions/</id>
    <published>2016-03-14T15:12:35.000Z</published>
    <updated>2016-03-23T14:34:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible"><a href="#In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible" class="headerlink" title="In a Monoid, if an element is left and right invertible, then it is invertible."></a>In a Monoid, if an element is left and right invertible, then it is invertible.</h3><p>Proof: By hypothesis we have<br>$$ a b = ca = 1 $$<br>hence we have<br>$$ b = cab = c$$<br>therefore $a$ is invertible.</p>
<a id="more"></a>
<p><em>Definition</em>: In a semi-group $A$, $z$ is called left(right) quasi-regular if there exists an element $z’$ such that $z’o z \equiv z’+z-z’z = 0\;(z o z’=0 )$.</p>
<p>If A is a Monoid, actually, $z$ is called left(right) quasi-regular if and only if $1-z$ is left invertible.</p>
<h3 id="In_a_semi-group_2C_if__24z_u2019oz__3D_0_24_and__24z_u2019_u2019oz_u2019__3D_0_24_then__24z_u2019_u2019_3Dz_24_2C_thus_both__24z_24_and__24z_u2019_24_are_quasi-regular"><a href="#In_a_semi-group_2C_if__24z_u2019oz__3D_0_24_and__24z_u2019_u2019oz_u2019__3D_0_24_then__24z_u2019_u2019_3Dz_24_2C_thus_both__24z_24_and__24z_u2019_24_are_quasi-regular" class="headerlink" title="In a semi-group, if $z’oz = 0$ and $z’’oz’ = 0$ then $z’’=z$, thus both $z$ and $z’$ are quasi-regular."></a>In a semi-group, if $z’oz = 0$ and $z’’oz’ = 0$ then $z’’=z$, thus both $z$ and $z’$ are quasi-regular.</h3><p>Proof: It is obvious right in a Monoid. Some trick occur while proving it.<br>$$ z’’ = z’’z’-z’ = z’’(z’z-z)-z’ = (z’’z’-z’’)z-z’=z’z-z = z $$<br>end the proof.</p>
<h3 id="In_a_Ring_2C_241-az_24_is_invertible_if_and_only_if__241-za_24_is_invertible"><a href="#In_a_Ring_2C_241-az_24_is_invertible_if_and_only_if__241-za_24_is_invertible" class="headerlink" title="In a Ring,$1-az$ is invertible if and only if $1-za$ is invertible."></a>In a Ring,$1-az$ is invertible if and only if $1-za$ is invertible.</h3><p>Proof: In fact, we have<br>$$ (1-az)^{-1} = 1+a(1-za)^{-1}z$$</p>
<h3 id="In_a_Ring__24M_24_2C__24z__5Cin_M_24-_If__24_5Cforall_a__5Cin_M_2C_5C_3B_1-az_24_is_left_invertible_2C_then__241-az_24_is_invertible_2Cso_is__241-za_24_why_foregoing_conclusion"><a href="#In_a_Ring__24M_24_2C__24z__5Cin_M_24-_If__24_5Cforall_a__5Cin_M_2C_5C_3B_1-az_24_is_left_invertible_2C_then__241-az_24_is_invertible_2Cso_is__241-za_24_why_foregoing_conclusion" class="headerlink" title="In a Ring $M$, $z \in M$. If $\forall a \in M,\; 1-az$ is left invertible, then $1-az$ is invertible,so is $1-za$ why foregoing conclusion."></a>In a Ring $M$, $z \in M$. If $\forall a \in M,\; 1-az$ is left invertible, then $1-az$ is invertible,so is $1-za$ why foregoing conclusion.</h3><p>Proof: $\forall a \in M$,$1-az$ is left invertible.thus there exists $1-y$ such that<br>$$ (1-y)(1-az) = 1 $$<br>hence $y = (ya-a)z$ is left invertible.<br>Hence by forgoing conclusion $1-az$ is invertible,and so is $1-za$.</p>
<p>Note that:</p>
<pre><code>A semi-group is a set which is closed under an associative multiplication.
A Monoid is a semi-group contain an identity element.
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible"><a href="#In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible" class="headerlink" title="In a Monoid, if an element is left and right invertible, then it is invertible."></a>In a Monoid, if an element is left and right invertible, then it is invertible.</h3><p>Proof: By hypothesis we have<br>$$ a b = ca = 1 $$<br>hence we have<br>$$ b = cab = c$$<br>therefore $a$ is invertible.</p>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gcd经典推导 hdu 5382]]></title>
    <link href="http://dna049.com/2016/03/13/gcd%E7%BB%8F%E5%85%B8%E6%8E%A8%E5%AF%BChdu-5382/"/>
    <id>http://dna049.com/2016/03/13/gcd经典推导hdu-5382/</id>
    <published>2016-03-12T16:20:40.000Z</published>
    <updated>2016-03-13T04:41:37.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/blog/2015-multi-university-training-contest-8-solutions-by-绍兴一中/" target="_blank" rel="external">多校训练</a> 中有一道数论题，推导十分强大，特此记录。<br><a id="more"></a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5382" target="_blank" rel="external">题目链接</a> 和推导过程:<br><img src="proof.png" alt="proof"><br>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">258280327</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],g[N],t[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">        g[i]=<span class="number">1</span>;t[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[i] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j+=i)&#123;</span><br><span class="line">                g[j]&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j+=i)&#123;</span><br><span class="line">            t[j]=(t[j]+g[i-<span class="number">1</span>])%M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        a[i]=(a[i-<span class="number">1</span>]+<span class="number">2</span>*i-<span class="number">1</span>-t[i-<span class="number">1</span>])%M;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;<span class="number">0</span>)  a[i]+=M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        a[i]=(a[i]+a[i-<span class="number">1</span>])%M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span></span><br><span class="line">    <span class="comment">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/blog/2015-multi-university-training-contest-8-solutions-by-绍兴一中/">多校训练</a> 中有一道数论题，推导十分强大，特此记录。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[矩阵快速幂的应用 hdu5451]]></title>
    <link href="http://dna049.com/2016/03/12/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84%E5%BA%94%E7%94%A8-hdu5451/"/>
    <id>http://dna049.com/2016/03/12/矩阵快速幂的应用-hdu5451/</id>
    <published>2016-03-12T07:41:44.000Z</published>
    <updated>2016-03-13T04:37:48.000Z</updated>
    <content type="html"><![CDATA[<p>上次已经写过了矩阵快速幂，这次再写的原因是因为此题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5451" target="_blank" rel="external">hdu5451</a>用了很多的黑科技，因此还是值得记录的。<br><a id="more"></a></p>
<p>问题简述如下:<br>$$ y = (5+ 2\sqrt{6})^{1+2^x}$$<br>where $0 \leq x &lt; 2^{32} $ and a prime number $p(p&lt;46337)$,calculate $r = floor(y) \;mod\; p$. </p>
<p>实际上我们需要计算的是<br>$$ r = (5+ 2\sqrt{6})^{1+2^x} + (5 - 2\sqrt{6})^{1+2^x} -1 $$<br>设 $a_n = (5+ 2\sqrt{6})^{1+2^x} + (5 - 2\sqrt{6})^{1+2^x} $ 则我们有<br>$$ a_0=2,a_1=10,a_n = a_{n-1} +a_{n-2}$$<br>最终答案即为<br>$$ (a_{1+2^n} - 1) \;mod\; M $$<br>另一方面，由递推关系式子，我们知道<br>$$ \left( \begin{matrix} a_{n} \\ a_{n-1} \end{matrix} \right) = A \left( \begin{matrix} a_{n-1} \\ a_{n-2} \end{matrix} \right) = A^{n-1} \left( \begin{matrix} a_1 \\ a_0 \end{matrix} \right) $$<br>因此<br>$$ \left( \begin{matrix} r \\ * \end{matrix} \right) = A^{2^x} \left( \begin{matrix} 10 \\ 2 \end{matrix} \right) $$<br>由于我们需要的是最终结果模 $p$.<br>而 $GL(n,p)$可看成 $n$ 阶方针到自身的可逆变换全体。推理易知道<br>$$ |GL(n,p)| =  \prod_{i=0}^{n-1} (p^n-p^i) $$<br>对于此题中 $ mp = |GL(2,p)| = (p^2-1)(p^2-p) $，由群的Lagrange定理知 $A^{|GL(2,p)|}=I_2$。因此我们只需计算 $A^{2^x} \;mod\; mp$ 用快速幂解决即可，但是这里有一个问题就是 mp 有可能很大，导致快速幂乘法的时候会溢出，于是乘法用快速加法来实现，具体见代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line">LL mod;</span><br><span class="line"><span class="keyword">class</span> Matrix&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">2</span>; <span class="comment">//col</span></span><br><span class="line">    LL a[N][N];</span><br><span class="line">    Matrix(<span class="keyword">int</span> a00=<span class="number">0</span>,<span class="keyword">int</span> a01=<span class="number">0</span>, <span class="keyword">int</span> a10=<span class="number">0</span>,<span class="keyword">int</span> a11=<span class="number">0</span>)&#123;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>]=a00;a[<span class="number">0</span>][<span class="number">1</span>]=a01;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">0</span>]=a10;a[<span class="number">1</span>][<span class="number">1</span>]=a11;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                R.a[i][j]=a[i][j]+A.a[i][j];</span><br><span class="line">                <span class="keyword">if</span>(R.a[i][j]&gt;=mod)   R.a[i][j]-=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                    R.a[i][j] = (R.a[i][j]+a[i][k]*A.a[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix A,LL n)</span></span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">R</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) R=R*A;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r+=x;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=p)    r-=p;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=p)    x-=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,<span class="keyword">unsigned</span> <span class="keyword">int</span> n,LL p)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=mul(r,x,p);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=mul(x,x,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=T;++t)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;mod;</span><br><span class="line">        LL p = mod;</span><br><span class="line">        p = (p*p-<span class="number">1</span>)*(p*p-p);</span><br><span class="line">        <span class="function">Matrix <span class="title">A</span><span class="params">(<span class="number">10</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        Matrix R = <span class="built_in">pow</span>(A,pow_mod(<span class="number">2</span>,x,p));</span><br><span class="line">        LL r = (R.a[<span class="number">0</span>][<span class="number">0</span>]*<span class="number">10</span>+R.a[<span class="number">0</span>][<span class="number">1</span>]*<span class="number">2</span>-<span class="number">1</span>)%mod;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>) r+=mod;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>上次已经写过了矩阵快速幂，这次再写的原因是因为此题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5451">hdu5451</a>用了很多的黑科技，因此还是值得记录的。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="矩阵" scheme="http://dna049.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Fermat平方和定理]]></title>
    <link href="http://dna049.com/2016/03/08/Fermat%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86/"/>
    <id>http://dna049.com/2016/03/08/Fermat平方和定理/</id>
    <published>2016-03-08T11:04:45.000Z</published>
    <updated>2016-03-14T16:32:13.000Z</updated>
    <content type="html"><![CDATA[<p>Fermat平方和定理的表述为：奇质数能表示为两个平方数之和的充分必要条件是该质数被4除余1。这个结论首次由 Euler 在 1747年给出证明。详细叙述如下：</p>
<a id="more"></a>
<p>为方便起见,记<br>$$ A = \lbrace a^2 + b^2 \;|\; a,b \in \mathbb{Z} \rbrace $$</p>
<p>证明分五步完成</p>
<ol>
<li>$(a^2+b^2)(c^2+d^2)=(ac \pm bd)^2 +(ad \mp bc)^2 $<br>proof: 计算即知。</li>
<li>若 $a^2+b^2 \;|\; c^2+d^2$, $a^2+b^2$ 为素数，则<br> $$ \frac{c^2+d^2}{a^2+b^2} \in A$$<br>proof: 由于$(ac-bd)(ac+bd) = (a^2+b^2)c^2-(c^2+d^2)b^2$<br>因此 $(a^2+b^2) \;|\; (ac-bd)(ac+bd)$ 而$(c^2+d^2)$ 是素数，因此必然整除其中一个。<br>假设$(a^2+b^2)|(ac-bd)$,则由1知 $(a^2+b^2)｜(ad+bc)$ 因此<br>$$ \frac{c^2+d^2}{a^2+b^2}=(\frac{ac - bd}{a^2+b^2})^2 +(\frac{ad + bc}{a^2+b^2})^2 $$<br>类似的，假设$(a^2+b^2) \;|\; (ac＋bd)$ 则有<br>$$ \frac{c^2+d^2}{a^2+b^2}=(\frac{ac + bd}{a^2+b^2})^2 +(\frac{ad - bc}{a^2+b^2})^2 $$</li>
<li>$x \;|\; a^2+b^2,x \notin A$，则$\exists y| \frac{a^2+b^2}{x}$ 使得 $y \notin A$<br>反证：设 $ a^2+b^2 = x p_1 p_2 \cdots p_n$ 则，若 则$ \forall y| \frac{a^2+b^2}{x},y \in A$ 则由2，经过 $n$ 次除法，最终 $x \in A$ 矛盾。</li>
<li>若 $(a,b)=1$ 则 $\forall x| a^2+b^2 ,x \in A$<br>假设 $\exists x| a^2+b^2,x \notin A$ 则，我们设<br>$a = mx + c,b = mx + d$,其中$|c|&lt;x,|d| &lt;x$。则<br>$a^2+b^2=(mx+c)^2+(mx+d)^2=tx+(c^2+d^2)$，因此$x \;|\; c^2+d^2$。又 $(a,b)=1$ ，因此 $((c,d),x)=1$。因此不妨设 $(c,d)=1$ 则 $\exists z, zx = c^2+d^2 \leq \frac{x^2}{2}$。即 $z\leq \frac{x}{2}$。由引理3知道 $z$ 有一个因子 $w \notin A$。即我们由 $ x \;|\; a^2+b^2,x \notin A$ 得到了 $ w \;|\; c^2+d^2, w \notin A ,w \leq  \frac{x}{2} $ 这样一直下去必然会在有限步结束，矛盾。</li>
<li>若素数$p=4n+1$，则 $p\in A$。<br>由Fermat小定理知$1,2^{4n},\cdots,(4n)^{4n}$除以 $p$ 模1.<br>因此$2^{4n}－1,3^{4n}－2^{4n},\cdots,(4n)^{4n}-(4n-1)^{4n}$都是 $p$ 的倍数。这些差都有分解<br>$$a^{4n} - b^{4n} = (a^{2n}+b^{2n})(a^{2n}-b^{2n})$$<br>由于上述 $a,b$ 相差为1，必然互素，因此若 $p|a^{2n}+b^{2n}$ 则由4命题得证。否则$2^{2n}-1,3^{2n}-2^{2n},\cdots,(2n)^{2n}-(2n-1)^{2n}$都是 $p$ 的倍数。<br>因此1.对上面式子做$2n$阶差得到 $(2n)!$ 是p的倍数，显然是不可能的。<br>或者2.由于上面序列的前 $d$ 项和 $d^{2n}-1$是$p$的倍数，因此素数 $p$ 无原根，矛盾与原根存在定理。</li>
</ol>
<p>当然上述定理也可以利用<br>$$ \mathbb{Z}[i] \simeq \mathbb{Z}[x]/(x^2+1) $$ 转化到 $F_p$ 域上的不可约问题解决。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Fermat平方和定理的表述为：奇质数能表示为两个平方数之和的充分必要条件是该质数被4除余1。这个结论首次由 Euler 在 1747年给出证明。详细叙述如下：</p>]]>
    
    </summary>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[矩阵快速幂的应用 hdu 1588]]></title>
    <link href="http://dna049.com/2016/03/05/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84%E5%BA%94%E7%94%A8-hdu-1588/"/>
    <id>http://dna049.com/2016/03/05/矩阵快速幂的应用-hdu-1588/</id>
    <published>2016-03-05T14:12:33.000Z</published>
    <updated>2016-03-10T09:21:36.000Z</updated>
    <content type="html"><![CDATA[<p>在一个半群中，$a^n$ 的运算可以使用快速幂，即在不超过 $2log_2(n)$ 的运算下完成计算。<br><a id="more"></a></p>
<p>直接用一个实例 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1588" target="_blank" rel="external">hdu1588 Gauss Fibonacci</a> 即可体现其思想。</p>
<h3 id="u95EE_u9898"><a href="#u95EE_u9898" class="headerlink" title="问题"></a>问题</h3><p>设 f 是 Fibonacci 数列满足：</p>
<ol>
<li>$f(0)=0$</li>
<li>$f(1)=1$</li>
<li>$f(n)=f(n-1)+f(n-2) ,\; n \geq 2$</li>
</ol>
<p>求 Gauss Fibonacci 问题<br>$$ \sum_{i=0}^{n-1} f(k*i+b) $$</p>
<h3 id="u6C42_u89E3"><a href="#u6C42_u89E3" class="headerlink" title="求解"></a>求解</h3><p>令 $ A = \left[ \begin{matrix} 1 &amp; 1 \\ 1 &amp; 0 \end{matrix} \right] $ 则<br>$$ \left( \begin{matrix} f(n+1) \\ f(n) \end{matrix} \right) = A \left( \begin{matrix} f(n) \\ f(n-1) \end{matrix} \right) = A^n \left( \begin{matrix} 1 \\ 0 \end{matrix} \right) $$<br>于是求解 $f(n)$ 可转化为求解 $A^n$ 另外 Gauss Fibonacci 问题可转化为求解<br>$$ A^b \cdot \sum_{i=0}^{n-1} A^{ki} $$</p>
<h3 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//#pragma comment(linker,"/STACK:10240000,10240000")</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">typedef pair&lt;LL,LL&gt; PLL;</span><br><span class="line">#define clr(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define PB push_back</span><br><span class="line">#define lrt rt&lt;&lt;1</span><br><span class="line">#define rrt rt&lt;&lt;1|1</span><br><span class="line">#define lson l,m,lrt</span><br><span class="line">#define rson m+1,r,rrt</span><br><span class="line">/*------------------------- template ------------------------------*/</span><br><span class="line">LL mod;</span><br><span class="line">class Matrix&#123;</span><br><span class="line">public:</span><br><span class="line">    const static int N = 2; //col</span><br><span class="line">    LL a[N][N];</span><br><span class="line">    Matrix(int a00=0,int a01=0, int a10=0,int a11=0)&#123;</span><br><span class="line">        a[0][0]=a00;a[0][1]=a01;</span><br><span class="line">        a[1][0]=a10;a[1][1]=a11;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix operator+(const Matrix&amp; A)const&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">            for(int j=0;j&lt;N;++j)&#123;</span><br><span class="line">                R.a[i][j]=a[i][j]+A.a[i][j];</span><br><span class="line">                if(R.a[i][j]&gt;=mod)   R.a[i][j]-=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return R;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix operator*(const Matrix&amp; A)const&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">            for(int k=0;k&lt;N;++k)&#123;</span><br><span class="line">                for(int j=0;j&lt;N;++j)&#123;</span><br><span class="line">                    R.a[i][j] = (R.a[i][j]+a[i][k]*A.a[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix pow(Matrix A,int n)&#123;</span><br><span class="line">    Matrix R(1,0,0,1);</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) R=R*A;</span><br><span class="line">        n&gt;&gt;=1;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    return R;</span><br><span class="line">&#125;</span><br><span class="line">Matrix getsum(Matrix A,int n)&#123;</span><br><span class="line">    Matrix R(1,0,0,1),X(1,0,0,1);</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) R=(R+X*pow(A,n));</span><br><span class="line">        n&gt;&gt;=1;  X=X*(Matrix(1,0,0,1)+pow(A,n));</span><br><span class="line">    &#125;</span><br><span class="line">    return R;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span><br><span class="line">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span><br><span class="line">    int k,b,n,m;</span><br><span class="line">    while(~scanf("%d%d%d%d",&amp;k,&amp;b,&amp;n,&amp;m))&#123;</span><br><span class="line">        mod = m;</span><br><span class="line">        Matrix A(1,1,1,0);</span><br><span class="line">        Matrix R = pow(A,b)*getsum(pow(A,k),n-1);</span><br><span class="line">        cout&lt;&lt;R.a[1][0]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在一个半群中，$a^n$ 的运算可以使用快速幂，即在不超过 $2log_2(n)$ 的运算下完成计算。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="矩阵" scheme="http://dna049.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自然底数e的由来]]></title>
    <link href="http://dna049.com/2016/02/24/%E8%87%AA%E7%84%B6%E5%BA%95%E6%95%B0e%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <id>http://dna049.com/2016/02/24/自然底数e的由来/</id>
    <published>2016-02-24T15:26:27.000Z</published>
    <updated>2016-02-24T15:45:47.000Z</updated>
    <content type="html"><![CDATA[<p>自然底数 $e$ 之所以重要，我想很大程度上是因为，指数函数 $f(x)=e^x$ 是“唯一”(在常数倍意义下)满足导数等于本身的函数。因此 $e$ 被叫做自然底数。<br><a id="more"></a></p>
<p>然而，$e$ 的定义可以由一个常见的重要数列极限来定义。即<br>$$ e \equiv \lim _{n \to \infty}(1+\frac{1}{n})^n $$<br>那么为什么右边有极限呢，我们来仔细分析。<br>令<br>$$ a_n = (1+\frac{1}{n})^n ,\; b_n =(1+\frac{1}{n})^{n+1} $$<br>则,由<a href="http://dna049.com/2016/02/24/均值不等式/">均值不等式</a>易知<br>$$ a_n = (1+\frac{1}{n})^n \cdot 1 \leq [\frac{n(1+\frac{1}{n})+1}{n+1}]^{n+1} =a_{n+1} $$<br>且<br>$$ \frac{1}{b_n} = (\frac{n}{n+1})^n \cdot 1 \leq [\frac{(n+1)\frac{n}{n+1}+1}{n+2}]^{n+2} = \frac{1}{b_{n+1}} $$<br>因此 $2 = a_1 \leq a_n \leq b_n \leq b_1 = 4$。由于单调有界序列必有极限，不妨把这个极限记作 $e$ 且由上面推理知 $2 &lt; e &lt; 4$。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自然底数 $e$ 之所以重要，我想很大程度上是因为，指数函数 $f(x)=e^x$ 是“唯一”(在常数倍意义下)满足导数等于本身的函数。因此 $e$ 被叫做自然底数。<br>]]>
    
    </summary>
    
      <category term="数学分析" scheme="http://dna049.com/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[均值不等式]]></title>
    <link href="http://dna049.com/2016/02/24/%E5%9D%87%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    <id>http://dna049.com/2016/02/24/均值不等式/</id>
    <published>2016-02-24T15:06:23.000Z</published>
    <updated>2016-02-24T15:25:58.000Z</updated>
    <content type="html"><![CDATA[<p>初中就学过最简单的均值不等式 $\frac{a+b}{2} \geq \sqrt{ab},a ,b \geq 0$。它的证明只需配方就知道了，这里介绍一下一般的均值不等式:<br>$$ \frac{ \sum_{i=1} ^n a_i}{n} \geq \sqrt[n]{\Pi_{i=1}^n a_i }$$<br><a id="more"></a><br>当 $n=1$ 时结论是平凡的，$n=2$ 时配方即知。$n=2^k$时不难用数学归纳法知，结论成立，下面主要看 $2^{k-1} &lt;n&lt; 2^k$的情况<br>令 $A = \frac{ \sum_{i=1} ^n a_i}{n} $ 则，应用 $2^k$ 时的结论<br>$$ \frac{ \sum_{i=1} ^n a_i + (2^k-n)A }{2^k} \geq\sqrt[2^k]{\Pi_{i=1}^n a_i A^{2^k -n}} $$<br>化简可得到结论。</p>
<pre><code>上述证明简单优美，第一次在陈纪修《数学分析》(上)看到这个优美的方法。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>初中就学过最简单的均值不等式 $\frac{a+b}{2} \geq \sqrt{ab},a ,b \geq 0$。它的证明只需配方就知道了，这里介绍一下一般的均值不等式:<br>$$ \frac{ \sum_{i=1} ^n a_i}{n} \geq \sqrt[n]{\Pi_{i=1}^n a_i }$$<br>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最强装逼题目0.0]]></title>
    <link href="http://dna049.com/2016/02/24/%E6%9C%80%E5%BC%BA%E8%A3%85%E9%80%BC%E9%A2%98%E7%9B%AE0-0/"/>
    <id>http://dna049.com/2016/02/24/最强装逼题目0-0/</id>
    <published>2016-02-24T13:50:13.000Z</published>
    <updated>2016-02-24T15:05:51.000Z</updated>
    <content type="html"><![CDATA[<p>数学老师想好了两个自然数 $m,n$ 满足 $2 \leq m \leq n \leq 100$ ,他把 $m,n$ 的和 $s$ 告诉了 $S$ 同学，把 $m,n$ 的积 $p$ 告诉了 $P$ 同学，他们都是聪明诚实的学生。进行了下面对话<br>$S$: 我不知道 $m,n$ 的值，但我知道你也不知道。<br>$P$: 现在我知道了。<br>$S$: 现在我也知道了。<br>请问 $m,n$ 的值。<br><a id="more"></a></p>
<ol>
<li>由第一句话，我们知道 $s \geq 6$,且 $p$ 中无大于或者等于 53 的质因数。但是 $S$ 是如何知道的呢，可见 $s \leq 54$。对 数 $6 ~ 54$ 逐一检查发现，除了$A = \lbrace 11,17,23,27,29,35,37,41,47,51,53 \rbrace$的其他元素外，其余每个数都可以表示成两个素数的和，因此从第一句话知道，$ s \in A$。</li>
<li>刚刚推理 $P$ 同学当然也能完成。由于 $A$ 中的元素全是奇数，因此，若 $p = 2^k \cdot (2v+1), k \geq 0, v \geq 0$ 或者 $p = 2^k \cdot (2v+1)(2j+1), k \geq 0, v \geq 0, j \geq 0$ 则 $P$ 同学就能确定的知道答案。</li>
<li><p>$S$ 同学最后也知道了 $m,n$ 的值，说明在 $s$ 所有分解 $s = m+ n, 2 \leq m \leq n \leq 100$ 中，且有一种满足 $xy = 2^k v$。<br>检查 $11 = 4+7 = 3+8$, $23 = 4 + 19 = 7+16$, $27 = 4+23 = 8+19$, $35=4+31=16+19$, $37 = 8+29 = 5+32$, $47= 4 + 43 = 16+31$, $51 = 4+47 = 8+43$。<br>又因为<br>$$ 29 = 4 + 25 = 13 +16,\; 41 = 4+37 = 16 + 25,\; 53 = 16 +37 = 21 + 32 $$<br>其中 $4 \times 25 = 100 = 20 \times 5$, $20+5 =25 \notin A$, $16 \times 25 = 400 = 80 \times 5$, $80+5 =85 \notin A$, $21 \times 32 = 672 = 7 \times 96$ ,$ 7+96 =103 \notin A$。<br>因此，只可能 $s=17$<br>$$ 17 = 2+15 = 3+14 = 4+13 = 5+12 = 6+11 = 7 +10 = 8+9 $$<br>其中只有 $17 =4 + 13$ 满足 $P$ 的断言，因此 $m = 4,n=13$。</p>
<p> 此题是我高三（2011年）在《奥赛金牌之路》中所见，实在很吊，一直铭记于心,特此记录。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>数学老师想好了两个自然数 $m,n$ 满足 $2 \leq m \leq n \leq 100$ ,他把 $m,n$ 的和 $s$ 告诉了 $S$ 同学，把 $m,n$ 的积 $p$ 告诉了 $P$ 同学，他们都是聪明诚实的学生。进行了下面对话<br>$S$: 我不知道 $m,n$ 的值，但我知道你也不知道。<br>$P$: 现在我知道了。<br>$S$: 现在我也知道了。<br>请问 $m,n$ 的值。<br>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[My Math work edited by LaTex]]></title>
    <link href="http://dna049.com/2016/02/23/My-Math-work-edited-by-LaTex/"/>
    <id>http://dna049.com/2016/02/23/My-Math-work-edited-by-LaTex/</id>
    <published>2016-02-23T11:17:02.000Z</published>
    <updated>2016-02-23T11:17:02.000Z</updated>
    <content type="html"><![CDATA[<p>This blog makes a record of my math work and will be update frequently.Click to view or download it.</p>
<a id="more"></a>
<h4 id="Here_are_PDF_version_of_my_math_work"><a href="#Here_are_PDF_version_of_my_math_work" class="headerlink" title="Here are PDF version of my math work"></a>Here are PDF version of my math work</h4><p><a href="1.pdf">Config of ACM-ICPC</a></p>
<p><a href="2.pdf">Some results about matrix</a></p>
<p><a href="3.pdf">Decomposition of 1 by 1/n </a></p>
<p><a href="4.pdf">Nowhere dense set and frist category set</a></p>
<p><a href="5.pdf">Relationship between Spectral Radius ,Numerical Radius and Spectral norm</a></p>
<p><a href="6.pdf">Some results about group</a></p>
<p><a href="7.pdf">The inverse of I-ba and I-ab</a></p>
<p><a href="8.pdf">example of function that only derivable on one point</a></p>
<p><a href="0.pdf">undergraduate graduation paper</a></p>
<h4 id="Here_are_Tex_version_of_my_math_work"><a href="#Here_are_Tex_version_of_my_math_work" class="headerlink" title="Here are Tex version of my math work"></a>Here are Tex version of my math work</h4><p><a href="1.tex">Config of ACM-ICPC.tex</a></p>
<p><a href="2.tex">Some results about matrix.tex</a></p>
<p><a href="3.tex">Decomposition of 1 by 1/n.tex</a></p>
<p><a href="4.tex">Nowhere dense set and frist category set.tex</a></p>
<p><a href="5.tex">Relationship between Spectral Radius ,Numerical Radius and Spectral norm.tex</a></p>
<p><a href="6.tex">Some results about group.tex</a></p>
<p><a href="7.tex">The inverse of I-ba and I-ab.tex</a></p>
<p><a href="8.tex">example of function that only derivable on one point.tex</a></p>
<h3 id="LaTex_is_a_wonderful_tool_for_Mathematics"><a href="#LaTex_is_a_wonderful_tool_for_Mathematics" class="headerlink" title="LaTex is a wonderful tool for Mathematics"></a>LaTex is a wonderful tool for Mathematics</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>This blog makes a record of my math work and will be update frequently.Click to view or download it.</p>]]>
    
    </summary>
    
      <category term="Tex" scheme="http://dna049.com/tags/Tex/"/>
    
      <category term="数学" scheme="http://dna049.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[整数集上的一种奇特拓扑]]></title>
    <link href="http://dna049.com/2016/02/22/%E6%95%B4%E6%95%B0%E9%9B%86%E4%B8%8A%E7%9A%84%E4%B8%80%E7%A7%8D%E5%A5%87%E7%89%B9%E6%8B%93%E6%89%91/"/>
    <id>http://dna049.com/2016/02/22/整数集上的一种奇特拓扑/</id>
    <published>2016-02-22T13:41:23.000Z</published>
    <updated>2016-02-23T11:34:31.000Z</updated>
    <content type="html"><![CDATA[<p>在《Proofs from THE BOOK》里素数无限的六种证明的第五种讲到了一种用点集拓扑学知识证明的方法，其中引入了整数集上的一种奇特拓扑。<br><a id="more"></a></p>
<p>对 $a,b \in \mathbb{Z},b&gt;0$，令<br>$$ N_{a,b} = \lbrace a + nb \colon n \in \mathbb{Z} \rbrace $$<br>我们称集合 $O \subset \mathbb{Z}$ 是开集，若$O = \emptyset$，或者 $ \forall a \in O,\exists b&gt;0,st. N_{a,b} \subset O$,容易验证这样定义的开集族全体构成了 $\mathbb{Z}$ 上的拓扑。<br>并且每个$N_{a,b}$ 都是既开又闭的。这是由于<br>$$ N_{a,b} = \mathbb{Z} \setminus \cup_{i-1}^{b-1} N_{a+i,b}$$</p>
<p>又由<br>$$ \mathbb{Z} \setminus \lbrace -1,1 \rbrace = \cup_{p \in P} N_{0,p} $$<br>若素数只有有限个，则$P$是有限集，从而$\lbrace -1,1 \rbrace$是开集，矛盾。</p>
<p>上述方法脑洞大，形式简洁，不愧是 <a href="0.pdf">《Proofs from THE BOOK》</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在《Proofs from THE BOOK》里素数无限的六种证明的第五种讲到了一种用点集拓扑学知识证明的方法，其中引入了整数集上的一种奇特拓扑。<br>]]>
    
    </summary>
    
      <category term="拓扑" scheme="http://dna049.com/tags/%E6%8B%93%E6%89%91/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hahn-Banach 延拓定理]]></title>
    <link href="http://dna049.com/2016/02/19/Hahn-Banach-%E5%BB%B6%E6%8B%93%E5%AE%9A%E7%90%86/"/>
    <id>http://dna049.com/2016/02/19/Hahn-Banach-延拓定理/</id>
    <published>2016-02-19T00:26:38.000Z</published>
    <updated>2016-02-23T11:34:40.000Z</updated>
    <content type="html"><![CDATA[<p>Hahn-Banach 延拓定理通常分为分析和几何的形式，其中几何形式通常称为凸集分离性定理。<br><a id="more"></a></p>
<h3 id="Hahn-Banach__u5EF6_u62D3_u5B9A_u7406_u7684_u5206_u6790_u5F62_u5F0F"><a href="#Hahn-Banach__u5EF6_u62D3_u5B9A_u7406_u7684_u5206_u6790_u5F62_u5F0F" class="headerlink" title="Hahn-Banach 延拓定理的分析形式"></a>Hahn-Banach 延拓定理的分析形式</h3><p><strong>定义1</strong> 设 $X$ 是线性空间，$p \colon X \to \mathbb{R}$ 是一个泛函，若 $p$ 满足</p>
<ol>
<li>$p(x+y) \leq p(x)+p(y)$ 则称 $p$ 在 $X$ 上是次可加的，若</li>
<li>$p(tx)=tp(x),\; \forall x \in X,t \geq 0$ 则称 $p$ 在 $X$ 上是正齐次的，若 $p$ 满足1和</li>
<li>$p(ax)=|a|p(x),\; \forall x \in X, a \in \Phi $ 则称 $p$ 是 $X$ 上的半范数。</li>
</ol>
<p><strong>定理1</strong> (实情形) 设 $X$ 是实线性空间， $p \colon X \to \mathbb{R}$是正齐性次可加泛函，$Y$ 是 $X$ 的线性子空间。若 $f_0 \colon Y \to \mathbb{R}$ 是 $Y$ 上的线性泛函，满足<br>$$ f_0(x) \leq p(x),\; \forall x \in Y $$<br>则 $X$ 上存在线性泛函 $f \colon X \to \mathbb{R}$使得<br>$$ f|_Y = f_0 ,f(x) \leq p(x),\; \forall x \in X $$</p>
<p>证明: 设 $x_0 \in X \setminus Y$ 记 $ \widetilde{Y} = span\lbrace  x_0,Y\rbrace$,首先将 $Y$ 延拓到 $\widetilde{Y}$ 再利用Zorn引理延拓完成整个证明。<br>$$ f(x) + f(y) =f(x+y) \leq p(x+y) \leq p(x-x_0) + p(x_0+y),\; \forall x,y \in Y $$<br>因此<br>$$ f(x) - p(x-x_0) \leq p(x_0+y) - f(y) $$<br>我们记 $ \alpha \equiv \inf_{y \in Y} p(x_0+y) - f(y)$，则<br>$$ f(x) - \alpha \leq p(x - x_0) ,\; f(y) + \alpha \leq f(y+x_0) ,\; \forall x,y \in Y$$<br>在 $\widetilde{Y}$ 上定义 $ f(tx_0 +y) = t \alpha + f_0(y) $ 显然 $f$ 是 $\widetilde{Y}$ 上的线性泛函且是 $f_0$ 的延拓且满足 $f(x) \leq p(x)$。<br>根据延拓关系建立偏序关系，用Zorn引理即知定理1成立</p>
<p><strong>定理2</strong> (复情形) 设 $X$ 是复线性空间， $p \colon X \to \mathbb{R}$是 $X$ 上的半范数，$Y$ 是 $X$ 的线性子空间。若 $f_0 \colon Y \to \mathbb{C}$ 是 $Y$ 上的线性泛函，满足<br>$$ |f_0(x)| \leq p(x),\; \forall x \in Y $$<br>则 $X$ 上存在线性泛函 $f \colon X \to \mathbb{C}$使得<br>$$ f|_Y = f_0 ,|f(x)| \leq p(x),\; \forall x \in X $$</p>
<p>证明: 考虑实部应用定理1，可以证明定理2. 取 $u = \Re{f_0}$ 则，由定理1，$u$ 可以延拓到 $X$ 上得到实线性泛函 $U$ 使得 $U(x) \leq p(x) ,\; \forall x \in X$ 。定义 $f(x) = U(x) - iU(ix),\; \forall x \in X$ 任意验证 $f$ 即为所求。  </p>
<p><strong>推论1</strong> 设 $X$ 是赋范空间，$x_0 \in X$,则存在连续线性泛函 $f$ 满足 $f(x_0) = ||x_0|| ,||f|| = 1$.<br><strong>推论2</strong> 设 $Y$ 是赋范空间 $X$ 的真闭子空间， 则存在连续线性泛函 $f$ 满足</p>
<ol>
<li>$f(y) = 0,y \in Y$,</li>
<li>$f(x) = dist(x,Y)$</li>
<li>$||f|| = 1$</li>
</ol>
<p><strong>推论3</strong> 设 $X$ 是赋范空间，$x_0,y_0 \in X, x_0 \neq y_0$ ，则存在连续线性泛函 $f$，使得 $f(x_0) \neq f(y_0)$</p>
<h3 id="Hahn-Banach__u5EF6_u62D3_u5B9A_u7406_u7684_u51E0_u4F55_u5F62_u5F0F"><a href="#Hahn-Banach__u5EF6_u62D3_u5B9A_u7406_u7684_u51E0_u4F55_u5F62_u5F0F" class="headerlink" title="Hahn-Banach 延拓定理的几何形式"></a>Hahn-Banach 延拓定理的几何形式</h3><p><strong>定理3</strong> 设 $X$ 是拓扑线性空间， $X^{* }$ 表示其上连续线性泛函全体，$A,B \subset X$ 是非空凸集。</p>
<ol>
<li>若 $A^{o} \neq \emptyset, A^{o} \cap B = \emptyset$ 则 $\exists f \in X^{* },f \neq 0$ 使得<br>$$ \Re f(x) \leq \Re f(y),\; \forall x \in A,y \in B. $$</li>
<li>若 $A$ 是开集，$A \cap B = \emptyset$, 则 $\exists f \in X^{* },r \in \mathbb{R}$ 使得<br>$$ \Re f(x) &lt; r \leq \Re f(y),\; \forall x \in A,y \in B. $$<br>若B也是开集，则可使右端不等式严格成立。</li>
<li>若空间 $X$ 是局部凸的，$A$ 是紧集，$B$ 是闭集，$A \cap B = \emptyset$ 则 $\exists f \in X^{* },r_1,r_2 \in \mathbb{R}$ 使得<br>$$ \Re f(x) \leq r_1 &lt; r_2 \leq \Re f(y),\; \forall x \in A,y \in B. $$</li>
<li>若空间 $X$ 是局部凸的，$A$ 是平衡开集，$A \cap B = \emptyset$ 则 $\exists f \in X^{* },r \in \mathbb{R}$ 使得<br>$$ |f(x)| &lt; r \leq |f(y)|, \; \forall x \in A,y \in B $$</li>
</ol>
<p>证明: 由于复线性泛函 $f$ 可以写成 $f(x) = \Re f(x) - i \Re f(ix)$ ,我们不妨假设 $X$ 是实空间，否则先将复空间视作是空间，得出实线性泛函，然后根据上式构造$X$上的复线性泛函，并不为影响上面的结论。</p>
<ol>
<li>不妨假定(线性泛函平移一下) $0 \in A^{o}$，取 $x_0 \in B$,令 $C = A^{o} - B + x_0$ 则 $C$ 是开凸集，$x_0 \notin C$。若$\mu_C$是$C$的 Minkovski 泛函(是正齐次次可加泛函)，则$\mu_C(x_0) \geq 1$ 定义<br>$$ M = \lbrace t x_0 \colon t \in \mathbb{R} \rbrace , f_0(t x_0) = t$$<br>在 $M$ 上 $f_0(t x_0) = t \leq t\mu_C(x_0) \leq \mu_0(t x_0)$ 由定理1知，存在线性泛函 $f \colon X \to \mathbb{R}$ 使得<br>$$ f|_M = f_0 ,f(x) \leq \mu_C(x),\; \forall x \in X $$<br>注意到在$C \cap (-C)$ 上<br>$$ \pm f(x) = f(\pm x) \leq \mu_C (\pm x) \leq 1$$<br>易知 $f$ 连续。<br>当 $x \in A^{o},y \in B$ 时 $x-y+x_0 \in C$,因此<br>$$f(x-y+x_0) \leq \mu_C(x-y+x_0) \leq 1$$<br>因此 $f(x) &lt; f(y)$,又对于凸集$A$ 有$ \overline{A^{o}} = \overline{A}$，所以 $f(x) \leq f(y),\; \forall x \in A ,y \in B$.</li>
<li>对上述 $f$ 记 $r = \inf_{y \in B} f(y)$,若 $A$ 是开集，则有 $f(x) \leq r, \forall x \in A$，否则设 $x_0 \in A,f(x_0) = r$.因为 $A$ 是开集，因此存在 $z \in X$ 使得$x_0 \pm z \in A,f(z) \neq 0$.于是 $f(x_0 \pm z) = r \pm  f(z)$矛盾，同理 $B$ 为开集时，右端也是严格的。</li>
<li>当 $A$ 紧，$B$ 闭时，取凸邻域 $V \in N(0)$，使得$ (A+V) \cap B = 0 $ ，由1，存在 $f \in X^{* },r \in \mathbb{R}$ 使得<br>$$ \Re f(x) &lt; r \leq \Re f(y),\; \forall x \in A+V,y \in B. $$<br>记 $r_1 = \sup_{x \in A} f(x),r_2 =\inf_{y \in B} f(y)$.因为 $A$ 是紧集，因此 r_1 必然可达到，此时必有 $r_1 \leq  r_2$，否则又会出现类似于2的矛盾。</li>
<li>根据2，存在$f \in X^{* },r&gt;0$ 使得<br>$$ \Re f(x) &lt; r \leq \Re f(y),\; \forall x \in A,y \in B. $$<br>由于 $A$ 是平衡集，故 $x \in A$ 当且仅当 $e^{-i \theta}x \in A, \theta \in \mathbb{R}$,特别的取 $\theta = \arg f(x)$ 则<br>$$ |f(x)| = e^{-i \theta}f(x) = f(e^{i \theta}x) = \Re f(e^{i \theta}x) &lt; r $$<br>这是我们要的不等式左边，右边直接由 $\Re f(y) \leq |f(y)|$ 得到,证毕。</li>
</ol>
<p>欢迎访问和评论 <a href="http://dna049.com">http://dna049.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Hahn-Banach 延拓定理通常分为分析和几何的形式，其中几何形式通常称为凸集分离性定理。<br>]]>
    
    </summary>
    
      <category term="泛函分析" scheme="http://dna049.com/tags/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拓扑线性空间的若干基本定理]]></title>
    <link href="http://dna049.com/2016/02/18/%E6%8B%93%E6%89%91%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/"/>
    <id>http://dna049.com/2016/02/18/拓扑线性空间的若干基本定理/</id>
    <published>2016-02-18T08:02:15.000Z</published>
    <updated>2016-02-23T11:16:57.000Z</updated>
    <content type="html"><![CDATA[<p>在泛函分析中几个基本重要的定理：一致有界原理，开映射定理，闭图像定理等都可以相应的推广到拓扑线性空间中。以下内容来自刘培德《拓扑线性空间与算子谱理论》第二章。<br><a id="more"></a></p>
<p>设 $X,Y$ 是拓扑线性空间，记$L(X,Y)$ 是 $X$ 到 $Y$ 的线性算子全体，而$\mathscr{L}(X,Y)$ 是 $X$ 到 $Y$ 的连续线性算子全体。$N_X(x)$ 表示 $x \in X$ 的邻域全体。除非特别声明，以下$X,Y$都是拓扑线性空间</p>
<h3 id="u7B49_u5EA6_u8FDE_u7EED_u548C_u4E00_u81F4_u6709_u754C"><a href="#u7B49_u5EA6_u8FDE_u7EED_u548C_u4E00_u81F4_u6709_u754C" class="headerlink" title="等度连续和一致有界"></a>等度连续和一致有界</h3><p>等度连续: 称算子族 $\mathscr{H} \subset L(X,Y)$ 是等度连续的，若 $\forall U \in N_Y(0), V \in N_X(0)$ 使得<br><span>$$T(V) \subset U, \; \forall T \in \mathscr{H}
 \; \Leftrightarrow \;
\cup_{T \in \mathscr{H} } T(V) \subset U$$</span><!-- Has MathJax --></p>
<p>一致有界: 称算子族 $\mathscr{H} \subset L(X,Y)$ 是一致有界的，若对 $X$ 中任一有界集 $E$ , $\cup_{T \in \mathscr{H}} T(E)$ 是有界.</p>
<p><strong>定理1</strong> 设 $\mathscr{H}$ 是 $L(X,Y)$ 中的一族算子。</p>
<ol>
<li>若 $\mathscr{H}$ 是等度连续的，则 $\mathscr{H}$ 是一致有界的。</li>
<li>若 $X$ 是可度量化的，$\mathscr{H}$ 是一致有界的，则 $\mathscr{H}$ 是等度连续的</li>
</ol>
<p>证明：</p>
<ol>
<li>若 $\mathscr{H}$ 是等度连续的，则$\forall U \in N_Y(0), \exists V \in N_X(0)$ 使得 $T(V) \subset U, \; \forall T \in \mathscr{H}$ .对 $X$ 中任一有界集 $E$，则 $\exists t &gt; 0$ 使得 $s&gt;t$ 时，$E \subset sV$,于是<span>$$T(E) \subset T(sV) = sT(V) \subset sU , \;
\forall T \in \mathscr{H}$$</span><!-- Has MathJax -->
从而 $\cup _ {T \in \mathscr{H} } T(V) \subset U$ , $\mathscr{H}$ 是一致有界的。</li>
<li>反证，设 $U \in N_Y(0)$ ,若不存在 $V$ 使得 $\cup_{T \in \mathscr{H} } T(V) \subset U$ ,则可取 $T_n \in \mathscr{H},x_n \in X, x_n \to 0$ 但 $Tx_n \notin U$.由于 $d(x_n,0) \to 0$ ,存在 $r_n \to \infty$ 使得 $r_n x_n \to 0$ . $r_n x_n$ 是有界的，从而 $\cup_{T \in \mathscr{H}} T(r_n x_n)$ 有界。但是<br>$$ r_n ^{-1} T(r_n x_n) = T(x_n) \notin U $$<br>矛盾与有界性的等价条件。</li>
</ol>
<h3 id="u4E00_u81F4_u6709_u754C_u6027_u539F_u7406"><a href="#u4E00_u81F4_u6709_u754C_u6027_u539F_u7406" class="headerlink" title="一致有界性原理"></a>一致有界性原理</h3><p><strong>定理2</strong> 设 $\mathscr{H} \subset \mathscr{L}(X,Y)$ , 记$E$为使 $\lbrace Tx:T \in \mathscr{H} \rbrace$ 的点 $x$ 全体。若 $E$ 是第二纲集，则 $\mathscr{H}$ 等度连续，此时必有 $E=X$.</p>
<p>证明：设 $W \in N_Y(0)$ ，取0点的平衡邻域 $U$ 使得 $ \overline{U} + \overline{U} \subset W$ 。记 $B = \cap_{T \in \mathscr{H} } T^{-1} (\overline{U})$，有 $T$ 的连续性知 $B$ 是闭集。$\forall x \in E, \lbrace Tx, T \in mathscr{H} \rbrace$ 有界。因此，$\exists n$ 使得 $Tx \in nU \forall T \in \mathscr{H} $，即 $\frac{x}{n} \in T^{-1} (U) \in T^{-1} (\overline{U})$ 。于是 $x \in nB,E \subset \cup_{n=1}^{\infty} nB$。$E$ 是第二纲集，因此有某个 $(nB)^{o} \neq \emptyset $,从而 $(B)^{o} \neq \emptyset $.<br>设 $x \in B^{o}$,记 $V = x-B^{o}$ ,则 $V \in N_X(0)$.注意到 $T(B) \in \overline{U} ,\forall T \in \mathscr{H} $。因此<br>$$ T(V) \subset Tx - T(B) \subset \overline{U} - \overline{U} \in W ,\forall T \in \mathscr{H} $$<br>这说明 $\mathscr{H}$ 是等度连续的。<br>由定理1知，此时 $\mathscr{H}$ 是一致有界的，又单点集 ${x}$ 有界，因此 $\lbrace Tx:T \in \mathscr{H} \rbrace$ 有界，所以 $E=X$。</p>
<p>定理3 (Banach-Steinhaus) 设 $ T_n\in \mathscr{L}(X,Y)$ , 记$E$为使 $\lim_{n \to \infty} T_n x $ 存在的 $x$ 全体。若 $E$ 是第二纲集，则$E=X$.<br>证明：由于收敛序列是有界的，因此根据定理2，上述结论显然。</p>
<h3 id="u5F00_u6620_u5C04_u5B9A_u7406"><a href="#u5F00_u6620_u5C04_u5B9A_u7406" class="headerlink" title="开映射定理"></a>开映射定理</h3><p>从 $X$ 到 $Y$ 的线性算子称为开算子，如果它把 $X$ 中的每一个开集映成 $Y$ 中的开集。</p>
<p><strong>定理4</strong> (开映射定理) 若 $X,Y$ 是 $F$ 空间(完备的赋准范空间)，$T \in \mathscr{L}(X,Y),T(X)$ 是 $Y$ 中的第二纲集，则 $T$ 是开算子，且此时$Y=T(X)$。</p>
<p>为证明开映射定理，先证明三个引理。</p>
<p><strong>引理1</strong> 设 $T:X \to Y$ 是线性算子，则 $T$ 是开映射，当且仅当 $\forall V \in N_X(0)$,$0 \in Y$ 是 $T(V)$ 的内点。</p>
<p>证明：若$T$ 是开算子，$V \in N_X(0)$,则 $T(V)$开，又 $T0=0$ ,故 $0 \in Y$ 是 $T(V)$ 的内点。<br>反之，若 $T$ 将0点的邻域映成以0为内点的集合。则对每个开集 $B \subset X$ ,$B$ 可以写成 $B = \cup_{x \in B } (x+V_x) $ 于是<br>$$ T(B) = \cup_{x \in B} T(x+V_x) = \cup_{x \in B}(Tx - T(V_x)) $$<br>由于 $T(V_x)$ 是以0为内点，上式表明 $Tx$ 是 $T(B)$ 的内点,从而 $T(B)$ 是 $Y$ 中的开集。</p>
<p><strong>引理2</strong> 设 $T:X \to Y$ 是线性算子，则 $T$ 是开映射，则 $T$ 是到上(满)的。</p>
<p>证明: 若 $T$ 是开映射，则 $\forall V \in X$, $T(V)$ 是 $Y$ 中的开集，$V,T(V)$都是吸收的，所以<br>$$ Y = \cup_{n=1}^{\infty} nT(V) = T(\cup_{n=1}^{\infty} nV) = T(X) $$</p>
<p><strong>引理3</strong> 设 $T:X \to Y$ 是线性算子，若 $T(X)$ 是 $Y$ 中的第二纲集，则 $\forall U \in N_X(0),\exists B \in N_Y(0)$ 使得 $B \in \overline{T(U)}$</p>
<p>证明: $\forall U \in N_X(0)$ ,取 $\forall V \in N_X(0)$ 使得 $V$ 是平衡的且 $V-V \subset U$.<br>$$ T(X) = T(\cup_{n=1}^{\infty} nV) = \cup_{n=1}^{\infty} nT(V)$$ 是第二纲的，所以 $\exists n$ 使得 $\overline{nT(V)}^{o} \neq \emptyset$，因此 $\overline{T(V)}^{o} \neq \emptyset$. 于是存在开集 $B \in N_X(0)$ 使得<br>$$B \subset \overline{T(V)} - \overline{T(V)} \subset \overline{T(V-V)} \subset \overline{T(U)} $$ </p>
<p>开映射定理证明: 设 $p,q$ 分别是 $X,Y$ 上的准范数，取<br>$$ U=\lbrace x \colon p(x)&lt;r \rbrace ,\quad U_n = \lbrace x \colon q(x) &lt; \frac{r}{2^n} \rbrace $$<br>由引理3知，存在$B_n \in N_Y(0)$ 使得 $B_n \subset \overline{T(U_n)}$.由引理1知，我们只需证明 $B_1 \subset U$.记<br>$$ O_n = \lbrace y \in Y \colon q(y) &lt; \frac{1}{n} \rbrace $$<br>任取 $y_1 \in B_1 \subset \overline{T(U_1)}$, 于是 $\exists x_1 \in U_1$ 使得 $y_2 = y_1 - Tx_1 \in B_2 \cap O_2$,类似地做，$\exists x_n \in U_n$ 使得 $y_{n+1} = y_n - Tx_n \in B_{n+1} \cap O_{n+1}$<br>此时<br>$$ y_{n+1} = y_1 -T(\sum_{i=1}^n x_i)$$<br>由于<br>$$ p(\sum_{i=1}^n x_i) \leq \sum_{i=1}^n p(x_i) &lt; \sum_{i=1}^n \frac{r}{2^n} &lt; r $$<br>并且由于 $\lbrace \sum_{i=1}^n x_i \rbrace$ 是Cauchy列，$\exists x_0 \in X, \sum_{i=1}^n x_i \to x_0$ 并且 $p(x_0) &lt; r$,从而 $x_0 \in U$。<br>注意到 $y_n \in O_n$, $y_n \to 0$。由 $T$ 的连续性<br>$$ 0 = \lim_{n \to \infty} y_{n+1} = y_1 - \lim_{n \to \infty} T(\sum_{i=1}^n x_i) = y_1 - Tx_0 $$<br>即 $y_1 = Tx_0 \in T(U)$,故$B \in T(U)$,证毕。</p>
<p><strong>推论1</strong> (Banach逆算子定理的推广) 从 $F$ 空间到　$F$ 空间上的每一个连续线性满算子 $T$ 的开算子，若 $T$ 还是一一的，则 $T$ 是同胚映射。<br><strong>推论2</strong> (范数等价定理的推广) 设 $X$ 上有两种拓扑 $\tau_1,\tau_2$,并且$\tau_1,\tau_2$ 都使 $X$ 成为 $F$ 空间，若$\tau_1,\tau_2$ 是可比较的，则$\tau_1 ＝ \tau_2$ 。</p>
<h3 id="u95ED_u56FE_u50CF_u5B9A_u7406"><a href="#u95ED_u56FE_u50CF_u5B9A_u7406" class="headerlink" title="闭图像定理"></a>闭图像定理</h3><p>设 $X,Y$ 是拓扑线性空间，$X \times Y$ 是乘积空间，$T \colon X \to Y$ 是线性算子，称 $T$ 是闭算子，若 $T$ 的图像 $\mathscr{G}(T) = \lbrace (x,Tx) \colon \forall x \in X \rbrace$ 是 $X \times Y$ 中的闭集。</p>
<p><strong>定理5</strong> 设 $X,Y$ 是拓扑线性空间，$T \colon X \to Y$ 是线性算子</p>
<ol>
<li>若 $T$ 是连续的，则 $T$ 是闭算子</li>
<li>(闭图像定理)若 $T$ 是闭算子，并且 $X,Y$ 都是 $F$ 空间，则 $T$ 是连续的。</li>
</ol>
<p>证明:</p>
<ol>
<li>设$T \colon X \to Y$ 连续，$(x_{\lambda},\lambda \in \Lambda)$ 是 $X$ 中的网，$x_{\lambda} \to x ,Tx_{\lambda} \to y$,则<br>$$ y = \lim_{\lambda \in \Lambda} Tx_{\lambda} =  T(\lim_{\lambda \in \Lambda} x_{\lambda}) = Tx$$<br>因此 $(x,y) \in \mathscr{G}(T)$,因此 $T$ 是闭算子。</li>
<li>注意到此时 $X \times Y$ 也是 $F$ 空间，由于 $\mathscr{G}(T)$ 是 $X \times Y$ 的线性子空间，若 $\mathscr{G}(T)$ 在 $X \times Y$ 中闭，$\mathscr{G}(T)$ 也是 $F$ 空间。由乘积拓扑的定义，两投影<br>$$ \pi_1 \colon \mathscr{G}(T) \to X, (x,Tx) \mapsto x, $$<br>$$ \pi_2 \colon \mathscr{G}(T) \to X, (x,Tx) \mapsto Tx $$<br>都是连续的。特别的 $\pi_1$ 是一一到上的，由推论1知，$\pi_1^{-1} \colon X \to \mathscr{G}(T)$ 连续，此时<br>$$ Tx = \pi_2(x,Tx) = \pi_2 \circ \pi_1^{-1} x,\forall x \in X $$<br>从而$T=\pi_2 \circ \pi_1^{-1}$</li>
</ol>
<pre><code>我发现我喜欢在此记录我学习的东西，反正这里也很少会有人来看，写出来很大的目的是让我自己走一遍过程，写总比看来的深刻。
</code></pre><p>欢迎访问0.0 <a href="http://dna049.com">http://dna049.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在泛函分析中几个基本重要的定理：一致有界原理，开映射定理，闭图像定理等都可以相应的推广到拓扑线性空间中。以下内容来自刘培德《拓扑线性空间与算子谱理论》第二章。<br>]]>
    
    </summary>
    
      <category term="泛函分析" scheme="http://dna049.com/tags/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[“公平”的席位分配]]></title>
    <link href="http://dna049.com/2016/02/17/%E5%85%AC%E5%B9%B3%E7%9A%84%E5%B8%AD%E4%BD%8D%E5%88%86%E9%85%8D/"/>
    <id>http://dna049.com/2016/02/17/公平的席位分配/</id>
    <published>2016-02-17T04:23:42.000Z</published>
    <updated>2016-02-23T11:16:53.000Z</updated>
    <content type="html"><![CDATA[<p>如果说数学有点用，估计大都表现在运筹学中吧。“公平”的席位分配首先本来就是不可能的，公平一般是无法达到的，我们只是尽量降低不公平度，那么我们怎么衡量不公平度呢。就像评价一个人，有不同的指标，不公平度也是一样，这里介绍一种相对合理易于接受，且好判断的方法。<br><a id="more"></a></p>
<h3 id="u95EE_u9898_u8868_u8FF0"><a href="#u95EE_u9898_u8868_u8FF0" class="headerlink" title="问题表述"></a>问题表述</h3><p>某学校三个系部学生共200名,(甲系100,乙系60,丙系40)代表会议共20席,按比例分配三个系分别为10、6、4席。老情况变为下列情况怎样分配才是最公平的,现因学生转系三系人数为103、63、34。 </p>
<ol>
<li>问20席该如何分配 ? </li>
<li>若增加21席又如何分配 ?</li>
</ol>
<p>显然，因为无法整除无论如何分配都不公平。下面说一下几种策略。</p>
<ol>
<li>按班级人数比例乘以总人数，小数点大的分得多余的一个位子。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">某校</th>
<th style="text-align:right">甲系</th>
<th style="text-align:right">乙系</th>
<th style="text-align:right">丙系</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">共200人</td>
<td style="text-align:right">103</td>
<td style="text-align:right">63</td>
<td style="text-align:right">34</td>
</tr>
<tr>
<td style="text-align:center">人数比例</td>
<td style="text-align:right">51.3</td>
<td style="text-align:right">31.5</td>
<td style="text-align:right">17</td>
</tr>
<tr>
<td style="text-align:center">20席位</td>
<td style="text-align:right">10.3</td>
<td style="text-align:right">6.3</td>
<td style="text-align:right">3.4</td>
</tr>
<tr>
<td style="text-align:center">实际分配</td>
<td style="text-align:right">10</td>
<td style="text-align:right">6</td>
<td style="text-align:right">4</td>
</tr>
<tr>
<td style="text-align:center">21席位</td>
<td style="text-align:right">10.82</td>
<td style="text-align:right">6.62</td>
<td style="text-align:right">3.57</td>
</tr>
<tr>
<td style="text-align:center">实际分配</td>
<td style="text-align:right">11</td>
<td style="text-align:right">7</td>
<td style="text-align:right">3</td>
</tr>
</tbody>
</table>
<p>按照上述方法，会出现席位增多而丙系的席位却减少了一个的不合理现象，说明此方法并不合理。</p>
<h3 id="u6A21_u578B_u5EFA_u7ACB"><a href="#u6A21_u578B_u5EFA_u7ACB" class="headerlink" title="模型建立"></a>模型建立</h3><p>假设由A、B两个单位公平分配席位的情况，设两方人数$p_1,p_2$ ,分配到的席位为 $n_1,n_2$。</p>
<ol>
<li>$\frac{p_1}{n_1} = \frac{p_2}{n_2}$ 公平，但是一般是不满足的。</li>
<li>$\frac{p_1}{n_1} &gt; \frac{p_2}{n_2}$ 对A不公平。</li>
<li>$\frac{p_1}{n_1} &lt; \frac{p_2}{n_2}$ 对B不公平。</li>
</ol>
<p>绝对不公平度为<br>$$ d = \left| \frac{p_1}{n_1} - \frac{p_2}{n_2} \right| $$<br>但这样做还是有不足，例如<br>某两个单位的人数和席位为 $n_1=n_2=10,p_1=120,p_2=100$ 算得  $d=2$.<br>另两个单位的人数和席位为 $n_1=n_2=10,p_1=1020,p_2=1000$ 算得 $d=2$。<br>但是显然，后一种方案，更公平。</p>
<p>因此，我们引入相对不公平度</p>
<ol>
<li>若 $\frac{p_1}{n_1} &gt; \frac{p_2}{n_2}$ 则<br>$$ r_A(n_1,n_2) = \frac{ \frac{p_1}{n_1} - \frac{p_2}{n_2} }{ \frac{p_2}{n_2} }$$</li>
<li>若 $\frac{p_1}{n_1} &lt; \frac{p_2}{n_2}$<br>$$ r_B(n_1,n_2) =  \frac{\frac{p_2}{n_2} - \frac{p_1}{n_1} }{\frac{p_1}{n_1}}$$<br>我们的目标是让$r_A,r_B$(每种分配只会有一个)最小。</li>
</ol>
<h5 id="u786E_u5B9A_u5206_u914D_u65B9_u6848"><a href="#u786E_u5B9A_u5206_u914D_u65B9_u6848" class="headerlink" title="确定分配方案"></a>确定分配方案</h5><p>假设当前 $\frac{p_1}{n_1} &gt; \frac{p_2}{n_2}$ 对A不公平。新增了一个席位。</p>
<ol>
<li>若 $\frac{p_1}{n_1+1} &gt; \frac{p_2}{n_2}$ 则A加1席</li>
<li>若 $\frac{p_1}{n_1+1} &lt; \frac{p_2}{n_2}$<br>若分配给A，则对B的不公平值(相对):<br>$$ r_B(n_1+1,n_2) = \frac{p_2(n_1+1)}{p_1 n_2} -1 $$<br>若分配给B，则对A的不公平值(相对):<br>$$ r_A(n_1,n_2+1) = \frac{p_1(n_2+1)}{p_2 n_1} -1 $$</li>
</ol>
<p>若$r_A(n_1,n_2+1)&lt;r_B(n_1+1,n_2)$则席位分配给B，反之给A。<br>即令<br>$$ Q_i = \frac{p_i ^2}{n_i(n_i+1)}$$<br>将席位分配给 $Q$ 值较大者。</p>
<h3 id="u6A21_u578B_u6C42_u89E3"><a href="#u6A21_u578B_u6C42_u89E3" class="headerlink" title="模型求解"></a>模型求解</h3><p>先按照平均原则取整之后。分出了19席：$n_1=10,n_2=6,n_3=3$<br>第20席:<br>$$ Q_1 = \frac{103^2}{10 \times 11 } = 96.4 \; , \;Q_2 = \frac{63^2}{6 \times 7} = 94.5 \; , \;Q_3 = \frac{34^2}{3 \times 4} = 96.3 $$<br>则分配：$n_1=11,n_2=6,n_3=3$<br>第21席：$Q_1=80.4, Q_2 = 94.5, Q_3 = 96.3$<br>则分配：$n_1=11,n_2=6,n_3=4$.</p>
<p>本文参考<a href="http://wenku.baidu.com/view/396d4f6aaf1ffc4ffe47ac52.html?re=view" target="_blank" rel="external">文库1</a>和<a href="http://wenku.baidu.com/view/312ef3274b35eefdc9d33304.html?re=view" target="_blank" rel="external">文库2</a>。修改了其中的错误，由于席位分配问题确实是一个经典问题，故在此记录。</p>
<p>欢迎访问<a href="http://dna049.com">http://dna049.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果说数学有点用，估计大都表现在运筹学中吧。“公平”的席位分配首先本来就是不可能的，公平一般是无法达到的，我们只是尽量降低不公平度，那么我们怎么衡量不公平度呢。就像评价一个人，有不同的指标，不公平度也是一样，这里介绍一种相对合理易于接受，且好判断的方法。<br>]]>
    
    </summary>
    
      <category term="运筹学" scheme="http://dna049.com/tags/%E8%BF%90%E7%AD%B9%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hdu 5628 (Dirichlet积与快速幂的应用)]]></title>
    <link href="http://dna049.com/2016/02/16/hdu-5628-Dirichlet%E7%A7%AF%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://dna049.com/2016/02/16/hdu-5628-Dirichlet积与快速幂的应用/</id>
    <published>2016-02-16T15:56:10.000Z</published>
    <updated>2016-03-06T02:37:56.000Z</updated>
    <content type="html"><![CDATA[<p>突然有点想打一场BestCoder，然后就看了看BC发现有道应用Dirichlet积的题。于是就去试了试。当然老套路还是很好过的，后来我想写的优美一点写成类的形式，不过一直出现Crash，于是跟周学长讨论了一下，外加一点看书，终于也是搞定了，就此存一下模版吧 0.0<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line"><span class="keyword">class</span> NumFun&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    NumFun(<span class="keyword">int</span> _n = <span class="number">0</span>)&#123;</span><br><span class="line">        n = _n;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    NumFun(<span class="keyword">const</span> NumFun &amp;A)&#123;</span><br><span class="line">        n = A.n;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            a[i]=A.a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NumFun &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NumFun &amp;A)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;A) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] a;</span><br><span class="line">            n = A.n;</span><br><span class="line">            a = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">                a[i]=A.a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~NumFun()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> d=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            a[i]=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            a[i]=p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NumFun <span class="keyword">operator</span>*(<span class="keyword">const</span> NumFun &amp;A)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="function">NumFun <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">        R.init(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i*j&lt;=n;++j)&#123;</span><br><span class="line">                R.a[i*j] = (R.a[i*j] + LL(a[i])*A.a[j])%M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">NumFun <span class="title">pow</span><span class="params">(NumFun A,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="function">NumFun <span class="title">R</span><span class="params">(A.n)</span></span>;</span><br><span class="line">    R.init();</span><br><span class="line">    R.a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) R=R*A;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("/Users/c10110057/Desktop/AC/in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("/Users/c10110057/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T,n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">NumFun <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">        R.<span class="built_in">set</span>(a);</span><br><span class="line">        <span class="function">NumFun <span class="title">ONE</span><span class="params">(n)</span></span>;</span><br><span class="line">        ONE.init(<span class="number">1</span>);</span><br><span class="line">        R = <span class="function">R*<span class="title">pow</span><span class="params">(ONE,k)</span></span>;</span><br><span class="line">        R.print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>突然有点想打一场BestCoder，然后就看了看BC发现有道应用Dirichlet积的题。于是就去试了试。当然老套路还是很好过的，后来我想写的优美一点写成类的形式，不过一直出现Crash，于是跟周学长讨论了一下，外加一点看书，终于也是搞定了，就此存一下模版吧 0.0<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二次剩余和Guass互反律]]></title>
    <link href="http://dna049.com/2016/02/16/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E5%92%8CGuass%E4%BA%92%E5%8F%8D%E5%BE%8B/"/>
    <id>http://dna049.com/2016/02/16/二次剩余和Guass互反律/</id>
    <published>2016-02-16T13:05:36.000Z</published>
    <updated>2016-02-23T11:16:43.000Z</updated>
    <content type="html"><![CDATA[<p>从二次剩余问题，引入Legendre符号，由此一步步导出Guass互反律，最后延伸到Jacobi符号，整个步骤确实连贯优美，脍炙人口。<br><a id="more"></a></p>
<p>寒假回家好好调整了一下状态，回学校后感觉还不错，效率也蛮高。发现理图虽然比较破，但是还是很不错的，哈哈哈。每次读潘承洞先生的《数论基础》都觉得受益匪浅，我把自己很喜欢的部分写入到该文中。</p>
<h3 id="u4E8C_u6B21_u5269_u4F59"><a href="#u4E8C_u6B21_u5269_u4F59" class="headerlink" title="二次剩余"></a>二次剩余</h3><p>考虑如下形式二次同余式<br>$$ x^2 = a \; (mod \; p) $$<br>其中 $p$ 是奇素数。</p>
<p>经过简单推理很容易发现，在模 $p$ 的简化系中，二次剩余与二次非剩余各占一半。且容易知道，$1^2,2^2,\cdots,(\frac{p-1}{2})^2$ 都是二次剩余。</p>
<h3 id="Legendre__u7B26_u53F7"><a href="#Legendre__u7B26_u53F7" class="headerlink" title="Legendre 符号"></a>Legendre 符号</h3><span>$$\left( \frac{a}{p} \right) = \left\{ \begin{array}{cc} 1, &amp; a\; R\; p \\
0, &amp; p\;|\;a \\
-1, &amp; a\; \overline{R}\; p. \end{array} \right.$$</span><!-- Has MathJax -->
<h5 id="u5B9A_u74061__3C_21-_uFFFC4-_3E"><a href="#u5B9A_u74061__3C_21-_uFFFC4-_3E" class="headerlink" title="定理1   <span>$\quad -(\frac{a}{p}) (p-1)! \equiv a^{\frac{p-1}{2}} \;(mod \; p)$</span><!-- Has MathJax -->"></a>定理1   <span>$\quad -(\frac{a}{p}) (p-1)! \equiv a^{\frac{p-1}{2}} \;(mod \; p)$</span><!-- Has MathJax --></h5><p>Proof: 对于 $p\;|\;a$ 的情形，结论显然。下面考虑 $(p,a)=1$ 的情形，令<br>$$ S = \lbrace 1,2,\cdots,p-1 \rbrace $$<br>对任意的 $ x \in S $ 必存在唯一的 $ y \in S $ 为下面同余式的解<br>$$ yx \equiv a \; (mod \; p) $$</p>
<p>(i) 当 $ (\frac{a}{p}) = -1 $ 时，同余式<br>$$ x^2 = a \; (mod \; p) $$<br>无解，所以 $y \neq x $ .因此集合 $S$ 中的元素可以分成 $\frac{p-1}{2} $ 对，我们就有<br>$$ (p-1)! \equiv a^{\frac{p-1}{2}} \;(mod \; p) $$<br>(ii) 当 $ (\frac{a}{p}) = 1 $ 时，同余式<br>$$ x^2 = a \; (mod \; p) $$<br>有两个解 $x_0$ 和 $p - x_0$.在$S$中去掉这两个数外剩下$p-3$个数分出 $\frac{p-3}{2}$对，则有<br>$$ (p-1)! \equiv a^{\frac{p-3}{2}}x_0(p-x_0) \;(mod \; p) \equiv - a^{\frac{p-1}{2}} \;(mod \; p) $$ 证毕。</p>
<h5 id="u63A8_u8BBA2__28Wilson__u5B9A_u7406_29"><a href="#u63A8_u8BBA2__28Wilson__u5B9A_u7406_29" class="headerlink" title="推论2 (Wilson 定理)"></a>推论2 (Wilson 定理)</h5><p>$$ (p-1)! \equiv -1 \;(mod \; p) $$<br>Proof: 定理一 中取 $a=1$即可。</p>
<h5 id="u63A8_u8BBA3__28Euler__u5224_u522B_u6CD5_29"><a href="#u63A8_u8BBA3__28Euler__u5224_u522B_u6CD5_29" class="headerlink" title="推论3 (Euler 判别法)"></a>推论3 (Euler 判别法)</h5><p>$$ \left( \frac{a}{p} \right ) \equiv a^{\frac{p-1}{2}} \;(mod \;p ) $$<br>Proof: 由定理1和推论2显然。Euler判别法不仅有理论价值(下面都是推论3的直接推论)，由于快速幂的存在，使得Euler判别法在计算时有相当好的效果。</p>
<h5 id="u63A8_u8BBA4__28Format__u5C0F_u5B9A_u7406_29__u8BBE__24_28a_2Cp_29_3D1_24__2C_u5219"><a href="#u63A8_u8BBA4__28Format__u5C0F_u5B9A_u7406_29__u8BBE__24_28a_2Cp_29_3D1_24__2C_u5219" class="headerlink" title="推论4 (Format 小定理) 设 $(a,p)=1$ ,则"></a>推论4 (Format 小定理) 设 $(a,p)=1$ ,则</h5><p>$$ a^{p-1} \equiv 1 \;(mod \; p) $$</p>
<h5 id="u63A8_u8BBA5__24_5C_3B__28_5Cfrac_7B-1_7D_7Bp_7D_29__3D__28-1_29_5E_7B_5Cfrac_7Bp-1_7D_7B2_7D_7D_24"><a href="#u63A8_u8BBA5__24_5C_3B__28_5Cfrac_7B-1_7D_7Bp_7D_29__3D__28-1_29_5E_7B_5Cfrac_7Bp-1_7D_7B2_7D_7D_24" class="headerlink" title="推论5 $\; (\frac{-1}{p}) = (-1)^{\frac{p-1}{2}}$"></a>推论5 $\; (\frac{-1}{p}) = (-1)^{\frac{p-1}{2}}$</h5><h5 id="u63A8_u8BBA6__24_5C_3B__28_5Cfrac_7Bab_7D_7Bp_7D_29__3D_28_5Cfrac_7Ba_7D_7Bp_7D_29_28_5Cfrac_7Bb_7D_7Bp_7D_29__24"><a href="#u63A8_u8BBA6__24_5C_3B__28_5Cfrac_7Bab_7D_7Bp_7D_29__3D_28_5Cfrac_7Ba_7D_7Bp_7D_29_28_5Cfrac_7Bb_7D_7Bp_7D_29__24" class="headerlink" title="推论6 $\; (\frac{ab}{p}) =(\frac{a}{p})(\frac{b}{p}) $"></a>推论6 $\; (\frac{ab}{p}) =(\frac{a}{p})(\frac{b}{p}) $</h5><p>推论3说明，我们求 Legendre 符号，可以转化成求 $ (\frac{2}{p}),(\frac{q}{p}) $.</p>
<h5 id="u5B9A_u74067__24_5C_3B__28_5Cfrac_7B2_7D_7Bp_7D_29__3D__28-1_29_5E_7B_5Cfrac_7Bp_5E2-1_7D_7B8_7D_7D_24"><a href="#u5B9A_u74067__24_5C_3B__28_5Cfrac_7B2_7D_7Bp_7D_29__3D__28-1_29_5E_7B_5Cfrac_7Bp_5E2-1_7D_7B8_7D_7D_24" class="headerlink" title="定理7 $\; (\frac{2}{p}) = (-1)^{\frac{p^2-1}{8}}$"></a>定理7 $\; (\frac{2}{p}) = (-1)^{\frac{p^2-1}{8}}$</h5><p>Proof:<br>$$ 2^{\frac{p-1}{2}}(\frac{p-1}{2})! = 2 \cdot 4 \cdots (p-1) \equiv (\frac{p-1}{2})!(-1)^{1+2+\cdots+\frac{p-1}{2}}\;(mod \; p) $$<br>所以<br>$$ (\frac{2}{p}) \equiv 2^{\frac{p-1}{2}} \equiv (-1)^{\frac{p^2-1}{8}} \;(mod \; p) $$ 证毕。</p>
<h5 id="u5B9A_u74068__28Guass__u4E8C_u6B21_u4E92_u53CD_u5F8B_29__u8BBE__24p_2Cq_24__u4E3A_u4E0D_u540C_u7684_u5947_u7D20_u6570_uFF0C_u5219_u6709"><a href="#u5B9A_u74068__28Guass__u4E8C_u6B21_u4E92_u53CD_u5F8B_29__u8BBE__24p_2Cq_24__u4E3A_u4E0D_u540C_u7684_u5947_u7D20_u6570_uFF0C_u5219_u6709" class="headerlink" title="定理8 (Guass 二次互反律) 设 $p,q$ 为不同的奇素数，则有"></a>定理8 (Guass 二次互反律) 设 $p,q$ 为不同的奇素数，则有</h5><p>$$ (\frac{p}{q}) (\frac{q}{p}) = (-1)^{\frac{(p-1)(q-1)}{4}}$$</p>
<p>Proof: 略。</p>
<p>这里只是简介的纪录一下比较简洁精彩的部分。更多数论的内容还是很推荐潘承洞先生的书的。另外指数原根等一些知识也讲的特别简洁明了。下面给出我写的求原根的MATLAB代码。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span> = <span class="title">zhi_shu</span><span class="params">(g,n)</span></span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line"><span class="comment">% 输入：底数g和模n</span></span><br><span class="line"><span class="comment">% 输出：其指数</span></span><br><span class="line"><span class="comment">% 2016-2-16 in FDU by dna049</span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line">r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> d = <span class="number">1</span>:n</span><br><span class="line">    r = <span class="built_in">mod</span>(r*g,n);</span><br><span class="line">    <span class="keyword">if</span> r == <span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span> = <span class="title">phi_euler</span><span class="params">(n)</span></span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line"><span class="comment">% Euler function in number theory</span></span><br><span class="line"><span class="comment">% 2016-2-16 in FDU by dna049</span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isprime</span>(n)</span><br><span class="line">        x = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pn = <span class="built_in">primes</span>(n);</span><br><span class="line">        x = n;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = pn</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">mod</span>(n,<span class="built_in">i</span>) == <span class="number">0</span></span><br><span class="line">                n = n/<span class="built_in">i</span>;</span><br><span class="line">                <span class="keyword">while</span> <span class="built_in">mod</span>(n,<span class="built_in">i</span>) == <span class="number">0</span></span><br><span class="line">                    n = n/<span class="built_in">i</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                x = x/<span class="built_in">i</span>*(<span class="built_in">i</span>-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">i</span>&gt;n</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span> = <span class="title">yuan_gen_s</span><span class="params">(p)</span></span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line"><span class="comment">% 输入：素数p</span></span><br><span class="line"><span class="comment">% 输出：所有原根</span></span><br><span class="line"><span class="comment">% 2016-2-16 in FDU by dna049</span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line">d_now = p-<span class="number">1</span>;</span><br><span class="line">v = <span class="built_in">ones</span>(<span class="number">1</span>,p);</span><br><span class="line">v(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">v(p) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:p-<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> v(<span class="built_in">i</span>) == <span class="number">1</span></span><br><span class="line">        td = zhi_shu(<span class="built_in">i</span>,p);</span><br><span class="line">        <span class="keyword">if</span> td ~= p-<span class="number">1</span></span><br><span class="line">            tp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:td</span><br><span class="line">                tp = <span class="built_in">mod</span>(tp*<span class="built_in">i</span>-<span class="number">1</span>,p)+<span class="number">1</span>;</span><br><span class="line">                v(tp) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">d = <span class="number">1</span>:p;</span><br><span class="line">d = d(v==<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>从二次剩余问题，引入Legendre符号，由此一步步导出Guass互反律，最后延伸到Jacobi符号，整个步骤确实连贯优美，脍炙人口。<br>]]>
    
    </summary>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自然数方幂和公式]]></title>
    <link href="http://dna049.com/2016/01/21/%E8%87%AA%E7%84%B6%E6%95%B0%E6%96%B9%E5%B9%82%E5%92%8C%E5%85%AC%E5%BC%8F/"/>
    <id>http://dna049.com/2016/01/21/自然数方幂和公式/</id>
    <published>2016-01-21T11:16:51.000Z</published>
    <updated>2016-02-24T13:57:25.000Z</updated>
    <content type="html"><![CDATA[<p>关于自然数方幂和公式，网上的求解版本有很多种。这里介绍一种不为人知，十分简洁明了的求解方法，该公式并非原创，但是整个证明过程和方法完全原创。它的思想来源于我高中时在一本数学竞赛书中的数列例题(书名忘了…)，正因为一本本这样的书，让我大学选择了数学系，现在依然在学习数学。<br><a id="more"></a></p>
<h3 id="u82E5__24a_n__3D_n_28n-1_29_24__u6C42_u5176_u524D__24n_24__u9879_u548C_24S_n_24"><a href="#u82E5__24a_n__3D_n_28n-1_29_24__u6C42_u5176_u524D__24n_24__u9879_u548C_24S_n_24" class="headerlink" title="若 $a_n = n(n-1)$ 求其前 $n$ 项和$S_n$"></a>若 $a_n = n(n-1)$ 求其前 $n$ 项和$S_n$</h3><span>$$a_n = n(n-1) ＝
\frac{(n+1)n(n-1) -n(n-1)(n-2)}{3}$$</span><!-- Has MathJax -->
<p>所以<br><span>$$S_n =
\frac{(n+1)n(n-1)}{3}$$</span><!-- Has MathJax --></p>
<h3 id="u82E5_3C_21-_uFFFC2-_3E_uFF0C_u5219_u5176_u524D__24n_24__u9879_u548C_3C_21-_uFFFC3-_3E"><a href="#u82E5_3C_21-_uFFFC2-_3E_uFF0C_u5219_u5176_u524D__24n_24__u9879_u548C_3C_21-_uFFFC3-_3E" class="headerlink" title="若<span>$a_n = A_n ^p$</span><!-- Has MathJax -->，则其前 $n$ 项和<span>$S_n ＝ \frac{ A_{n+1} ^{p+1}}{p+1}$</span><!-- Has MathJax -->"></a>若<span>$a_n = A_n ^p$</span><!-- Has MathJax -->，则其前 $n$ 项和<span>$S_n ＝ \frac{ A_{n+1} ^{p+1}}{p+1}$</span><!-- Has MathJax --></h3><span>$$a_n = A_n ^p ＝
\frac{A_{n+1} ^{p+1} -A_n ^{p+1}}{p+1}$$</span><!-- Has MathJax -->
<p>所以<br><span>$$S_n =
\frac{A_{n+1} ^{p+1}}{p+1}$$</span><!-- Has MathJax --></p>
<p>由上面的结论下面我们来直对主题。</p>
<h3 id="u6C42__241_5E2+2_5E2+__5Cdots_+_n_5E2_24"><a href="#u6C42__241_5E2+2_5E2+__5Cdots_+_n_5E2_24" class="headerlink" title="求 $1^2+2^2+ \dots + n^2$"></a>求 $1^2+2^2+ \dots + n^2$</h3><p>由<br>$$ n^2 = n(n-1) + n $$<br>知<br>$$1^2+2^2+ \dots + n^2 = \frac{(n+1)n(n-1)}{3} + \frac{(n+1)n}{2} = \frac{n(n+1)(2n+1)}{6}$$</p>
<h3 id="u6C42_241_5Ep+2_5Ep+__5Cdots_+_n_5Ep_24"><a href="#u6C42_241_5Ep+2_5Ep+__5Cdots_+_n_5Ep_24" class="headerlink" title="求$1^p+2^p+ \dots + n^p$"></a>求$1^p+2^p+ \dots + n^p$</h3><p>设<br><span>$$n^p =
a_p A_n ^p + a_{p-1} A_n ^{p-1} + a_{p-2} A_n ^{p-2} + \cdots + a_1 A_n ^1$$</span><!-- Has MathJax --><br>则<br><span>$$1^p+2^p+ \dots + n^p =
\frac{a_p A_{n+1} ^{p+1}}{p+1} + \frac{a_{p-1} A_{n+1} ^{p}}{p} + \cdots + \frac{a_1 A_{n+1} ^2}{2}$$</span><!-- Has MathJax --><br>因此问题的关键就转化成如何求解数组 $a_k ,k=1,2,\cdots,p$<br>我们发现当 $n＝k$ 时成立<br><span>$$k^p =
a_k A_k ^k + a_{k-1} A_k ^{k-1} + \cdots a_1 A_{k} ^1$$</span><!-- Has MathJax --><br>令 $b_k = k! \cdot a_k$ 则<br><span>$$k^p = 
b_k + b_{k-1} C_k ^{k-1} + \cdots b_1 C_{k} ^1$$</span><!-- Has MathJax --><br>即<br><span>$$k^p = 
\sum _{j=1} ^k b_j C _{k} ^j$$</span><!-- Has MathJax --><br>应用二项式反演知(可参考<a href="http://dna049.com/2016/01/21/两类反演公式及其矩阵形式/">我的博文</a>)<br><span>$$b_k = 
\sum _{j=1} ^k (-1)^{k-j} C _{k} ^j k^p$$</span><!-- Has MathJax --><br>因此最终,我们有公式</p>
<span>$$1^p+2^p+ \dots + n^p =
\sum _{k=1} ^p \; (\; \sum_{j=1} ^ {k} (-1)^{k-j} C_k^j j^p \;) \; C _{n+1} ^{k+1}$$</span><!-- Has MathJax --> 
<p>本博文完全由作者(dna0.49)原创于2016年1月21号，转载或引用请注明<a href="http://dna049.com">http://dna049.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于自然数方幂和公式，网上的求解版本有很多种。这里介绍一种不为人知，十分简洁明了的求解方法，该公式并非原创，但是整个证明过程和方法完全原创。它的思想来源于我高中时在一本数学竞赛书中的数列例题(书名忘了…)，正因为一本本这样的书，让我大学选择了数学系，现在依然在学习数学。<br>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
</feed>
