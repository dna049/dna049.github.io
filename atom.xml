<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[0.肆玖]]></title>
  <subtitle><![CDATA[自称数学家，半个程序员]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-02-16T23:24:49.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[dna049]]></name>
    <email><![CDATA[dna049@foxmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[hdu 5628 (Dirichlet积与快速幂的应用)]]></title>
    <link href="http://yoursite.com/2016/02/16/hdu-5628-Dirichlet%E7%A7%AF%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2016/02/16/hdu-5628-Dirichlet积与快速幂的应用/</id>
    <published>2016-02-16T15:56:10.000Z</published>
    <updated>2016-02-16T23:24:49.000Z</updated>
    <content type="html"><![CDATA[<p>突然有点想打一场BestCoder，然后就看了看BC发现有道应用Dirichlet积的题。于是就去试了试。当然老套路还是很好过的，后来我想写的优美一点写成类的形式，不过一直出现Crash，于是跟周学长讨论了一下，外加一点看书，终于也是搞定了，就此存一下模版吧 0.0<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line"><span class="keyword">class</span> NumFun&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    NumFun(<span class="keyword">int</span> _n = <span class="number">0</span>)&#123;</span><br><span class="line">        n = _n;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    NumFun(<span class="keyword">const</span> NumFun &amp;A)&#123;</span><br><span class="line">        n = A.n;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            a[i]=A.a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NumFun &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NumFun &amp;A)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;A) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] a;</span><br><span class="line">            n = A.n;</span><br><span class="line">            a = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">                a[i]=A.a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~NumFun()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> d=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            a[i]=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            a[i]=p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NumFun <span class="keyword">operator</span>*(<span class="keyword">const</span> NumFun &amp;A)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="function">NumFun <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">        R.init(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i*j&lt;=n;++j)&#123;</span><br><span class="line">                R.a[i*j] = (R.a[i*j] + LL(a[i])*A.a[j])%M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">NumFun <span class="title">pow</span><span class="params">(NumFun A,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="function">NumFun <span class="title">R</span><span class="params">(A.n)</span></span>;</span><br><span class="line">    R.init();</span><br><span class="line">    R.a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) R=R*A;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("/Users/c10110057/Desktop/AC/in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("/Users/c10110057/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T,n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">NumFun <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">        R.<span class="built_in">set</span>(a);</span><br><span class="line">        <span class="function">NumFun <span class="title">ONE</span><span class="params">(n)</span></span>;</span><br><span class="line">        ONE.init(<span class="number">1</span>);</span><br><span class="line">        R = <span class="function">R*<span class="title">pow</span><span class="params">(ONE,k)</span></span>;</span><br><span class="line">        R.print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>突然有点想打一场BestCoder，然后就看了看BC发现有道应用Dirichlet积的题。于是就去试了试。当然老套路还是很好过的，后来我想写的优美一点写成类的形式，不过一直出现Crash，于是跟周学长讨论了一下，外加一点看书，终于也是搞定了，就此存一下模版吧 0.0<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[二次剩余和Guass互反律]]></title>
    <link href="http://yoursite.com/2016/02/16/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E5%92%8CGuass%E4%BA%92%E5%8F%8D%E5%BE%8B/"/>
    <id>http://yoursite.com/2016/02/16/二次剩余和Guass互反律/</id>
    <published>2016-02-16T13:05:36.000Z</published>
    <updated>2016-02-17T04:22:15.000Z</updated>
    <content type="html"><![CDATA[<p>从二次剩余问题，引入Legendre符号，由此一步步导出Guass互反律，最后延伸到Jacobi符号，整个步骤确实连贯优美，脍炙人口。<br><a id="more"></a></p>
<p>寒假回家好好调整了一下状态，回学校后感觉还不错，效率也蛮高。发现理图虽然比较破，但是还是很不错的，哈哈哈。每次读潘承洞先生的《数论基础》都觉得受益匪浅，我把自己很喜欢的部分写入到该文中。</p>
<h3 id="u4E8C_u6B21_u5269_u4F59"><a href="#u4E8C_u6B21_u5269_u4F59" class="headerlink" title="二次剩余"></a>二次剩余</h3><p>考虑如下形式二次同余式<br>$$ x^2 = a \; (mod \; p) $$<br>其中 $p$ 是奇素数。</p>
<p>经过简单推理很容易发现，在模 $p$ 的简化系中，二次剩余与二次非剩余各占一半。且容易知道，$1^2,2^2,\cdots,(\frac{p-1}{2})^2$ 都是二次剩余。</p>
<h3 id="Legendre__u7B26_u53F7"><a href="#Legendre__u7B26_u53F7" class="headerlink" title="Legendre 符号"></a>Legendre 符号</h3><span>$$\left( \frac{a}{p} \right) = \left\{ \begin{array}{cc} 1, &amp; a\; R\; p \\
0, &amp; p\;|\;a \\
-1, &amp; a\; \overline{R}\; p. \end{array} \right.$$</span><!-- Has MathJax -->
<h5 id="u5B9A_u74061__3C_21-_uFFFC4-_3E"><a href="#u5B9A_u74061__3C_21-_uFFFC4-_3E" class="headerlink" title="定理1   <span>$\quad -(\frac{a}{p}) (p-1)! \equiv a^{\frac{p-1}{2}} \;(mod \; p)$</span><!-- Has MathJax -->"></a>定理1   <span>$\quad -(\frac{a}{p}) (p-1)! \equiv a^{\frac{p-1}{2}} \;(mod \; p)$</span><!-- Has MathJax --></h5><p>Proof: 对于 $p\;|\;a$ 的情形，结论显然。下面考虑 $(p,a)=1$ 的情形，令<br>$$ S = \lbrace 1,2,\cdots,p-1 \rbrace $$<br>对任意的 $ x \in S $ 必存在唯一的 $ y \in S $ 为下面同余式的解<br>$$ yx \equiv a \; (mod \; p) $$</p>
<p>(i) 当 $ (\frac{a}{p}) = -1 $ 时，同余式<br>$$ x^2 = a \; (mod \; p) $$<br>无解，所以 $y \neq x $ .因此集合 $S$ 中的元素可以分成 $\frac{p-1}{2} $ 对，我们就有<br>$$ (p-1)! \equiv a^{\frac{p-1}{2}} \;(mod \; p) $$<br>(ii) 当 $ (\frac{a}{p}) = 1 $ 时，同余式<br>$$ x^2 = a \; (mod \; p) $$<br>有两个解 $x_0$ 和 $p - x_0$.在$S$中去掉这两个数外剩下$p-3$个数分出 $\frac{p-3}{2}$对，则有<br>$$ (p-1)! \equiv a^{\frac{p-3}{2}}x_0(p-x_0) \;(mod \; p) \equiv - a^{\frac{p-1}{2}} \;(mod \; p) $$ 证毕。</p>
<h5 id="u63A8_u8BBA2__28Wilson__u5B9A_u7406_29"><a href="#u63A8_u8BBA2__28Wilson__u5B9A_u7406_29" class="headerlink" title="推论2 (Wilson 定理)"></a>推论2 (Wilson 定理)</h5><p>$$ (p-1)! \equiv -1 \;(mod \; p) $$<br>Proof: 定理一 中取 $a=1$即可。</p>
<h5 id="u63A8_u8BBA3__28Euler__u5224_u522B_u6CD5_29"><a href="#u63A8_u8BBA3__28Euler__u5224_u522B_u6CD5_29" class="headerlink" title="推论3 (Euler 判别法)"></a>推论3 (Euler 判别法)</h5><p>$$ \left( \frac{a}{p} \right ) \equiv a^{\frac{p-1}{2}} \;(mod \;p ) $$<br>Proof: 由定理1和推论2显然。Euler判别法不仅有理论价值(下面都是推论3的直接推论)，由于快速幂的存在，使得Euler判别法在计算时有相当好的效果。</p>
<h5 id="u63A8_u8BBA4__28Format__u5C0F_u5B9A_u7406_29__u8BBE__24_28a_2Cp_29_3D1_24__2C_u5219"><a href="#u63A8_u8BBA4__28Format__u5C0F_u5B9A_u7406_29__u8BBE__24_28a_2Cp_29_3D1_24__2C_u5219" class="headerlink" title="推论4 (Format 小定理) 设 $(a,p)=1$ ,则"></a>推论4 (Format 小定理) 设 $(a,p)=1$ ,则</h5><p>$$ a^{p-1} \equiv 1 \;(mod \; p) $$</p>
<h5 id="u63A8_u8BBA5__24_5C_3B__28_5Cfrac_7B-1_7D_7Bp_7D_29__3D__28-1_29_5E_7B_5Cfrac_7Bp-1_7D_7B2_7D_7D_24"><a href="#u63A8_u8BBA5__24_5C_3B__28_5Cfrac_7B-1_7D_7Bp_7D_29__3D__28-1_29_5E_7B_5Cfrac_7Bp-1_7D_7B2_7D_7D_24" class="headerlink" title="推论5 $\; (\frac{-1}{p}) = (-1)^{\frac{p-1}{2}}$"></a>推论5 $\; (\frac{-1}{p}) = (-1)^{\frac{p-1}{2}}$</h5><h5 id="u63A8_u8BBA6__24_5C_3B__28_5Cfrac_7Bab_7D_7Bp_7D_29__3D_28_5Cfrac_7Ba_7D_7Bp_7D_29_28_5Cfrac_7Bb_7D_7Bp_7D_29__24"><a href="#u63A8_u8BBA6__24_5C_3B__28_5Cfrac_7Bab_7D_7Bp_7D_29__3D_28_5Cfrac_7Ba_7D_7Bp_7D_29_28_5Cfrac_7Bb_7D_7Bp_7D_29__24" class="headerlink" title="推论6 $\; (\frac{ab}{p}) =(\frac{a}{p})(\frac{b}{p}) $"></a>推论6 $\; (\frac{ab}{p}) =(\frac{a}{p})(\frac{b}{p}) $</h5><p>推论3说明，我们求 Legendre 符号，可以转化成求 $ (\frac{2}{p}),(\frac{q}{p}) $.</p>
<h5 id="u5B9A_u74067__24_5C_3B__28_5Cfrac_7B2_7D_7Bp_7D_29__3D__28-1_29_5E_7B_5Cfrac_7Bp_5E2-1_7D_7B8_7D_7D_24"><a href="#u5B9A_u74067__24_5C_3B__28_5Cfrac_7B2_7D_7Bp_7D_29__3D__28-1_29_5E_7B_5Cfrac_7Bp_5E2-1_7D_7B8_7D_7D_24" class="headerlink" title="定理7 $\; (\frac{2}{p}) = (-1)^{\frac{p^2-1}{8}}$"></a>定理7 $\; (\frac{2}{p}) = (-1)^{\frac{p^2-1}{8}}$</h5><p>Proof:<br>$$ 2^{\frac{p-1}{2}}(\frac{p-1}{2})! = 2 \cdot 4 \cdots (p-1) \equiv (\frac{p-1}{2})!(-1)^{1+2+\cdots+\frac{p-1}{2}}\;(mod \; p) $$<br>所以<br>$$ (\frac{2}{p}) \equiv 2^{\frac{p-1}{2}} \equiv (-1)^{\frac{p^2-1}{8}} \;(mod \; p) $$ 证毕。</p>
<h5 id="u5B9A_u74068__28Guass__u4E8C_u6B21_u4E92_u53CD_u5F8B_29__u8BBE__24p_2Cq_24__u4E3A_u4E0D_u540C_u7684_u5947_u7D20_u6570_uFF0C_u5219_u6709"><a href="#u5B9A_u74068__28Guass__u4E8C_u6B21_u4E92_u53CD_u5F8B_29__u8BBE__24p_2Cq_24__u4E3A_u4E0D_u540C_u7684_u5947_u7D20_u6570_uFF0C_u5219_u6709" class="headerlink" title="定理8 (Guass 二次互反律) 设 $p,q$ 为不同的奇素数，则有"></a>定理8 (Guass 二次互反律) 设 $p,q$ 为不同的奇素数，则有</h5><p>$$ (\frac{p}{q}) (\frac{q}{p}) = (-1)^{\frac{(p-1)(q-1)}{4}}$$</p>
<p>Proof: 略。</p>
<p>这里只是简介的纪录一下比较简洁精彩的部分。更多数论的内容还是很推荐潘承洞先生的书的。另外指数原根等一些知识也讲的特别简洁明了。下面给出我写的求原根的MATLAB代码。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span> = <span class="title">zhi_shu</span><span class="params">(g,n)</span></span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line"><span class="comment">% 输入：底数g和模n</span></span><br><span class="line"><span class="comment">% 输出：其指数</span></span><br><span class="line"><span class="comment">% 2016-2-16 in FDU by dna049</span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line">r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> d = <span class="number">1</span>:n</span><br><span class="line">    r = <span class="built_in">mod</span>(r*g,n);</span><br><span class="line">    <span class="keyword">if</span> r == <span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span> = <span class="title">phi_euler</span><span class="params">(n)</span></span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line"><span class="comment">% Euler function in number theory</span></span><br><span class="line"><span class="comment">% 2016-2-16 in FDU by dna049</span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isprime</span>(n)</span><br><span class="line">        x = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pn = <span class="built_in">primes</span>(n);</span><br><span class="line">        x = n;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = pn</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">mod</span>(n,<span class="built_in">i</span>) == <span class="number">0</span></span><br><span class="line">                n = n/<span class="built_in">i</span>;</span><br><span class="line">                <span class="keyword">while</span> <span class="built_in">mod</span>(n,<span class="built_in">i</span>) == <span class="number">0</span></span><br><span class="line">                    n = n/<span class="built_in">i</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                x = x/<span class="built_in">i</span>*(<span class="built_in">i</span>-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">i</span>&gt;n</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span> = <span class="title">yuan_gen_s</span><span class="params">(p)</span></span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line"><span class="comment">% 输入：素数p</span></span><br><span class="line"><span class="comment">% 输出：所有原根</span></span><br><span class="line"><span class="comment">% 2016-2-16 in FDU by dna049</span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line">d_now = p-<span class="number">1</span>;</span><br><span class="line">v = <span class="built_in">ones</span>(<span class="number">1</span>,p);</span><br><span class="line">v(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">v(p) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:p-<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> v(<span class="built_in">i</span>) == <span class="number">1</span></span><br><span class="line">        td = zhi_shu(<span class="built_in">i</span>,p);</span><br><span class="line">        <span class="keyword">if</span> td ~= p-<span class="number">1</span></span><br><span class="line">            tp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:td</span><br><span class="line">                tp = <span class="built_in">mod</span>(tp*<span class="built_in">i</span>-<span class="number">1</span>,p)+<span class="number">1</span>;</span><br><span class="line">                v(tp) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">d = <span class="number">1</span>:p;</span><br><span class="line">d = d(v==<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>从二次剩余问题，引入Legendre符号，由此一步步导出Guass互反律，最后延伸到Jacobi符号，整个步骤确实连贯优美，脍炙人口。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[自然数方幂和公式]]></title>
    <link href="http://yoursite.com/2016/01/21/%E8%87%AA%E7%84%B6%E6%95%B0%E6%96%B9%E5%B9%82%E5%92%8C%E5%85%AC%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/01/21/自然数方幂和公式/</id>
    <published>2016-01-21T11:16:51.000Z</published>
    <updated>2016-01-24T08:54:42.000Z</updated>
    <content type="html"><![CDATA[<p>关于自然数方幂和公式，网上的求解版本有很多种。这里介绍一种不为人知，十分简洁明了的求解方法，该公式并非原创，但是整个证明过程和方法完全原创。它的思想来源于我高中时在一本数学竞赛书中的数列例题(书名忘了…)，正因为一本本这样的书，让我大学选择了数学系，现在依然在学习数学。<br><a id="more"></a></p>
<h3 id="u82E5__24a_n__3D_n_28n-1_29_24__u6C42_u5176_u524D__24n_24__u9879_u548C_24S_n_24"><a href="#u82E5__24a_n__3D_n_28n-1_29_24__u6C42_u5176_u524D__24n_24__u9879_u548C_24S_n_24" class="headerlink" title="若 $a_n = n(n-1)$ 求其前 $n$ 项和$S_n$"></a>若 $a_n = n(n-1)$ 求其前 $n$ 项和$S_n$</h3><span>$$a_n = n(n-1) ＝
\frac{(n+1)n(n-1) -n(n-1)(n-2)}{3}$$</span><!-- Has MathJax -->
<p>所以<br><span>$$S_n =
\frac{(n+1)n(n-1)}{3}$$</span><!-- Has MathJax --></p>
<h3 id="u82E5_3C_21-_uFFFC2-_3E_uFF0C_u5219_u5176_u524D__24n_24__u9879_u548C_3C_21-_uFFFC3-_3E"><a href="#u82E5_3C_21-_uFFFC2-_3E_uFF0C_u5219_u5176_u524D__24n_24__u9879_u548C_3C_21-_uFFFC3-_3E" class="headerlink" title="若<span>$a_n = A_n ^p$</span><!-- Has MathJax -->，则其前 $n$ 项和<span>$S_n ＝ \frac{ A_{n+1} ^{p+1}}{p+1}$</span><!-- Has MathJax -->"></a>若<span>$a_n = A_n ^p$</span><!-- Has MathJax -->，则其前 $n$ 项和<span>$S_n ＝ \frac{ A_{n+1} ^{p+1}}{p+1}$</span><!-- Has MathJax --></h3><span>$$a_n = A_n ^p ＝
\frac{A_{n+1} ^{p+1} -A_n ^{p+1}}{p+1}$$</span><!-- Has MathJax -->
<p>所以<br><span>$$S_n =
\frac{A_{n+1} ^{p+1}}{p+1}$$</span><!-- Has MathJax --></p>
<p>由上面的结论下面我们来直对主题。</p>
<h3 id="u6C42__241_5E2+2_5E2+__5Cdots_+_n_5E2_24"><a href="#u6C42__241_5E2+2_5E2+__5Cdots_+_n_5E2_24" class="headerlink" title="求 $1^2+2^2+ \dots + n^2$"></a>求 $1^2+2^2+ \dots + n^2$</h3><p>由<br>$$ n^2 = n(n-1) + n $$<br>知<br>$$1^2+2^2+ \dots + n^2 = \frac{(n+1)n(n-1)}{3} + \frac{(n+1)n}{2} = \frac{n(n+1)(2n+1)}{6}$$</p>
<h3 id="u6C42_241_5Ep+2_5Ep+__5Cdots_+_n_5Ep_24"><a href="#u6C42_241_5Ep+2_5Ep+__5Cdots_+_n_5Ep_24" class="headerlink" title="求$1^p+2^p+ \dots + n^p$"></a>求$1^p+2^p+ \dots + n^p$</h3><p>设<br><span>$$n^p =
a_p A_n ^p + a_{p-1} A_n ^{p-1} + a_{p-2} A_n ^{p-2} + \cdots + a_1 A_n ^1$$</span><!-- Has MathJax --><br>则<br><span>$$1^p+2^p+ \dots + n^p =
\frac{a_p A_{n+1} ^{p+1}}{p+1} + \frac{a_{p-1} A_{n+1} ^{p}}{p} + \cdots + \frac{a_1 A_{n+1} ^2}{2}$$</span><!-- Has MathJax --><br>因此问题的关键就转化成如何求解数组 $a_k ,k=1,2,\cdots,p$<br>我们发现当 $n＝k$ 时成立<br><span>$$k^p =
a_k A_k ^k + a_{k-1} A_k ^{k-1} + \cdots a_1 A_{k} ^1$$</span><!-- Has MathJax --><br>令 $b_k = k! \cdot a_k$ 则<br><span>$$k^p = 
b_k + b_{k-1} C_k ^{k-1} + \cdots b_1 C_{k} ^1$$</span><!-- Has MathJax --><br>即<br><span>$$k^p = 
\sum _{j=1} ^k b_j C _{k} ^j$$</span><!-- Has MathJax --><br>应用二项式反演知(可参考<a href="http://dna049.com/2016/01/21/两类反演公式及其矩阵形式/" target="_blank" rel="external">我的博文</a>)<br><span>$$b_k = 
\sum _{j=1} ^k (-1)^{k-j} C _{k} ^j k^p$$</span><!-- Has MathJax --><br>因此最终,我们有公式</p>
<span>$$1^p+2^p+ \dots + n^p =
\sum _{k=1} ^p \; (\; \sum_{j=1} ^ {k} (-1)^{k-j} C_k^j j^p \;) \; C _{n+1} ^{k+1}$$</span><!-- Has MathJax --> 
<p>本博文完全由作者(dna0.49)原创于2016年1月21号，转载或引用请注明<a href="http://dna049.com" target="_blank" rel="external">http://dna049.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于自然数方幂和公式，网上的求解版本有很多种。这里介绍一种不为人知，十分简洁明了的求解方法，该公式并非原创，但是整个证明过程和方法完全原创。它的思想来源于我高中时在一本数学竞赛书中的数列例题(书名忘了…)，正因为一本本这样的书，让我大学选择了数学系，现在依然在学习数学。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[两类反演公式及其矩阵形式]]></title>
    <link href="http://yoursite.com/2016/01/21/%E4%B8%A4%E7%B1%BB%E5%8F%8D%E6%BC%94%E5%85%AC%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/01/21/两类反演公式及其矩阵形式/</id>
    <published>2016-01-21T09:31:20.000Z</published>
    <updated>2016-01-26T02:19:43.000Z</updated>
    <content type="html"><![CDATA[<p>在上一篇<a href="http://dna049.com/2016/01/20/数论函数的Dirichlet积/" target="_blank" rel="external">博文</a>中，介绍过数论中的 Mobius 反演公式，让我想起了另一个经典的反演公式－－－二项式反演公式。然而本质上反演公式就是矩阵求逆的过程。只是他们的逆有很简单的形式，因此就有了这样两个反演公式而已。<br><a id="more"></a></p>
<p>Mobius 反演在上一篇博客中已经提及，现在着重提一下二项式反演公式，这个公式让我在2014年ACM－ICPC亚洲区域赛西安站拿银，当时<a href="2014acmicpc-asia-xian-regional-contest.pdf">F题</a>答案直接算需要$n^3$复杂度，而利用二项式反演公式后，可以在$n^2$复杂度内完美解决。1A过题，感觉超爽。</p>
<h3 id="u53CD_u6F14_u516C_u5F0F_u4E0E_u5176_u77E9_u9635_u5F62_u5F0F"><a href="#u53CD_u6F14_u516C_u5F0F_u4E0E_u5176_u77E9_u9635_u5F62_u5F0F" class="headerlink" title="反演公式与其矩阵形式"></a>反演公式与其矩阵形式</h3><p>由<br><span>$$\sum _{r = 1} ^n a _{n,r} f(r) 
= g(n)$$</span><!-- Has MathJax --><br>其中$g(n)$已知，解出$f(n)$<br><span>$$f(n) = 
\sum _{r = 1} ^n b _{n,r} g(r)$$</span><!-- Has MathJax --><br>为其反演公式，也称上面两式互为反演公式。</p>
<p>令<br><span>$$A = \left( \begin{matrix} a _{11} &amp; &amp;  \\
a _{21} &amp; a _{22} &amp; \\
\cdots &amp; \cdots &amp; \ddots &amp; \\
a _{n1} &amp; a _{n2} &amp; \cdots &amp; a _{nn} \\
\end{matrix} \right) 
\qquad
B = \left( \begin{matrix} b _{11} &amp; &amp;  \\
b _{21} &amp; b _{22} &amp; \\
\cdots &amp; \cdots &amp; \ddots &amp; \\
b _{n1} &amp; b _{n2} &amp; \cdots &amp; b _{nn} \\
\end{matrix} \right)$$</span><!-- Has MathJax --></p>
<p>则上述反演公式本质上就是求矩阵$A$的逆$B$.</p>
<h3 id="u4E8C_u9879_u5F0F_u53CD_u6F14_u516C_u5F0F"><a href="#u4E8C_u9879_u5F0F_u53CD_u6F14_u516C_u5F0F" class="headerlink" title="二项式反演公式"></a>二项式反演公式</h3><p>若<br><span>$$g(n) = 
\sum _{r = s} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) f(r)$$</span><!-- Has MathJax --><br>其中 $s \geq 0$ 则<br><span>$$f(n) 
= \sum _{r = s} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) g(r)$$</span><!-- Has MathJax --></p>
<p>Proof: 要证明反演公式，只需证明，对应的矩阵 $A$ 和 $B$ 互为逆即可. 令 $C = A*B$ 则<br><span>$$\begin{align}
c _{ij} = \sum _{k=1} ^n a _{ik} b _{kj} &amp; = \sum _{k =j} ^ i \left(\begin{matrix} i \\ k\end{matrix}\right) (-1)^{k-j} \left(\begin{matrix} k \\ j\end{matrix}\right) = 
\sum _{k=0} ^ {i-j} \left(\begin{matrix} i \\ k+j\end{matrix}\right) (-1)^k \left(\begin{matrix} k+j \\ j\end{matrix}\right) \\
&amp; = \left(\begin{matrix} i \\ j\end{matrix}\right) \sum _{k=0} ^ {i-j} (-1)^k \left(\begin{matrix} i-j \\ k\end{matrix}\right) = \left\{ \begin{array}{ll} 1,&amp; i=j \\  0,&amp; i&gt;j\end{array} \right.
\end{align}$$</span><!-- Has MathJax --><br>证毕。</p>
<h3 id="u4E24_u7C7B_u53CD_u6F14_u516C_u5F0F_u7684_u5E94_u7528"><a href="#u4E24_u7C7B_u53CD_u6F14_u516C_u5F0F_u7684_u5E94_u7528" class="headerlink" title="两类反演公式的应用"></a>两类反演公式的应用</h3><p>这两类反演公式在组合数学和数论中都有诸多应用，这里简单的提几个。</p>
<h5 id="28_u9519_u6392_u95EE_u9898_29__u5728__24n_24__u4E2A_u6570_u5B57__241_2C2_2C_5Cdots_2Cn_24__u5F62_u6210__24n_21_24__u4E2A_u6392_u5217__24a_1a_2__5Cdots_a_n_24__u4E2D_u6EE1_u8DB3__24a_i__5Cneq_i_24__u7684_u6392_u5217_u6709_u591A_u5C11_u4E2A_uFF1F"><a href="#28_u9519_u6392_u95EE_u9898_29__u5728__24n_24__u4E2A_u6570_u5B57__241_2C2_2C_5Cdots_2Cn_24__u5F62_u6210__24n_21_24__u4E2A_u6392_u5217__24a_1a_2__5Cdots_a_n_24__u4E2D_u6EE1_u8DB3__24a_i__5Cneq_i_24__u7684_u6392_u5217_u6709_u591A_u5C11_u4E2A_uFF1F" class="headerlink" title="(错排问题) 在 $n$ 个数字 $1,2,\dots,n$ 形成 $n!$ 个排列 $a_1a_2 \dots a_n$ 中满足 $a_i \neq i$ 的排列有多少个？"></a>(错排问题) 在 $n$ 个数字 $1,2,\dots,n$ 形成 $n!$ 个排列 $a_1a_2 \dots a_n$ 中满足 $a_i \neq i$ 的排列有多少个？</h5><p>不妨设答案为 <span>$D_n$</span><!-- Has MathJax --> ,则可以看出恰好有 $r$ 个 <span>$a_i =i$</span><!-- Has MathJax -->的排列数为<span>$\left(\begin{matrix} n \\ r\end{matrix}\right) D_{n-r}$</span><!-- Has MathJax -->,因此<br><span>$$n! =
\sum _{r = 0} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) D_{n-r}$$</span><!-- Has MathJax --><br>因此<br><span>$$D_n ＝ 
\sum _{r = 0} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) r! = n! \sum _{r=0} ^n \frac{(-1)^r}{r!}$$</span><!-- Has MathJax --></p>
<h5 id="28_u6EE1_u5C04_u4E2A_u6570_29__u6C42m_u5143_u96C6A_u5230n_u5143_u96C6B_u7684_u6EE1_u8EAB_u7684_u4E2A_u6570g_28m_2Cn_29"><a href="#28_u6EE1_u5C04_u4E2A_u6570_29__u6C42m_u5143_u96C6A_u5230n_u5143_u96C6B_u7684_u6EE1_u8EAB_u7684_u4E2A_u6570g_28m_2Cn_29" class="headerlink" title="(满射个数) 求m元集A到n元集B的满身的个数g(m,n)"></a>(满射个数) 求m元集A到n元集B的满身的个数g(m,n)</h5><p>类似于错排的思路，我们有<br><span>$$n^m =
\sum _{r = 1} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) g(m,r)$$</span><!-- Has MathJax --><br>于是<br><span>$$g(m,n) = 
\sum _{r = 1} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) r^m$$</span><!-- Has MathJax --></p>
<h5 id="Mobius_u53CD_u6F14_u5728_u53EF_u91CD_u590D_u5706_u6392_u5217_u4E2D_u6709_u91CD_u8981_u5E94_u7528_uFF0C_u8FD9_u91CC_u5C31_u4E0D_u8BF4_u4E86_u3002"><a href="#Mobius_u53CD_u6F14_u5728_u53EF_u91CD_u590D_u5706_u6392_u5217_u4E2D_u6709_u91CD_u8981_u5E94_u7528_uFF0C_u8FD9_u91CC_u5C31_u4E0D_u8BF4_u4E86_u3002" class="headerlink" title="Mobius反演在可重复圆排列中有重要应用，这里就不说了。"></a>Mobius反演在可重复圆排列中有重要应用，这里就不说了。</h5><h3 id="Mobius__u77E9_u9635"><a href="#Mobius__u77E9_u9635" class="headerlink" title="Mobius 矩阵"></a>Mobius 矩阵</h3><p>由 Mobius 反演公式对应的矩阵我们有,若<br><span>$$a _{ij} = \left\{ \begin{array}{cc} 1, &amp; j|i \\
0, &amp; else. \end{array} \right.$$</span><!-- Has MathJax --><br>则，其逆矩阵为<br><span>$$b _{ij} = \left\{ \begin{array}{cc} \mu (\frac{i}{j}), &amp; j|i \\
0, &amp; else. \end{array} \right.$$</span><!-- Has MathJax --></p>
<p>本文参考了<a href="http://www.douban.com/note/480023639/?type=like" target="_blank" rel="external">豆瓣</a>和<a href="http://wenku.baidu.com/link?url=0m3D-588KfEUvocmKGoW5X4z5SHrEKVOaqfLoTeRtJaJcG6oDEUh2QEbJmNa1p2OTkqFLCqhfhM-RsoOI2fkutlqL9q3xgJhIAic4HumI5W" target="_blank" rel="external">百度文库</a>以及 许胤龙，孙淑玲《组合数学引论》。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇<a href="http://dna049.com/2016/01/20/数论函数的Dirichlet积/">博文</a>中，介绍过数论中的 Mobius 反演公式，让我想起了另一个经典的反演公式－－－二项式反演公式。然而本质上反演公式就是矩阵求逆的过程。只是他们的逆有很简单的形式，因此就有了这样两个反演公式而已。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[My Math work edited by LaTex]]></title>
    <link href="http://yoursite.com/2016/01/20/My-Math-work-edited-by-LaTex/"/>
    <id>http://yoursite.com/2016/01/20/My-Math-work-edited-by-LaTex/</id>
    <published>2016-01-20T13:09:36.000Z</published>
    <updated>2016-01-19T05:09:40.000Z</updated>
    <content type="html"><![CDATA[<p>This blog makes a record of my math work and will be update frequently.Click to view or download it.</p>
<a id="more"></a>
<h4 id="Here_are_PDF_version_of_my_math_work"><a href="#Here_are_PDF_version_of_my_math_work" class="headerlink" title="Here are PDF version of my math work"></a>Here are PDF version of my math work</h4><p><a href="1.pdf">Config of ACM-ICPC</a></p>
<p><a href="2.pdf">Some results about matrix</a></p>
<p><a href="3.pdf">Decomposition of 1 by 1/n </a></p>
<p><a href="4.pdf">Nowhere dense set and frist category set</a></p>
<p><a href="5.pdf">Relationship between Spectral Radius ,Numerical Radius and Spectral norm</a></p>
<p><a href="6.pdf">Some results about group</a></p>
<p><a href="7.pdf">The inverse of I-ba and I-ab</a></p>
<p><a href="8.pdf">example of function that only derivable on one point</a></p>
<p><a href="0.pdf">undergraduate graduation paper</a></p>
<h4 id="Here_are_Tex_version_of_my_math_work"><a href="#Here_are_Tex_version_of_my_math_work" class="headerlink" title="Here are Tex version of my math work"></a>Here are Tex version of my math work</h4><p><a href="1.tex">Config of ACM-ICPC.tex</a></p>
<p><a href="2.tex">Some results about matrix.tex</a></p>
<p><a href="3.tex">Decomposition of 1 by 1/n.tex</a></p>
<p><a href="4.tex">Nowhere dense set and frist category set.tex</a></p>
<p><a href="5.tex">Relationship between Spectral Radius ,Numerical Radius and Spectral norm.tex</a></p>
<p><a href="6.tex">Some results about group.tex</a></p>
<p><a href="7.tex">The inverse of I-ba and I-ab.tex</a></p>
<p><a href="8.tex">example of function that only derivable on one point.tex</a></p>
<h3 id="LaTex_is_a_wonderful_tool_for_Mathematics"><a href="#LaTex_is_a_wonderful_tool_for_Mathematics" class="headerlink" title="LaTex is a wonderful tool for Mathematics"></a>LaTex is a wonderful tool for Mathematics</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>This blog makes a record of my math work and will be update frequently.Click to view or download it.</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[数论函数的 Dirichlet 积]]></title>
    <link href="http://yoursite.com/2016/01/20/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E7%9A%84Dirichlet%E7%A7%AF/"/>
    <id>http://yoursite.com/2016/01/20/数论函数的Dirichlet积/</id>
    <published>2016-01-20T12:09:26.000Z</published>
    <updated>2016-01-24T08:56:27.000Z</updated>
    <content type="html"><![CDATA[<p>最近重温潘承洞老先生的《数论基础》(现代数学基础丛书34)，确实是经典中的经典。以现代的眼光看数论函数，使得分析问题更加简洁本质，而这些都要归功于 Dirichlet 积的引入。<br><a id="more"></a></p>
<h3 id="u5E38_u89C1_u6570_u8BBA_u51FD_u6570"><a href="#u5E38_u89C1_u6570_u8BBA_u51FD_u6570" class="headerlink" title="常见数论函数"></a>常见数论函数</h3><p>为了更好的介绍 Dirichlet 积，先引入一些记号，数论函数是指定义于全体正整数集上的函数。</p>
<ol>
<li>$u(n) \equiv 1$ </li>
<li>$e(n) = n$</li>
<li><span>$I(n) = \left\{\begin{array}{ll} 1, &amp; n=1, \\ 0, &amp; n&gt;1. \end{array} \right.$</span><!-- Has MathJax --></li>
<li>n的所有正除数的个数 $d(n)$.<br>$$ d(n)= \sum_{d|n} 1 = (a_1+1)(a_2+1) \cdots (a_n+1), \; n=p_1^{a_1} \cdots p_s^{a_s} $$</li>
<li>n的全部素因子的个数（按重数计）$ \Omega(n) $<span>$$\begin{array}{ll} \Omega(1)=0 &amp; \\
\Omega(n) = a_1 + a_2+ \cdots a_n, &amp; n=p_1^{a_1} \cdots p_s^{a_s} \end{array}$$</span><!-- Has MathJax --></li>
<li>n的不同素因子的个数 $\omega(n)$  <span>$$\begin{array}{ll} \omega(1)=0 &amp; \\
\omega(n) = s, &amp; n=p_1^{a_1} \cdots p_s^{a_s} \end{array}$$</span><!-- Has MathJax --></li>
<li>n的正除数的幂和函数 $\sigma_{\lambda}(n)$,<span>$$\sigma_{\lambda}(n) = \sum_{d|n}
d^{\lambda}$$</span><!-- Has MathJax --></li>
<li>所有不超过n且和n互素的正整数的个数 $\phi(n)$<span>$$\phi(n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\
(d,n)=1 \end{array} } 1$$</span><!-- Has MathJax -->
$\phi(n)$ 称之为Euler函数。</li>
<li>Mobius 函数 $\mu(n)$<span>$$\mu(n) = \left\{\begin{array}{ll} 1, &amp; n=1, \\ (-1)^s, &amp; n=p_1p_2 \cdots p_s, \; p_1 &lt; p_2&lt; \cdots &lt; p_s. \\
0, &amp; else. \end{array} \right.$$</span><!-- Has MathJax --></li>
<li>Mangoldt函数 $\Lambda(n)$<span>$$\Lambda(n) = \left\{\begin{array}{ll} \log p, &amp; n= p^k, k \geq 1\\
0, &amp; else. \end{array} \right.$$</span><!-- Has MathJax --></li>
<li>Liouville 函数 $\lambda(n)$<br>$$ \lambda(n) = (-1)^{\Omega(n)} $$</li>
<li>Euler函数的推广(自创 dna0.49 ) $ \phi _{\lambda}(n)$<span>$$\phi _{\lambda} (n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\
(d,n)=1 \end{array} } d^{\lambda}$$</span><!-- Has MathJax -->
当 $\lambda = 0$ 时即为Euler函数。</li>
</ol>
<p>用下面的 Dirichlet 积的概念，大家就会对上面常见的数论函数有更深刻的认识。</p>
<h3 id="Dirichlet__u79EF"><a href="#Dirichlet__u79EF" class="headerlink" title="Dirichlet 积"></a>Dirichlet 积</h3><p>设$f(n)$,$g(n)$是两个数论函数，则<br>$$ h(n) = \sum_{d|n} f(d)g(\frac{n}{d}) $$<br>称为$f(n)$和$g(n)$的 Dirichlet 积,记作$h=f*g$.</p>
<h5 id="u5B9A_u7406_u4E00_Dirichlet__u79EF_u6EE1_u8DB3_u4EA4_u6362_u5F8B_u548C_u7ED3_u5408_u5F8B_u5373"><a href="#u5B9A_u7406_u4E00_Dirichlet__u79EF_u6EE1_u8DB3_u4EA4_u6362_u5F8B_u548C_u7ED3_u5408_u5F8B_u5373" class="headerlink" title="定理一 Dirichlet 积满足交换律和结合律即"></a>定理一 Dirichlet 积满足交换律和结合律即</h5><span>$$f * g = 
g * f$$</span><!-- Has MathJax -->
<span>$$(f*g)*h = 
f*(g*h)$$</span><!-- Has MathJax -->
<p>由定义上式显然。</p>
<h5 id="u5B9A_u7406_u4E8C_Dirichlet__u79EF_u7684_u5E7A_u5143_u5B58_u5728_u4E3A__24I_28n_29_24"><a href="#u5B9A_u7406_u4E8C_Dirichlet__u79EF_u7684_u5E7A_u5143_u5B58_u5728_u4E3A__24I_28n_29_24" class="headerlink" title="定理二 Dirichlet 积的幺元存在为 $I(n)$"></a>定理二 Dirichlet 积的幺元存在为 $I(n)$</h5><p>直接计算验算即知。</p>
<ul>
<li>由定理一和二知。数论函数全体关于 Dirichlet 积构成了一个含幺交换半群(Commutative Monoid) </li>
<li>由抽象代数的基本知识知道 Monoid 中的元如果存在逆元必然唯一，证明也是显然的 </li>
<li>现在的问题就是这个 Monoid 那些元有逆元( Dirichlet 逆，以下简称逆)。或者说一个数论函数可逆的充要条件是什么。</li>
</ul>
<p>实际上，我们有如下结论</p>
<h5 id="u5B9A_u7406_u4E09__u6570_u8BBA_u51FD_u6570__24f_24__u53EF_u9006_u7684_u5145_u8981_u6761_u4EF6_u662F__24f_281_29__5Cneq_0_24-_u6B64_u65F6_u5B83_u7684_u9006_u5143_u4E3A"><a href="#u5B9A_u7406_u4E09__u6570_u8BBA_u51FD_u6570__24f_24__u53EF_u9006_u7684_u5145_u8981_u6761_u4EF6_u662F__24f_281_29__5Cneq_0_24-_u6B64_u65F6_u5B83_u7684_u9006_u5143_u4E3A" class="headerlink" title="定理三 数论函数 $f$ 可逆的充要条件是 $f(1) \neq 0$.此时它的逆元为"></a>定理三 数论函数 $f$ 可逆的充要条件是 $f(1) \neq 0$.此时它的逆元为</h5><span>$$f^{-1} (1) = \frac{1}{f(1)},\quad
f^{-1} (n) = \frac{-1}{f(1)} \sum _{d|n,\, d&lt;n} f(\frac{n}{d})f^{-1}(d),\; n&gt;1$$</span><!-- Has MathJax -->
<p>证明是显然的，验算即知。</p>
<ul>
<li>至此从抽象的层次已经对数论函数的 Dirichlet 积有了一个清晰的认识，下面用这套语言考虑我们的常见函数 </li>
</ul>
<h5 id="u5B9A_u7406_u56DB_Mobius__u51FD_u6570__24_5Cmu_28n_29_24__u662F__24u_28n_29_24__u7684_u9006_u3002"><a href="#u5B9A_u7406_u56DB_Mobius__u51FD_u6570__24_5Cmu_28n_29_24__u662F__24u_28n_29_24__u7684_u9006_u3002" class="headerlink" title="定理四 Mobius 函数 $\mu(n)$ 是 $u(n)$ 的逆。"></a>定理四 Mobius 函数 $\mu(n)$ 是 $u(n)$ 的逆。</h5><p>即<br><span>$$\sum_{ d|n } \mu(n) = \left\{ \begin{array}{ll}  1, &amp; n=1, \\
0, &amp; n&gt;1. \end{array} \right.$$</span><!-- Has MathJax --></p>
<p>$n=1$ 时显然，不妨设 $n = p_1^{a_1} p_2^{a_2} \cdots p_s^{a_s}$ 则由 $\mu(n)$ 的定义<br><span>$$\begin{align}
\sum_{ d|n } \mu(n) &amp; = \mu(1) + \mu(p_1) + \mu(p_2) + \cdots +\mu(p_s) + \cdots + \mu(p_1 p_2) + \cdots \\
&amp; \quad + \mu(p_{s-1}p_s) + \cdots \mu(p_1 p_2 \cdots p_s) \\
&amp; =  1 + \begin{matrix} s \\ 1\end{matrix} (-1) + \begin{matrix} s \\ 2\end{matrix} (-1)^2 + \cdots + \begin{matrix} s \\ s\end{matrix} (-1)^s = (1-1)^s = 0 \end{align}$$</span><!-- Has MathJax --></p>
<ul>
<li>由此可见，原来看上去复杂的不知所以然的 Mobius 函数本质上是恒为1的函数的 Dirichlet 逆元。</li>
</ul>
<h5 id="u5B9A_u4E49_u4E94__u82E5__24F_3Df*u_24__u5219_u79F0_24F_24__u662F_24f_24__u7684_Mobius__u53D8_u6362_uFF0C_u5373"><a href="#u5B9A_u4E49_u4E94__u82E5__24F_3Df*u_24__u5219_u79F0_24F_24__u662F_24f_24__u7684_Mobius__u53D8_u6362_uFF0C_u5373" class="headerlink" title="定义五 若 $F=f*u$ 则称$F$ 是$f$ 的 Mobius 变换，即"></a>定义五 若 $F=f*u$ 则称$F$ 是$f$ 的 Mobius 变换，即</h5><p>$$ F(n) = \sum_{d|n} f(d) $$</p>
<p>显然此时我们有 $ f=F * \mu $,称$f$ 是$F$ 的 Mobius 反变换。<br>实际上，这就是我们常说的 Mobius 反演公式。<br><span>$$F(n) = \sum_{d|n} f(d) \Longleftrightarrow f(n) =
\sum_{d|n} F(d) \mu(\frac{n}{d})$$</span><!-- Has MathJax --></p>
<p>Mobius 变换的例子</p>
<ol>
<li>$I(n)$ 是 $\mu(n)$ 的 Mobius 变换</li>
<li>$d(n)$ 是 $u(n)$ 的 Mobius 变换</li>
<li>$e(n)$ 是 $\phi(n)$ 的 Mobius 变换</li>
<li>$\log n$ 是 $\Lambda(n)$ 的 Mobius 变换</li>
</ol>
<p>前两个是显然的，后面两个证明如下。</p>
<span>$$n = \sum _{i=1} ^n 1 = 
\sum _{d|n} \sum_{(n,i) = d} 1 =
\sum _{d|n} \sum_{(\frac{n}{d},k)=1} 1 =
\sum _{d|n} \phi(\frac{n}{d}) = \sum _{d|n} \phi(d)$$</span><!-- Has MathJax -->
<p>因此<br><span>$$\phi(n) = \sum _{d|n} \mu(d) \frac{n}{d} =
n \sum _{d|n} \frac{\mu(d)}{d}$$</span><!-- Has MathJax --><br>另外我们还有一个证明方式</p>
<span>$$\phi(n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\
(d,n)=1 \end{array} } 1 ＝ \sum_{1 \leq d \leq n} \sum_ {l|(d,n)} \mu(l) = \sum _{l|n} \mu(l) \sum _{1 \leq d \leq n , l|d} 1 = \sum _{l|n} \mu(l) \frac{n}{l}$$</span><!-- Has MathJax -->
<ul>
<li>上述两种证明都是两种常用处理数论函数的技术手段。</li>
</ul>
<p>至于 $\log n$ 是 $\Lambda(n)$ 的 Mobius 变换的证明只需验算即知。</p>
<p>用上面所说的技术，我们来考虑一下推广的Euler函数 $\phi _{\lambda}$</p>
<span>$$\sum _{i=1} ^n i^{\lambda} = 
\sum _{d|n} \sum_{(n,i) = d} i^{\lambda}  =
\sum _{d|n} d^{\lambda} \sum_{(\frac{n}{d},k)=1} k^{\lambda}  = 
\sum _{d|n} d^{\lambda} \phi _{\lambda} (\frac{n}{d}) = 
n^{\lambda} * \phi _{\lambda}$$</span><!-- Has MathJax -->
<h5 id="u53EF_u4E58_u51FD_u6570"><a href="#u53EF_u4E58_u51FD_u6570" class="headerlink" title="可乘函数"></a>可乘函数</h5><p>寻找不变量一直是数学关心的问题，变化中的不变量，可以大大简化运算，并且反过来刻画了变化。具体说，寻找 Dirichlet 积不变量一方面对于那些不变量，可以简化它们操作，另一方面，由于 Dirichlet 积保持这些性质也就刻画了 Dirichlet 本身。其中这样的一个不变量就是可乘函数。</p>
<p>设 $f(n)$ 是定义在全体自然数上不恒为0的数论函数，若它满足条件<br>$$ f(mn) = f(m) f(n), \quad (m,n)=1 $$<br>则称之为可乘函数。若对任意正整数 $m,n$ 恒有<br>$$ f(mn) = f(m) f(n) $$<br>则称之为完全可乘函数。</p>
<p>可乘函数例子：    $\mu(n)$, $d(n)$.<br>完全可乘函数例子：    $n^{\lambda}$, $I(n)$.</p>
<ul>
<li>显然(完全)可乘函数的的积，倒数(如果有意义的话)都是(完全)可乘函数。</li>
</ul>
<h5 id="u5B9A_u7406_u516D__u53EF_u4E58_u51FD_u6570__24f_28n_29_24__u6709_u5982_u4E0B_u6027_u8D28_uFF1A"><a href="#u5B9A_u7406_u516D__u53EF_u4E58_u51FD_u6570__24f_28n_29_24__u6709_u5982_u4E0B_u6027_u8D28_uFF1A" class="headerlink" title="定理六 可乘函数 $f(n)$ 有如下性质："></a>定理六 可乘函数 $f(n)$ 有如下性质：</h5><ol>
<li>$f(1)=1$</li>
<li>$f(n)=f(p_1^{a_1}) f(p_2)^{a_2} \cdots f(p_s)^{a_s}, \quad n = p_1^{a_1} p_2^{a_2} \cdots p_s^{a_s}$</li>
<li>$f(n)$ 为完全可乘的充要条件是对任意的 $p$ 和 $k \geq 1$ 恒有<br> $$ f(p^k) = f ^k (p) $$</li>
<li>$f((m,n)[m,n])=f(m)f(n)$</li>
<li>$f$的逆元必然存在(形式上更加简单)</li>
</ol>
<p>上述定理的证明是显然的，结论是重要的。</p>
<h5 id="u5B9A_u7406_u4E03_Dirchlet__u79EF__u4FDD_u6301_u53EF_u4E58_u6027"><a href="#u5B9A_u7406_u4E03_Dirchlet__u79EF__u4FDD_u6301_u53EF_u4E58_u6027" class="headerlink" title="定理七 Dirchlet 积 保持可乘性"></a>定理七 Dirchlet 积 保持可乘性</h5><ol>
<li>若 $f$ 可乘, $g$ 可乘, 则 <span>$h=f*g$</span><!-- Has MathJax --> 可乘;</li>
<li>若 $g$ 可乘, <span>$h=f*g$</span><!-- Has MathJax --> 可乘，则 $f$ 可乘.</li>
</ol>
<p>Proof: </p>
<ol>
<li><p>若 $f$ 可乘, $g$ 可乘, 则对任意满足 $(m,n)=1$ 的正整数 $m,n$,对于 $mn$ 的每一个正因子 $d$ 可以分解为 $d=d_1 d_2$ 的形式, 其中$(d_1,d_2)=1,d_1|m,d_2|n$ </p>
<span>$$h(mn) = \sum _{d|mn} f(d)g(\frac{mn}{d}) =
\sum _{d_1|m} f(d_1)g(\frac{m}{d_1}) \sum _{d_2|n} f(d_2)g(\frac{n}{d_2}) = h(m)h(n)$$</span><!-- Has MathJax -->
</li>
<li><p>反证，若$f$不可乘，则可以推出$h$不可乘即可。若$f$不可乘,则必存在$m,n$,$(m,n)=1$ 但是<br>$$ f(mn) \neq f(m)f(n) $$<br>若 $mn=1$ , 则 $f(1) \neq f(1) f(1)$ 知 $f(1) \neq 1$. 因此 $h(1)=f(1)g(1)=f(1) \neq 1$ 矛盾于$h$可乘。<br>我们选取满足上述性质的最小正整数$mn$,即当$d_1d_2&lt;mn$是恒有<br>$$ f(d_1d_2) = f(d_1)f(d_2),\quad (d_1,d_2)=1 $$<br>由$h$的定义</p>
<span>$$\begin{align}
h(mn) = \sum _{d|mn} f(d) g(\frac{mn}{d}) &amp; = 
\sum _{d_1|m} f(d_1) g(\frac{m}{d_1}) \sum _{d_2|m} f(d_2)g(\frac{n}{d_2})-f(m)f(n) +f(mn) \\
&amp; = h(m)h(n) -f(m)f(n) + f(mn) \neq h(m)h(n)
\end{align}$$</span><!-- Has MathJax -->
<p>证毕。</p>
</li>
</ol>
<ul>
<li>Dirichlet 积一般不保持完全可乘性。</li>
</ul>
<p>由定理六和七，我们有如下推论: 若 $F$ 是 $f$ 的 Mobius 变换，则</p>
<ol>
<li>$f$ 可乘 $\Longleftrightarrow$ $F$ 可乘</li>
<li>$f$ 可乘，则<span>$$F(n) = \sum_{d|n} f(d) = 
\prod _{p^a || n} (1+ f(p)+\cdots f(p^a))$$</span><!-- Has MathJax --></li>
<li>$f$ 可乘，则 <span>$$\sum _{d|n} \mu(d) f(d) = 
\prod _{p | n} (1 - f(p))$$</span><!-- Has MathJax -->
</li>
</ol>
<ul>
<li>上面1是定理7.1的直接推论，2可由定理6.2的直接推论，3是2的直接推论。由3我们可以得到著名的欧拉公式：<span>$$\phi(n) = n \sum _{d|n} \frac{\mu(d)}{d} ＝ 
n \prod _{p|n} (1-\frac{1}{p})$$</span><!-- Has MathJax -->
</li>
</ul>
<h4 id="u5B8C_u5168_u53EF_u4E58_u7684_u9006"><a href="#u5B8C_u5168_u53EF_u4E58_u7684_u9006" class="headerlink" title="完全可乘的逆"></a>完全可乘的逆</h4><p>由于可乘函数满足 $f(1)=1$ 因此可乘函数的逆相对而言更加简单，并且它的逆也是可乘函数。但是计算逆的过程仍然很复杂，但是完全可乘函数的逆却特别简单。</p>
<h5 id="u5B9A_u7406_u516B__u8BBE__24f_24__u53EF_u4E58_uFF0C_u5219_24f_24__u5B8C_u5168_u53EF_u4E58_u7684_u5145_u8981_u6761_u4EF6_u662F"><a href="#u5B9A_u7406_u516B__u8BBE__24f_24__u53EF_u4E58_uFF0C_u5219_24f_24__u5B8C_u5168_u53EF_u4E58_u7684_u5145_u8981_u6761_u4EF6_u662F" class="headerlink" title="定理八 设 $f$ 可乘，则$f$ 完全可乘的充要条件是"></a>定理八 设 $f$ 可乘，则$f$ 完全可乘的充要条件是</h5><p>$$ f^{-1}(n) = \mu(n)f(n) $$<br>应用定理6.3验证即知。</p>
<h5 id="u63A8_u5E7F_u7684Mobius_u53CD_u6F14_u516C_u5F0F"><a href="#u63A8_u5E7F_u7684Mobius_u53CD_u6F14_u516C_u5F0F" class="headerlink" title="推广的Mobius反演公式"></a>推广的Mobius反演公式</h5><p>设 $g$ 完全可乘, <span>$h= f * g$</span><!-- Has MathJax --> ,则<span>$f= h * \mu g$</span><!-- Has MathJax --> ,即<br><span>$$h(n) = \sum _{d|n} f(d)g(\frac{n}{d})
\quad \Longleftrightarrow \quad f(n) = \sum _{d|n} h(d)
\mu(\frac{n}{d})g(\frac{n}{d})$$</span><!-- Has MathJax --></p>
<p>另上式中 $g=u$ ，上式就变成了Mobius反演公式。<br>由推广的Mobius反演公式，我们由<br><span>$$\sum _{i=1} ^n i^{\lambda} = 
n^{\lambda} * \phi _{\lambda}$$</span><!-- Has MathJax --><br>可知<br><span>$$\phi _{\lambda}(n) =
\sum _{i=1} ^n i^{\lambda} * \mu(n) n^{\lambda}$$</span><!-- Has MathJax -->  </p>
<h5 id="u4E09_u4E2A_u4F18_u7F8E_u516C_u5F0F"><a href="#u4E09_u4E2A_u4F18_u7F8E_u516C_u5F0F" class="headerlink" title="三个优美公式"></a>三个优美公式</h5><p>最后我用三个我很喜欢的公式结束这篇博文。</p>
<ol>
<li><span>$\sum _{n \leq x} d(n) = \sum _{n \leq x} \lfloor \frac{x}{n} \rfloor$</span><!-- Has MathJax -->
</li>
</ol>
<span>$$\sum _{n \leq x} \lfloor \frac{x}{n} \rfloor = 
\sum _{n \leq x} \sum _{l \leq x,\; n|l} 1 = 
\sum _{l \leq x} \sum _{n|l} 1 =
\sum _{l \leq x} d(l) =
\sum _{n \leq x} d(n)$$</span><!-- Has MathJax -->
<ol>
<li><span>$\sum _{n \leq x} \mu(n) \lfloor \frac{x}{n} \rfloor = 1$</span><!-- Has MathJax -->
</li>
</ol>
<span>$$\sum _{n \leq x} \mu(n) \lfloor \frac{x}{n} \rfloor =
\sum _{n \leq x} \mu(n) \sum _{l \leq x,\; n|l} 1 =
\sum _{l \leq x} \sum _{n|l} \mu(n) = \sum _{l \leq x} I(n) =
= 1$$</span><!-- Has MathJax -->
<ol>
<li><span>$\sum _{n=1} ^{\infty} \frac{\mu(n)}{n^2} = \frac{6}{\pi^2}$</span><!-- Has MathJax -->
</li>
</ol>
<span>$$\sum _{n=1} ^{\infty} \frac{1}{n^2} \sum _{n=1} ^{\infty} \frac{\mu(n)}{n^2} =
\sum _{n=1} ^{\infty} \frac{a_n}{n^2}$$</span><!-- Has MathJax -->
<p>其中<br><span>$$a_n = 
\sum _{d|n} \mu(d) = I(n)$$</span><!-- Has MathJax --><br>又由<br><span>$$\sum _{n=1} ^{\infty} \frac{1}{n^2} = 
\frac{\pi^2}{6}$$</span><!-- Has MathJax --><br>结论显然。</p>
<p>该博文大多资料来自 潘承洞《数论基础》，转载请注明<a href="http://dna049.com" target="_blank" rel="external">http://dna049.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近重温潘承洞老先生的《数论基础》(现代数学基础丛书34)，确实是经典中的经典。以现代的眼光看数论函数，使得分析问题更加简洁本质，而这些都要归功于 Dirichlet 积的引入。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Several Algorithms of root Complex]]></title>
    <link href="http://yoursite.com/2016/01/03/Several-Algorithms-of-root-Complex/"/>
    <id>http://yoursite.com/2016/01/03/Several-Algorithms-of-root-Complex/</id>
    <published>2016-01-03T07:12:12.000Z</published>
    <updated>2016-01-21T12:36:43.000Z</updated>
    <content type="html"><![CDATA[<p>I, as a ACMer, always take algorithm complexity into consideration when programming. Today, I introduce you some elegant algorithms of root Complex.</p>
<a id="more"></a>
<h3 id="1-__3C_21-_uFFFC5-_3E"><a href="#1-__3C_21-_uFFFC5-_3E" class="headerlink" title="1. <span>$s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor$</span><!-- Has MathJax -->"></a>1. <span>$s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor$</span><!-- Has MathJax --></h3><p>Since The range of <span>$\lfloor \frac{n}{i} \rfloor$</span><!-- Has MathJax --> contains at most $2\sqrt{n}$ . There may exist a algorithm of complexity $O(\sqrt{n})$.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(LL n)</span></span>&#123; <span class="comment">// The code is simple and easy to understand</span></span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123; </span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        sum += (j-i+<span class="number">1</span>)*(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Actually, $s(n)$ donate the number of positive integer point under graph $xy=1$.</p>
<h3 id="2-__3C_21-_uFFFC7-_3E"><a href="#2-__3C_21-_uFFFC7-_3E" class="headerlink" title="2. <span>$\sigma_k(n) = \sum_{d|n} d^k$</span><!-- Has MathJax -->"></a>2. <span>$\sigma_k(n) = \sum_{d|n} d^k$</span><!-- Has MathJax --></h3><ol>
<li><span>$\sigma_0(n)$</span><!-- Has MathJax --> donate the number of divisors. </li>
<li><span>$\sigma_1(n)$</span><!-- Has MathJax --> donate the sum of divisors.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mypow</span><span class="params">(LL x,LL n)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=x*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getr</span><span class="params">(LL n,LL k)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">0</span>,d;</span><br><span class="line">    <span class="keyword">for</span>(d=<span class="number">1</span>;d*d&lt;n;++d)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%d==<span class="number">0</span>)  r += mypow(d,k) + mypow(n/d,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d*d == n) r+=mypow(d,k);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>The code above is primary and trival. </p>
<h3 id="3-__3C_21-_uFFFC10-_3E"><a href="#3-__3C_21-_uFFFC10-_3E" class="headerlink" title="3. <span>$f(n) = \sum_{i=1}^n \sigma_k(i)$</span><!-- Has MathJax -->"></a>3. <span>$f(n) = \sum_{i=1}^n \sigma_k(i)$</span><!-- Has MathJax --></h3><span>$$f(n) = \sum_{i=1}^n \sigma_k(n) =
\sum_{i=1}^n \sum_{d|i} d^k = 
\sum_{d=1} d^k \sum_i ^n[d|i] =
\sum_{d=1} ^n d^k \lfloor \frac{n}{d} \rfloor$$</span><!-- Has MathJax -->
<p>If we get <span>$ts[n] = \sum_{i=1}^n i^k$</span><!-- Has MathJax -->, similar to problem 1, we have fllowing C++ code:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LL getf(LL <span class="keyword">n</span>)&#123;</span><br><span class="line">    LL <span class="keyword">sum</span> = 0;</span><br><span class="line">    <span class="keyword">for</span>(LL i=1,j;i&lt;=<span class="keyword">n</span>;i=j+1)&#123; </span><br><span class="line">        j = <span class="keyword">n</span>/(<span class="keyword">n</span>/i);</span><br><span class="line">        <span class="keyword">sum</span> += (ts[j]-ts[i-1])*(<span class="keyword">n</span>/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Actuall, we have<br><span>$$ts[n] = \left \{ 
\begin{array}{ll}
\frac{n(n+1)}{2} &amp; k=1 \\
\frac{n(n+1)(2n+1)}{6} &amp; k=2 \\
\frac{n^2(n+1)^2}{4} &amp; k=3 \\ 
\end{array} \right.$$</span><!-- Has MathJax --><br>and for general</p>
<span>$$1^p+2^p+ \dots + n^p =
\sum _{k=1} ^p \; (\; \sum_{j=1} ^ {k} (-1)^{k-j} C_k^j j^p \;) \; C _{n+1} ^{k+1}$$</span><!-- Has MathJax --> 
<p>you can see <a href="http://dna049.com/2016/01/21/自然数方幂和公式/" target="_blank" rel="external">my blog</a> for detail.</p>
<h3 id="4-__3C_21-_uFFFC15-_3E"><a href="#4-__3C_21-_uFFFC15-_3E" class="headerlink" title="4. <span>$g(n) = \sum_{i=1}^n\phi(i)$</span><!-- Has MathJax -->"></a>4. <span>$g(n) = \sum_{i=1}^n\phi(i)$</span><!-- Has MathJax --></h3><p>Throughout this blog, $\phi(n)$ donate the <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function" target="_blank" rel="external">Euler function</a> unless explicitly stated.$\phi(n)$ counts the positive integers less than or equal to n that are relatively prime to n. Euler’s product formula:<br><span>$$\phi(n) = 
n \prod _{p|n}( 1-\frac{1}{p} )$$</span><!-- Has MathJax --><br>where the product is over the distinct prime numbers dividing n.</p>
<p>Now, we begin to computer $g(n)$<br><span>$$g(n) = \sum_ {i=1}^n \phi(i) =
\sum_{1 \leq x \leq y \leq n , gcd(x,y)=1} 1$$</span><!-- Has MathJax --></p>
<p>we define<br><span>$$g_k(n) = \sum_ {i=1}^n \phi(i) =
\sum_{1 \leq x \leq y \leq n , gcd(x,y)=k} 1 = f(\lfloor \frac{n}{k} \rfloor)$$</span><!-- Has MathJax --></p>
<p>and <span>$\sum_{i=1}^n g_k(i) = \sum_{1 \leq x \leq y \leq n} 1 = \frac{n(n+1)}{2}$</span><!-- Has MathJax --> So we have </p>
<span>$$g(n) = 
\frac{n(n+1)}{2} - \sum_ {k=2}^n f(\lfloor \frac{n}{k} \rfloor)$$</span><!-- Has MathJax -->
<p>Similar to problem 1,we have,<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000006</span>;</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ans,-<span class="number">1</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">1</span>;ans[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;N&amp;&amp;ans[n]!=-<span class="number">1</span>) <span class="keyword">return</span> ans[n];</span><br><span class="line">    LL r = n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        r -= (j-i+<span class="number">1</span>)*getans(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;N) ans[n]=r;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-_Problem_hdu5608"><a href="#5-_Problem_hdu5608" class="headerlink" title="5. Problem hdu5608"></a>5. Problem hdu5608</h3><p>If<br><span>$$n^2 -3n+2 
= \sum_ {d|n} f(d)$$</span><!-- Has MathJax --><br>calculate<br><span>$$h(n) = \sum_{i=1}^n 
f(i) \; mod \; 10^9+7$$</span><!-- Has MathJax --></p>
<p>Since<br><span>$$\sum_{i=1}^n \sum_ {d|i} f(d) = 
\sum_{i=1}^n f(i) \lfloor \frac{n}{i} \rfloor = 
\sum_{i=1}^n h(\lfloor \frac{n}{i} \rfloor)$$</span><!-- Has MathJax --><br>and we have,</p>
<span>$$\sum_{i=1}^n \sum_ {d|i} f(d) = 
\sum_{i=1}^n n^2-3n+2 = \sum_{i=1}^n (n-1)(n-2) = \frac{n(n-1)(n-2)}{3}$$</span><!-- Has MathJax -->
<p>by conditon. Hence,<br><span>$$h(n) = 
\frac{n(n-1)(n-2)}{3} - 
\sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$$</span><!-- Has MathJax --><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000006</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv3 = (M+<span class="number">1</span>)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">        ans[i] = LL(i-<span class="number">1</span>)*(i-<span class="number">2</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)&#123;  <span class="comment">// Pretreatment acceleration</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i&lt;&lt;<span class="number">1</span>;j&lt;N;j+=i)&#123;</span><br><span class="line">            ans[j] -= ans[i];</span><br><span class="line">            <span class="keyword">if</span>(ans[j] &lt; <span class="number">0</span>) ans[j] += M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        ans[i] += ans[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(ans[i] &gt; M)  ans[i] -= M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(n&lt;N) <span class="keyword">return</span> ans[n];</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it = mp.find(n); <span class="comment">//Memory search</span></span><br><span class="line">    <span class="keyword">if</span> (it != mp.end())  <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    <span class="keyword">int</span> r = LL(n)*(n-<span class="number">1</span>)%M*(n-<span class="number">2</span>)%M*inv3%M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        r -= LL(j-i+<span class="number">1</span>)*getans(n/i)%M;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>) r+=M;</span><br><span class="line">    &#125;</span><br><span class="line">    mp.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(n,r));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("/Users/c10110057/Desktop/AC/in","r",stdin);</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;getans(n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-_Note"><a href="#6-_Note" class="headerlink" title="6. Note"></a>6. Note</h3><p>All C++ code above should be changed to fit different demands.Thanks <a href="http://zimpha.github.io" target="_blank" rel="external">Zimpha</a> who provides some problems and ideas two years old.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>I, as a ACMer, always take algorithm complexity into consideration when programming. Today, I introduce you some elegant algorithms of root Complex.</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016厦门马拉松]]></title>
    <link href="http://yoursite.com/2016/01/03/2016%E5%8E%A6%E9%97%A8%E9%A9%AC%E6%8B%89%E6%9D%BE/"/>
    <id>http://yoursite.com/2016/01/03/2016厦门马拉松/</id>
    <published>2016-01-03T06:18:20.000Z</published>
    <updated>2016-01-03T14:07:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u7B2C_u4E00_u6B21_u5168_u7A0B_u9A6C_u62C9_u677E"><a href="#u7B2C_u4E00_u6B21_u5168_u7A0B_u9A6C_u62C9_u677E" class="headerlink" title="第一次全程马拉松"></a>第一次全程马拉松</h3><p>仅仅只参加几次10公里的我，这次想装个逼跑个全程马拉松。其实我就是这么任性，没办法。然后就BB一下此次马拉松吧。</p>
<a id="more"></a>
<h5 id="u5751_u7239_u7684_u7279_u6B65"><a href="#u5751_u7239_u7684_u7279_u6B65" class="headerlink" title="坑爹的特步"></a>坑爹的特步</h5><p>衣服尺码不按照官网提供的来，给我一个3XL简直都不用穿裤子了。</p>
<h5 id="u6709_u7231_u7684_u8FDB_u660E_u5BFA"><a href="#u6709_u7231_u7684_u8FDB_u660E_u5BFA" class="headerlink" title="有爱的进明寺"></a>有爱的进明寺</h5><p>大约在28公里的时候，进明寺的一些好心人给我提供了补给，三小块芝麻糕吃的让人心里暖暖的。</p>
<h5 id="u8D5B_u9053_u5F88_u7F8E"><a href="#u8D5B_u9053_u5F88_u7F8E" class="headerlink" title="赛道很美"></a>赛道很美</h5><p>毕竟环海而行，感觉就是舒畅</p>
<h3 id="u8FD9_u6B21_u9A6C_u62C9_u677E_u603B_u4F53_u6765_u8BF4_u5C31_u662F_u592A_u5E74_u8F7B_u4E86"><a href="#u8FD9_u6B21_u9A6C_u62C9_u677E_u603B_u4F53_u6765_u8BF4_u5C31_u662F_u592A_u5E74_u8F7B_u4E86" class="headerlink" title="这次马拉松总体来说就是太年轻了"></a>这次马拉松总体来说就是太年轻了</h3><h5 id="u5B58_u597D_u8863_u670D_u540E_uFF0C_u6CA1_u6709_u7AD9_u5728_u524D_u9762"><a href="#u5B58_u597D_u8863_u670D_u540E_uFF0C_u6CA1_u6709_u7AD9_u5728_u524D_u9762" class="headerlink" title="存好衣服后，没有站在前面"></a>存好衣服后，没有站在前面</h5><p>本次号码为 M64700 存衣车比较靠后，然后存完衣服应该挤进前几组的，导致8:09才到起点。</p>
<h5 id="u524D_u534A_u7A0B_u901F_u5EA6_u592A_u5FEB"><a href="#u524D_u534A_u7A0B_u901F_u5EA6_u592A_u5FEB" class="headerlink" title="前半程速度太快"></a>前半程速度太快</h5><p>一开始就随意跑怎么舒服怎么跑，没有保存体力，到了18公里的时候开始有点不舒服了。如果只跑半程，冲刺一下就没问题了，然而…</p>
<h5 id="u6CA1_u5E26_u8865_u7ED9_u662F_u4E2A_u9519_u8BEF"><a href="#u6CA1_u5E26_u8865_u7ED9_u662F_u4E2A_u9519_u8BEF" class="headerlink" title="没带补给是个错误"></a>没带补给是个错误</h5><p>应该在腰包带个士力架和几颗盐丸的。到了22－25公里时候特别的饿。然后去外面小卖部买了八宝粥，坐着一下就喝完了（还好当时带了钱）。到了33公里左右不流汗了，这时候很不舒服，不流汗肯定是不正常的。还好最后也没抽筋。</p>
<h5 id="u8FD0_u52A8mp3"><a href="#u8FD0_u52A8mp3" class="headerlink" title="运动mp3"></a>运动mp3</h5><p>买的mp3没来得及存五月天的歌确实是一大失误，不过mp3太廉价，下次去买个运动耳机吧。</p>
<h5 id="u6700_u540E_u4E00_u6BB5_u8DEF_u8DD1_u8DD1_u505C_u505C_u4E5F_u7B97_u662F_u8DD1_u5B8C_u4E86_uFF0C_u51C0_u6210_u7EE94_3A59"><a href="#u6700_u540E_u4E00_u6BB5_u8DEF_u8DD1_u8DD1_u505C_u505C_u4E5F_u7B97_u662F_u8DD1_u5B8C_u4E86_uFF0C_u51C0_u6210_u7EE94_3A59" class="headerlink" title="最后一段路跑跑停停也算是跑完了，净成绩4:59"></a>最后一段路跑跑停停也算是跑完了，净成绩4:59</h5><p>最后应采取的策略就是跟着漂亮女生跑，感觉效果还可以，跟着的女生不行了就马上换，然后慢慢的就跑完了，很遗憾的是一直遇见的一妹子最后没看到她。给我留下了本次马拉松的美好回忆。</p>
<h5 id="u8DD1_u5B8C_u624D_u77E5_u9053_u534A_u7A0B_u548C_u5168_u7A0B_u7684_u5DEE_u522B_u786E_u5B9E_u5F88_u5927"><a href="#u8DD1_u5B8C_u624D_u77E5_u9053_u534A_u7A0B_u548C_u5168_u7A0B_u7684_u5DEE_u522B_u786E_u5B9E_u5F88_u5927" class="headerlink" title="跑完才知道半程和全程的差别确实很大"></a>跑完才知道半程和全程的差别确实很大</h5><p>半程喝两次水就可以了，全程要考虑能量，内分泌（盐分），膝盖，腿抽筋等一系列问题。</p>
<h3 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h3><p>跑完之后去了趟厦门大学，只有一个门可以进，绕了一大圈。去食堂蹭了顿饭，感觉厦大也没什么好看的，还不如我大华理的奉贤校区。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u7B2C_u4E00_u6B21_u5168_u7A0B_u9A6C_u62C9_u677E"><a href="#u7B2C_u4E00_u6B21_u5168_u7A0B_u9A6C_u62C9_u677E" class="headerlink" title="第一次全程马拉松"></a>第一次全程马拉松</h3><p>仅仅只参加几次10公里的我，这次想装个逼跑个全程马拉松。其实我就是这么任性，没办法。然后就BB一下此次马拉松吧。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[好好反省]]></title>
    <link href="http://yoursite.com/2015/12/30/%E5%A5%BD%E5%A5%BD%E5%8F%8D%E7%9C%81/"/>
    <id>http://yoursite.com/2015/12/30/好好反省/</id>
    <published>2015-12-30T03:45:06.000Z</published>
    <updated>2016-01-20T12:07:43.000Z</updated>
    <content type="html"><![CDATA[<p>现在的我已经一无所有。学习，爱情，友情一无所有，大学让我成了一个目中无人自私的家伙。现在的我却成了自卑，自己都讨厌自己的人。总是想洗心革面缺总是三分钟的热血。我也不知道何时能够做回那个高中数学竞赛时的0.肆玖，但是有一种预感，他就要回来。</p>
<p>从2015年12月23号开始走向单身生活。2012年4月，我这辈子第一次体会到被爱的感觉，我一直深深的依赖着她。分开那天在华理图书馆，她说我现在翅膀长硬了，不需要一个既当妈又当女朋友的她了。我先现在开始我要和<br>自己的内心谈一次恋爱，找回那个迷路的0.肆玖。</p>
<p>经过了一学期的折腾我想我已经下定决心好好学代数了。我一直生活在一个极度自由的环境，给了我一颗放荡狂野的心。现在要有规律的生活，11点前睡，6点半起床，看名家原著英语，记单词养成一点不差的记住并主动使用，我想这是我写的最后一篇数学中文博文了(后来发现这并不现实)，因为我知道不具名的演员不管有没有观众。该上课上课，其它时间看代数课外书，要让以后的老师看得起。定理证明尽量自己来。英语课一定好好预习，课本每一个单词都要读到读懂。晚上回来复习一下英语。按照周计划行事。</p>
<h3 id="2016_u5E74_u5143_u65E6_u52302017_u5E74_u5143_u65E6"><a href="#2016_u5E74_u5143_u65E6_u52302017_u5E74_u5143_u65E6" class="headerlink" title="2016年元旦到2017年元旦"></a>2016年元旦到2017年元旦</h3><ol>
<li>不碰女人(导致哥性饥渴)</li>
<li>不碰游戏(0.0)</li>
<li>考托福</li>
</ol>
<h3 id="u8BC4_u8BBA_u4E2D_u8BB0_u5F55_u4E0D_u826F_u5386_u53F2"><a href="#u8BC4_u8BBA_u4E2D_u8BB0_u5F55_u4E0D_u826F_u5386_u53F2" class="headerlink" title="评论中记录不良历史"></a>评论中记录不良历史</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>现在的我已经一无所有。学习，爱情，友情一无所有，大学让我成了一个目中无人自私的家伙。现在的我却成了自卑，自己都讨厌自己的人。总是想洗心革面缺总是三分钟的热血。我也不知道何时能够做回那个高中数学竞赛时的0.肆玖，但是有一种预感，他就要回来。</p>
<p>从2015年12月2]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[打回原形]]></title>
    <link href="http://yoursite.com/2015/12/24/%E6%89%93%E5%9B%9E%E5%8E%9F%E5%BD%A2/"/>
    <id>http://yoursite.com/2015/12/24/打回原形/</id>
    <published>2015-12-24T13:50:21.000Z</published>
    <updated>2015-12-24T14:15:47.000Z</updated>
    <content type="html"><![CDATA[<p>最近状态好差，感觉自己真的老了。好怀念初一的时候，傻的很充实。怀念大一的时候，青春有干劲。然而现在一副要死的样。我想改变，想丢掉名字性别。转土重来，一个人静静，可是一个人静静的时候却又感到空虚。</p>
<a id="more"></a>
<p>初一的时候什么都不多想，基本上只知道学习，学校也几乎是不放假的。那时候很静，不浮躁，一点一滴。后来却变了，我整个人成了一个吊儿郎当，浮夸，装逼的人，我内心深处并不希望这样，因为我相信人是孤独的，只有被自己肯定才是真正的自信之源。我现在不自信也是这学期碌碌无为结的果，我不想重蹈我高中的覆辙。之后高中不温不火的学习让我进了我华东理工大学。</p>
<p>大学总是新鲜的，是一块可口的蛋糕，要吃前总要思考万分。当时的我知道，我不能像高中那样平平凡凡，不被看重。在大学学自己喜欢的专业确实是一件很奢侈的事。所以大一的我燃烧了我的青春，我一年读了别人四年都不止的书，花的时间，达到的效果也是让现在的我都震惊的。然后这些都是过去，我已被打回原形。来到复旦的第一个学期就要这样悄无声息，带着微笑和嘲讽的表情从我心头走过。我恨这种感觉，这种让我没有归属感，没有成就感，让我不自信的感觉。所以我需要召唤一个更强大的自己出来。</p>
<p>他说，2020年，当dna049毕业的时候，他要让别人不因为他毕业于复旦大学上海数学中心觉得他厉害，而是因为他叫dna049而觉得他厉害。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近状态好差，感觉自己真的老了。好怀念初一的时候，傻的很充实。怀念大一的时候，青春有干劲。然而现在一副要死的样。我想改变，想丢掉名字性别。转土重来，一个人静静，可是一个人静静的时候却又感到空虚。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo 中插入图片最简单方式]]></title>
    <link href="http://yoursite.com/2015/12/23/hexo-%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%9C%80%E7%AE%80%E5%8D%95%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/12/23/hexo-中插入图片最简单方式/</id>
    <published>2015-12-23T12:42:32.000Z</published>
    <updated>2015-12-23T13:03:29.000Z</updated>
    <content type="html"><![CDATA[<p>因为上一篇博文需要贴一张本地图片，奈何技术上无法解决。后来查了官方文档并且询问hexo交流群（287306637）之后，有给出解决方案（用图床）但是不是我想要的方式，最终通过<a href="https://hexo.io/docs/asset-folders.html" target="_blank" rel="external">官方文档</a>解决了此问题。</p>
<a id="more"></a>
<p>方法其实很简单，只需再修改 _config.yml 文件中的</p>
<pre><code>post_asset_folder: false
</code></pre><p>改成</p>
<pre><code>post_asset_folder: true
</code></pre><p>然后举个例子大家就明白了。</p>
<pre><code>hexo new &quot;example&quot;
</code></pre><p>经过上面设置之后，source 目录下会多出一个 example 的目录。在这个example目录下放一张 math.png 的图片，然后在 example.md 中加入 </p>
<pre><code>![图片加载中](math.png)
</code></pre><p>即可。就是这么简单。<br><img src="example.png" alt="Loading"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为上一篇博文需要贴一张本地图片，奈何技术上无法解决。后来查了官方文档并且询问hexo交流群（287306637）之后，有给出解决方案（用图床）但是不是我想要的方式，最终通过<a href="https://hexo.io/docs/asset-folders.html">官方文档</a>解决了此问题。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[本科数学系学习路线图]]></title>
    <link href="http://yoursite.com/2015/12/23/%E6%9C%AC%E7%A7%91%E6%95%B0%E5%AD%A6%E7%B3%BB%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%BE/"/>
    <id>http://yoursite.com/2015/12/23/本科数学系学习路线图/</id>
    <published>2015-12-23T09:52:57.000Z</published>
    <updated>2015-12-24T13:48:53.000Z</updated>
    <content type="html"><![CDATA[<p>最近在看刘培德先生的书《拓扑线性空间和算子谱理论》，简直爱不释手。而拓扑线性空间理论是在1950年左右由<a href="https://sv.wikipedia.org/wiki/Nicolas_Bourbaki" target="_blank" rel="external">Nicolas Bourbaki学派</a>建立。不禁让我回顾本科学习生涯中，从学习300年前一直到100年前的数学，现在又在学习几十年前的数学。于是就把本科学习路线总结如下图，下图由此<a href="https://www.processon.com" target="_blank" rel="external">网站</a>在线产生</p>
<a id="more"></a>
<p><img src="math.png" alt="图片加载中0.0"></p>
<p>上图中颜色代表了一定的重要性，而尺寸大的代表其基础重要性。</p>
<h3 id="u63A8_u8350_u7684_u4E66"><a href="#u63A8_u8350_u7684_u4E66" class="headerlink" title="推荐的书"></a>推荐的书</h3><p>由于本人阅历有限，仅给出自己看过比较好的书。<br>       数学分析: 陈纪修<br>    高等代数：北京大学**小组<br>    数论基础：潘承洞<br>    线性代数：李炯生<br>    实变函数：胡适耕<br>    泛函分析：北师大<br>    点集拓扑学：熊金城<br>    近世代数：冯克勤<br>    矩阵论：詹兴致</p>
<p>不求高逼格，只求有益于心。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在看刘培德先生的书《拓扑线性空间和算子谱理论》，简直爱不释手。而拓扑线性空间理论是在1950年左右由<a href="https://sv.wikipedia.org/wiki/Nicolas_Bourbaki">Nicolas Bourbaki学派</a>建立。不禁让我回顾本科学习生涯中，从学习300年前一直到100年前的数学，现在又在学习几十年前的数学。于是就把本科学习路线总结如下图，下图由此<a href="https://www.processon.com">网站</a>在线产生</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[拓扑线性空间中的开集和闭集]]></title>
    <link href="http://yoursite.com/2015/12/20/%E6%8B%93%E6%89%91%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E5%BC%80%E9%9B%86%E5%92%8C%E9%97%AD%E9%9B%86/"/>
    <id>http://yoursite.com/2015/12/20/拓扑线性空间中的开集和闭集/</id>
    <published>2015-12-20T15:13:32.000Z</published>
    <updated>2016-01-20T12:21:57.000Z</updated>
    <content type="html"><![CDATA[<p>在复习泛函分析的时候，因为很多结论可以推广到更为一般的情况，因此就看了刘培德先生编著的《拓扑线性空间与算子谱理论》这本书。然后在书中读到了有关开集和闭集的一些性质，在此总结一下，先叙述一下结论。<br>在拓扑线性空间中，</p>
<ol>
<li>若A是开集，B是任意集合，则A+B是开集。</li>
<li>若A是闭集，B是闭集，则A+B不一定为闭集。</li>
<li>若A是紧集，B是闭集，则A+B是闭集。<a id="more"></a>
</li>
</ol>
<h4 id="u62D3_u6251_u7EBF_u6027_u7A7A_u95F4"><a href="#u62D3_u6251_u7EBF_u6027_u7A7A_u95F4" class="headerlink" title="拓扑线性空间"></a>拓扑线性空间</h4><p>拓扑线性空间是一类其线性结构与最一般的拓扑结构有机结合的集合。它作为泛函分析的分支产生于20世纪40到50年代，至今仍然是现代数学乃至自然科学中讨论有关问题和相关理论的最为广泛的框架。它的产生很大直接或间接来自数学上赫赫有名的<a href="https://en.wikipedia.org/wiki/Nicolas_Bourbaki" target="_blank" rel="external">Nicolas Bourbaki学派</a>。</p>
<h5 id="u62D3_u6251_u7EBF_u6027_u7A7A_u95F4_u7684_u5B9A_u4E49"><a href="#u62D3_u6251_u7EBF_u6027_u7A7A_u95F4_u7684_u5B9A_u4E49" class="headerlink" title="拓扑线性空间的定义"></a>拓扑线性空间的定义</h5><p>设X是标量域K(实数域或复数域)上的拓扑线性空间，$\tau$是X上的拓扑，若</p>
<ol>
<li>对于每一点$x \in X$，单点集$\lbrace x \rbrace$是X中的闭集。</li>
<li>线性空间的加法和数乘关于$\tau$连续。</li>
</ol>
<p>则称X是拓扑线性空间（TLS）<br>注：至于线性空间和拓扑的定义是很容易查到。上面条件1说明TLS必然是T1空间，但是经过推理可知TLS是T3空间，因而必然是Hausdorff的。拓扑线性空间的拓扑有很多很好的性质，这里不再多说了。</p>
<h5 id="u7ED3_u8BBA_u7684_u8BC1_u660E"><a href="#u7ED3_u8BBA_u7684_u8BC1_u660E" class="headerlink" title="结论的证明"></a>结论的证明</h5><p>首先，开集，闭集，紧集这些概念完全是依赖拓扑的。具体可查熊金城《点集拓扑学讲义》，线性空间可以查任何一本线性代数或者高等代数的书。<br>Proof：<br>(i) 若A是开集，B是任意集合，则A+B是开集。<br>因为<span>$A+B = \cup _ {y \in B} A+y$</span><!-- Has MathJax -->是开集，证毕。<br>(ii) 若A是闭集，B是闭集，则A+B不一定为闭集。<br>不妨设<span>$A＝\lbrace (x,y) \;|\; x&gt;0,xy \geq 1 \rbrace ,B＝\lbrace (x,y) \;|\; x&gt;0,xy \leq -1 \rbrace$</span><!-- Has MathJax -->则显然A、B是闭集，但是<span>$A+B =\lbrace (x,y) \;|\; x&gt;0 \rbrace$</span><!-- Has MathJax -->是开集且不是闭集。<br>(iii) 若A是紧集，B是闭集，则A+B是闭集。<br>这里的证明需要用到拓扑的两个结论</p>
<ol>
<li>$x \in \overline{A}$当且仅当A中有网（<span>$x _ {\lambda}, \lambda \in \Lambda,x _ \lambda \to x$</span><!-- Has MathJax -->)</li>
<li>A紧当且仅当A中每一个网 <span>$x _ {\lambda}, \lambda \in \Lambda$</span><!-- Has MathJax -->都有极限点（即有收敛子网）</li>
</ol>
<p>若$c \in \overline{A+B}$，则存在网（<span>$c _ {\lambda}= a _ {\lambda} +b _ {\lambda}, \lambda \in \Lambda$</span><!-- Has MathJax -->）使得<span>$c _ {\lambda} \to c$</span><!-- Has MathJax -->,这里<span>$a _ {\lambda} \in A , b _ {\lambda} \in B$</span><!-- Has MathJax -->。由于A紧，于是有子网<span>$a _ {\lambda&apos;} , \lambda&apos; \in \Lambda&apos; \subset \Lambda$</span><!-- Has MathJax -->）使得<span>$a _ {\lambda&apos;} \to a$</span><!-- Has MathJax -->此时<span>$b _ {\lambda&apos;} = c _ {\lambda&apos;} - a _ {\lambda&apos;} \to c-a = b$</span><!-- Has MathJax -->，由于B是闭集，故$b \in B$。于是$c = a + b \in A+B$，即$\overline{A+B} ＝ A+B$，所以A+B是闭的。</p>
<h5 id="u540E_u8BB0"><a href="#u540E_u8BB0" class="headerlink" title="后记"></a>后记</h5><p>其实现代数学最大的问题，不是不知道怎么处理问题，而是根本不懂问题在说什么。</p>
<p>我们要相当的努力才能认识到自己是傻逼的事实。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在复习泛函分析的时候，因为很多结论可以推广到更为一般的情况，因此就看了刘培德先生编著的《拓扑线性空间与算子谱理论》这本书。然后在书中读到了有关开集和闭集的一些性质，在此总结一下，先叙述一下结论。<br>在拓扑线性空间中，</p>
<ol>
<li>若A是开集，B是任意集合，则A+B是开集。</li>
<li>若A是闭集，B是闭集，则A+B不一定为闭集。</li>
<li>若A是紧集，B是闭集，则A+B是闭集。]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Perron-Frobenius理论]]></title>
    <link href="http://yoursite.com/2015/12/17/Perron-Frobenius%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2015/12/17/Perron-Frobenius理论/</id>
    <published>2015-12-17T02:27:18.000Z</published>
    <updated>2015-12-18T01:26:32.000Z</updated>
    <content type="html"><![CDATA[<p>1907年O.Perron发现正矩阵的谱有特别有趣的性质。G.Frobenius在1908-1912年间将Perron的工作推广到不可约非负矩阵的情形，并得到了新的进一步结果。Ferron-Frobenius理论有很多证明方式，下面介绍H.Wielandt的优美证明。<br><a id="more"></a></p>
<p>两个矩阵X和Y称为置换相似的，若存在一个置换矩阵P满足$P^TXP=Y$。设$A\in M_n$.称A为可约的，若A置换相似于一个形如<br><span>$$\left( \begin{matrix}
B &amp; 0\\
C &amp; D
\end{matrix} \right)$$</span><!-- Has MathJax --><br>其中B，D为方阵，若A不是可约的，则称A是不可约的。</p>
<h5 id="u5F15_u74061__u8BBEA_u662Fn_28n_26gt_3B1_29_u9636_u4E0D_u53EF_u7EA6_u975E_u8D1F_u77E9_u9635_uFF0C_24y_5Cin__5Cmathbf_7BR_7D_+_5E_7Bn_7D__5Cbackslash__5Clbrace_0__5Crbrace__24__u4E14_u81F3_u5C11_u6709_u4E00_u4E2A_u5206_u91CF_u4E3A0-_u5219__24_28I+A_29y_24__u7684_u6B63_u5206_u91CF_u7684_u4E2A_u6570_u5927_u4E8Ey_u7684_u6B63_u5206_u91CF_u4E2A_u6570_u3002"><a href="#u5F15_u74061__u8BBEA_u662Fn_28n_26gt_3B1_29_u9636_u4E0D_u53EF_u7EA6_u975E_u8D1F_u77E9_u9635_uFF0C_24y_5Cin__5Cmathbf_7BR_7D_+_5E_7Bn_7D__5Cbackslash__5Clbrace_0__5Crbrace__24__u4E14_u81F3_u5C11_u6709_u4E00_u4E2A_u5206_u91CF_u4E3A0-_u5219__24_28I+A_29y_24__u7684_u6B63_u5206_u91CF_u7684_u4E2A_u6570_u5927_u4E8Ey_u7684_u6B63_u5206_u91CF_u4E2A_u6570_u3002" class="headerlink" title="引理1 设A是n(n&gt;1)阶不可约非负矩阵，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 且至少有一个分量为0.则 $(I+A)y$ 的正分量的个数大于y的正分量个数。"></a>引理1 设A是n(n&gt;1)阶不可约非负矩阵，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 且至少有一个分量为0.则 $(I+A)y$ 的正分量的个数大于y的正分量个数。</h5><p>Proof： 设y恰好有k个正分量，$1 \leq k \leq n-1$。设P是置换矩阵使得$x=Py$的前k个分量为正，其它为0，因为A是非负矩阵，所以$(I+A)y$的零分量个数不会超过$n-k$。假设这个个数等于$n-k$，则有$y_i = 0 \Rightarrow (Ay)_i = 0$。即$(Py)_i = 0 \Rightarrow (PAy)_i = 0$ 于是$(PAP^Tx)_i = 0,i=k+1,\cdots,n$，设$B=PAP^T$. 则当$k+1 \leq i \leq n$ 时，<br><span>$$(Bx)_i = \sum _{j=1} ^{n} b _{ij} x _j = 
\sum _{j=1} ^{k} b _{ij} x _j = 0$$</span><!-- Has MathJax --></p>
<p>但当$1 \leq j \leq k$时，<span>$x _ j &gt;0$</span><!-- Has MathJax -->。所以<span>$b _{ij}=0,k+1 \leq i \leq n,1 \leq j \leq k$</span><!-- Has MathJax --> 矛盾于A不可约,证毕。</p>
<p>由引理1，我们马上得到以下结论</p>
<h5 id="u5F15_u74062__u8BBEA_u662Fn_u9636_u4E0D_u53EF_u7EA6_u975E_u8D1F_u77E9_u9635_uFF0C_24y_5Cin__5Cmathbf_7BR_7D_+_5E_7Bn_7D__5Cbackslash__5Clbrace_0__5Crbrace__24__u5219__24_28I+A_29_5E_7Bn-1_7Dy_26gt_3B0_24"><a href="#u5F15_u74062__u8BBEA_u662Fn_u9636_u4E0D_u53EF_u7EA6_u975E_u8D1F_u77E9_u9635_uFF0C_24y_5Cin__5Cmathbf_7BR_7D_+_5E_7Bn_7D__5Cbackslash__5Clbrace_0__5Crbrace__24__u5219__24_28I+A_29_5E_7Bn-1_7Dy_26gt_3B0_24" class="headerlink" title="引理2 设A是n阶不可约非负矩阵，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 则 $(I+A)^{n-1}y&gt;0$."></a>引理2 设A是n阶不可约非负矩阵，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 则 $(I+A)^{n-1}y&gt;0$.</h5><h5 id="u5F15_u74063__u8BBE_24n_26gt_3B1_24_u5219n_u9636_u975E_u8D1F_u77E9_u9635A_u4E0D_u53EF_u7EA6_u5F53_u4E14_u4EC5_u5F53_uFF0C_24y_5Cin__5Cmathbf_7BR_7D_+_5E_7Bn_7D__5Cbackslash__5Clbrace_0__5Crbrace__24__u5219__24_28I+A_29_5E_7Bn-1_7D_26gt_3B0_24"><a href="#u5F15_u74063__u8BBE_24n_26gt_3B1_24_u5219n_u9636_u975E_u8D1F_u77E9_u9635A_u4E0D_u53EF_u7EA6_u5F53_u4E14_u4EC5_u5F53_uFF0C_24y_5Cin__5Cmathbf_7BR_7D_+_5E_7Bn_7D__5Cbackslash__5Clbrace_0__5Crbrace__24__u5219__24_28I+A_29_5E_7Bn-1_7D_26gt_3B0_24" class="headerlink" title="引理3 设$n&gt;1$则n阶非负矩阵A不可约当且仅当，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 则 $(I+A)^{n-1}&gt;0$."></a>引理3 设$n&gt;1$则n阶非负矩阵A不可约当且仅当，$y\in \mathbf{R}_+^{n} \backslash \lbrace 0 \rbrace $ 则 $(I+A)^{n-1}&gt;0$.</h5><p>proof: 应用引理2，考虑$(I+A)^{n-1}e_j$即可。</p>
<h5 id="u5F15_u74064__u4E00_u4E2A_u4E0D_u53EF_u7EA6_u975E_u8D1F_u77E9_u9635_u7684_u975E_u8D1F_u7279_u5F81_u5411_u91CF_u662F_u6B63_u7279_u5F81_u5411_u91CF_u3002"><a href="#u5F15_u74064__u4E00_u4E2A_u4E0D_u53EF_u7EA6_u975E_u8D1F_u77E9_u9635_u7684_u975E_u8D1F_u7279_u5F81_u5411_u91CF_u662F_u6B63_u7279_u5F81_u5411_u91CF_u3002" class="headerlink" title="引理4 一个不可约非负矩阵的非负特征向量是正特征向量。"></a>引理4 一个不可约非负矩阵的非负特征向量是正特征向量。</h5><p>Proof：设A是不可约非负矩阵，$Ax=\lambda x, x \geq 0,x \neq 0$。显然 $\lambda \geq 0$ 我们有<br><span>$$(I+A)x = 
(1 + \lambda)x$$</span><!-- Has MathJax --><br>因此$(1+A)x$与$x$有相同个数的正分量，有引理1知$x&gt;0$。</p>
<h5 id="Collatz-Wielandt_u51FD_u6570"><a href="#Collatz-Wielandt_u51FD_u6570" class="headerlink" title="Collatz-Wielandt函数"></a>Collatz-Wielandt函数</h5><p>设A是一个n阶非负矩阵。A的Collatz－Wielandt函数<span>$f_A \colon \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace  \to \mathbf{R} _+$</span><!-- Has MathJax --><br>定义为<br><span>$$f_A(x) = \min _{ x _i \neq 0 } 
\frac{(Ax) _i }{x _i}$$</span><!-- Has MathJax --></p>
<h5 id="u5F15_u74065__u8BBEA_u4E3An_u9636_u975E_u8D1F_u4E0D_u53EF_u7EA6_u77E9_u9635_uFF0C_u5219"><a href="#u5F15_u74065__u8BBEA_u4E3An_u9636_u975E_u8D1F_u4E0D_u53EF_u7EA6_u77E9_u9635_uFF0C_u5219" class="headerlink" title="引理5 设A为n阶非负不可约矩阵，则"></a>引理5 设A为n阶非负不可约矩阵，则</h5><ol>
<li>$f_A(tx) = f_A(x), \forall t &gt; 0 $</li>
<li>$f_A(x) = \max \lbrace \rho | Ax-\rho x \geq 0 \rbrace$</li>
<li>设 $x \in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace $ ,记 $y = (I+A)^{n-1} x$ ,则 $ f_A(y) \geq f_A(x)$。</li>
</ol>
<p>Proof：(1),(2)显然。下证明(3)<br>我们有$Ax- f_A(x)x \geq 0$，在等式两边左乘以$(I+A)^{n-1}$并利用$A$和$(I+A)^{n-1}$乘法可交换的性质，得到<br><span>$$A(I+A)^{n-1}x - 
f_A(x)(I+A)^{n-1}x \geq 0$$</span><!-- Has MathJax --><br>即<br><span>$$Ay - f_A(x)y
\geq 0$$</span><!-- Has MathJax --><br>再由(2)就得到(3)。</p>
<p>容易证明：$f_A$是有界函数，实际上，$f_A$非负且不超过$A$的最大行和。<br>记<span>$\Omega _n = \lbrace x \in \mathbf{R} _+ ^n | \sum _{i=1} ^n = 1 \rbrace$</span><!-- Has MathJax -->引理5.1说明，我们只需要在$ \Omega _n$上研究$f_A$即可。显然$\Omega _n$是一个紧集，但是$f_A$可能在$\Omega _n$ 的边界不连续。但是我们仍然有引理6。</p>
<h5 id="u5F15_u74066__u8BBEA_u662Fn_u9636_u975E_u8D1F_u4E0D_u53EF_u7EA6_u77E9_u9635_uFF0C_u5219_3C_21-_uFFFC10-_3E_u5728_24_5Cmathbf_7BR_7D__+__5En__5Cbackslash__5Clbrace_0__5Crbrace__24_u4E0A_u53EF_u4EE5_u53D6_u5230_u6700_u5927_u503C_u3002"><a href="#u5F15_u74066__u8BBEA_u662Fn_u9636_u975E_u8D1F_u4E0D_u53EF_u7EA6_u77E9_u9635_uFF0C_u5219_3C_21-_uFFFC10-_3E_u5728_24_5Cmathbf_7BR_7D__+__5En__5Cbackslash__5Clbrace_0__5Crbrace__24_u4E0A_u53EF_u4EE5_u53D6_u5230_u6700_u5927_u503C_u3002" class="headerlink" title="引理6 设A是n阶非负不可约矩阵，则<span>$f _ A$</span><!-- Has MathJax -->在$\mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace $上可以取到最大值。"></a>引理6 设A是n阶非负不可约矩阵，则<span>$f _ A$</span><!-- Has MathJax -->在$\mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace $上可以取到最大值。</h5><p>Proof： 记<br><span>$$\Delta = (I+A)^{n-1} \Omega _n = \lbrace y |
y=(I+A)^{n-1} x ,x \in \Omega _n \rbrace$$</span><!-- Has MathJax --><br>则$\Delta$是一个紧集，且有引理2知$\Delta$中向量都是正向量，因此<span>$f _ A$</span><!-- Has MathJax --> 在$ \Delta $上连续，由Weierstrass定理，$f_A$在某一点<span>$y^0 \in \Delta$</span><!-- Has MathJax -->取得<span>$f _ A$</span><!-- Has MathJax -->在$\Delta$上的最大值。记 <span>$z ^0 = y ^0 / \sum_{i=1} ^n y _i ^0 \in \Omega _ n$</span><!-- Has MathJax -->。<span>$\forall x \in \Omega _n$</span><!-- Has MathJax -->，记 $ y=(I+A)^{n-1}x $利用引理5可知<br><span>$$f_A(x) \leq f_A(y) 
\leq f_A(y ^0) = f_A(z^0)$$</span><!-- Has MathJax --><br>这就证明了<span>$f_A$</span><!-- Has MathJax --> 在 $z^0$上取到它在<span>$\Omega _n$</span><!-- Has MathJax -->上的最大值。利用对<span>$\forall z \in R _+ ^n \backslash \lbrace 0 \rbrace$</span><!-- Has MathJax -->和引理6.1有<br><span>$$f_A(z) \leq f_A(\frac{z}{\sum_{i=1}^n z _i}) = 
f_A(z^0)$$</span><!-- Has MathJax --><br>可见<span>$f_A$</span><!-- Has MathJax -->在$z^0$处取到它在<span>$R _+ ^n \backslash \lbrace 0 \rbrace$</span><!-- Has MathJax -->上的最大值。</p>
<p>矩阵A的谱半径$\rho(A)$定义成矩阵A的所有特征值的绝对值的最大值。<br>万事俱备了，下面开始介绍著名的Perron-Frobenius定理</p>
<h5 id="u5B9A_u74067_28Perron-Frobenius_29__u8BBEA_u662Fn_28n_26gt_3B1_29_u9636_u975E_u8D1F_u4E0D_u53EF_u7EA6_u77E9_u9635_uFF0C_u5219_u4E0B_u9762_u7ED3_u8BBA_u6210_u7ACB_u3002"><a href="#u5B9A_u74067_28Perron-Frobenius_29__u8BBEA_u662Fn_28n_26gt_3B1_29_u9636_u975E_u8D1F_u4E0D_u53EF_u7EA6_u77E9_u9635_uFF0C_u5219_u4E0B_u9762_u7ED3_u8BBA_u6210_u7ACB_u3002" class="headerlink" title="定理7(Perron-Frobenius) 设A是n(n&gt;1)阶非负不可约矩阵，则下面结论成立。"></a>定理7(Perron-Frobenius) 设A是n(n&gt;1)阶非负不可约矩阵，则下面结论成立。</h5><ol>
<li>$\rho(A)&gt;0$ 且 $\rho(A)$是矩阵A的一个单特征值。</li>
<li>A有一个对应于$\rho(A)$的正特征向量。</li>
<li>A的每个非负特征向量都对应于特征值$\rho(A)$.</li>
</ol>
<p>Proof：由引理6存在$x^0 \in R _+ ^n \backslash \lbrace 0 \rbrace  $满足<br><span>$$f_A(x^0) \geq f_A(x),
\forall x \in \mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace$$</span><!-- Has MathJax --></p>
<p>记<span>$r=f_A(x^0)$</span><!-- Has MathJax -->。取<span>$u=(1,\cdots,1)^T$</span><!-- Has MathJax -->。因为$A$不可约，没有零行，所以<br><span>$$r \geq f_A(u) =
\min \sum _ {i=1} ^n a _{ij} &gt; 0$$</span><!-- Has MathJax --><br>下面证明r是A的一个特征值，我们有<br><span>$$Ax^0 - rx^0 
\geq 0$$</span><!-- Has MathJax --><br>假设$Ax^0 - rx^0 \neq 0$。由引理5.2<br><span>$$(I+A)^{n-1}
(Ax^0 - rx^0) &gt; 0$$</span><!-- Has MathJax --><br>即<br><span>$$Ay^0 - 
ry^0&gt; 0$$</span><!-- Has MathJax --><br>其中<span>$y_0 = (I+A)^{n-1}x^0 &gt;0$</span><!-- Has MathJax -->。因此存在一个正数 $\epsilon$ 使得<br><span>$$Ay^0 - 
(r+\epsilon)y^0&gt; 0$$</span><!-- Has MathJax --><br>由引理5.2，<span>$f_A(y^0) \geq r+\epsilon &gt; r$</span><!-- Has MathJax -->这就与<span>$r=f_A(x^0)$</span><!-- Has MathJax -->的最大性矛盾。所以$Ax^0=rx^0$。从而r是A的一个特征值，$x^0$是A的一个特征向量。有引理4知，$x^0$是正向量。<br>设$\lambda$是A的任何一个特征向量：$Ax=\lambda x$ 则<br><span>$$|\lambda||x|
\leq A|x|$$</span><!-- Has MathJax --><br>于是$|\lambda| \leq f _ A(|x|) \leq r$ 这表明$r = \rho(A)$。</p>
<p>现证明$\rho(A)$是单特征值，我们先证明$\rho(A)$的几何重数是1，设<br><span>$$Ay = \rho(A) y,
0 \neq y \in \mathbf{C} ^n$$</span><!-- Has MathJax --><br>则<br><span>$$A|y| \geq 
\rho(A)|y|$$</span><!-- Has MathJax --><br>上面证明过程表面上式是等式。且$|y|&gt;0$。可见，A的对应于$\rho(A)$的特征向量不含零分量。设y和z是对应$\rho(A)$的特征向量。则<span>$|y|&gt;0,|z|&gt;0.z_ 1 y-y_ 1 z$</span><!-- Has MathJax -->属于$\rho(A)$的特征子空间，但<span>$z_ 1 y-y_ 1 z$</span><!-- Has MathJax -->的第一个分量为0，所以它不可能是$\rho(A)$的特征值，因此，<span>$z_ 1 y-y_ 1 z＝0$</span><!-- Has MathJax -->，y和z线性相关，所以$\rho(A)$的几何重数为1.<br>为了证明$r=\rho(A)$是特征多项式$\phi(\lambda) = det(\lambda I - A)$的单根，只需证明，导数<span>$\phi&apos;(r) \neq 0$</span><!-- Has MathJax -->。用$adj(Z)$表示Z的伴随矩阵。我们有<br><span>$$\phi&apos;(\lambda) = \sum_{i=1}^n det[(\lambda I - A)(i|i)]
=tr[adj(\lambda I - A)]$$</span><!-- Has MathJax --><br>记$B(r)=adj(rI-A)$则$\phi’(r) = tr B(r)$,<br><span>$$(rI-A)B(r) = det(rI-A)I
=0$$</span><!-- Has MathJax --><br>因为r的几何重数为1，所以$rank(rI-A)=n-1$，于是$B(r) \neq 0$。设b是$B(r)$的任意一个非零列，则$(rI-A)b=0$,因此b是A的对应于r的特征向量，但是A有一个对应于r的特征向量$x^0$，且因为r的几何重数为1，因此b是$x^0$的一个常数倍，从而$b&gt;0$或者$b<0$。这就证明了$b(r)$的每一列要么是零列，要么是正向量，要么是负向量。考虑<span>$[B(r)]^T = adj(rI-A^T),r=\rho(A)=\rho(A^T)$<!-- Has MathJax --> 。上面结论应用于$[B(r)]^T$的列，所以$B(r)&gt;0$或者$B(r)&lt;0$,从而$\phi’(r)=tr[B(r)] \neq 0$,这就证明了$\rho(A)$是单特征值。<br>我们已经证明了(1),(2)。现在来证明(3)。设$y&gt;0$是$A^T$对应于$\rho(A)$的特征向量，设x是A的任意一个非负特征向量：<span>$Ax = \mu x$</span><!-- Has MathJax -->。则<br><span>$$\mu y^T x = y^T Ax = 
\rho(A)y^Tx$$</span><!-- Has MathJax --><br>因为$y^Tx&gt;0$,我们有$ \mu = \rho(A) $，证毕。<br>注：由引理4，A的非负特征向量实际上都是正向量，因此结论3可叙述成：在A的所有特征向量中，只有$\rho(A)$有非负特征向量。上述证明还确定了以下结果：</0$。这就证明了$b(r)$的每一列要么是零列，要么是正向量，要么是负向量。考虑<span></p>
<h6 id="u5B9A_u74068-__u8BBEA_u662F_u4E00_u4E2An_28n_26gt_3B1_29_u9636_u4E0D_u53EF_u7EA6_u975E_u8D1F_u77E9_u9635_uFF0C_u5219"><a href="#u5B9A_u74068-__u8BBEA_u662F_u4E00_u4E2An_28n_26gt_3B1_29_u9636_u4E0D_u53EF_u7EA6_u975E_u8D1F_u77E9_u9635_uFF0C_u5219" class="headerlink" title="定理8. 设A是一个n(n&gt;1)阶不可约非负矩阵，则"></a>定理8. 设A是一个n(n&gt;1)阶不可约非负矩阵，则</h6><span>$$\rho(A) = \max \lbrace f_A(x)|x\in \mathbf{R} _+ ^n
\backslash \lbrace 0 \rbrace \rbrace$$</span><!-- Has MathJax -->
<p>若<span>$\mathbf{R} _+ ^n \backslash \lbrace 0 \rbrace ,f_A(x) = \rho(A)$</span><!-- Has MathJax -->则$\rho&gt;0$且x是对应于$\rho(A)$的一个特征向量。</p>
<h6 id="u5B9A_u74069-__u8BBEA_u662F_u4E00_u4E2A_u975E_u8D1F_u77E9_u9635_uFF0C_u5219_24_5Crho_28A_29_24_u662FA_u7684_u7279_u5F81_u503C_uFF0C_u4E14A_u6709_u4E00_u4E2A_u5BF9_u5E94_u4E8E_24_5Crho_28A_29_24_u7684_u975E_u8D1F_u7279_u5F81_u5411_u91CF_u3002"><a href="#u5B9A_u74069-__u8BBEA_u662F_u4E00_u4E2A_u975E_u8D1F_u77E9_u9635_uFF0C_u5219_24_5Crho_28A_29_24_u662FA_u7684_u7279_u5F81_u503C_uFF0C_u4E14A_u6709_u4E00_u4E2A_u5BF9_u5E94_u4E8E_24_5Crho_28A_29_24_u7684_u975E_u8D1F_u7279_u5F81_u5411_u91CF_u3002" class="headerlink" title="定理9. 设A是一个非负矩阵，则$\rho(A)$是A的特征值，且A有一个对应于$\rho(A)$的非负特征向量。"></a>定理9. 设A是一个非负矩阵，则$\rho(A)$是A的特征值，且A有一个对应于$\rho(A)$的非负特征向量。</h6><p>Proof：设A的阶数为n，定理对$n=1$是平凡地成立。下面设$n=2$，用J表示元素全为1的矩阵。<br>对于正整数k，记<span>$A_k = A + \frac{1}{k} J$</span><!-- Has MathJax -->是一个正矩阵，由Perron-Frobenius定理，<span>$A_k$</span><!-- Has MathJax -->在<span>$\Omega _n = \lbrace x \in \mathbf{R} _+ ^n | \sum _{i=1} ^n = 1 \rbrace$</span><!-- Has MathJax -->中有唯一一个对应于<span>$\rho(A_k)$</span><!-- Has MathJax -->的特征向量$x^k$<br>因为向量序列$\lbrace x^k \rbrace $有界因此，由Bolzano-Weierstrass定理,$\lbrace x^k \rbrace $有收敛子列<span>$\lbrace x^{k_i} \rbrace: \lim _{i \to \infty } = x$</span><!-- Has MathJax -->。显然<span>$x \in \Omega _n$</span><!-- Has MathJax -->因此<span>$$A _{k_i}x^{k _i} = 
\rho(A _{k _i}) x^{k _i}$$</span><!-- Has MathJax --><br>注意到<span>$A _{k_i} \to A , \rho(A _{k _i}) \to \rho(A)$</span><!-- Has MathJax --> 因此$i \to \infty$得到$Ax = \rho(A)x$，证毕。</p>
<p>至此，Prron-Frobenius定理介绍完毕。下面介绍一个非负矩阵特征值的界。<br>定理10 设A是一个n阶矩阵非负矩阵，则<br><span>$$\min_{1 \leq i \leq n} r_i \leq \rho(A) 
\leq \max_{1 \leq i \leq n} r_i$$</span><!-- Has MathJax --><br><span>$$\min_{1 \leq i \leq n} c_i \leq \rho(A) 
\leq \max_{1 \leq i \leq n} c_i$$</span><!-- Has MathJax --><br>其中<span>$r_i, c_j$</span><!-- Has MathJax -->分别为A的第i行和和第j列和。<br>Proof：设x是$A^T$的一个Perron向量(对应于谱半径的非负特征向量)。因为$\rho(A^T)=\rho(A)$从$A^Tx=\rho(A)x$得<br><span>$$\rho(A)x_i = \sum_{k=1}^n a_{ki}x_k 
\qquad i = 1,\cdots,n.$$</span><!-- Has MathJax --><br>将这些等式相加得到<span>$\rho(A) \sum_{i=1}^n x_i =\sum_{k=1}^n r_k x_k$</span><!-- Has MathJax -->，即<br><span>$$\rho(A)= 
\frac{\sum_{k=1}^n r_k x_k }{\sum_{i=1}^n x_i}$$</span><!-- Has MathJax --><br>证毕。</p>
<h6 id="u5B9A_u740611_28Wielandt_29__u8BBEA_u662Fn_28n_26gt_3B1_29_u9636_u4E0D_u53EF_u7EA6_u975E_u8D1F_u77E9_u9635_uFF0C_u4E14_24_7CB_7C__5Cleq_A_24__u5219_u5BF9_u4E8EB_u7684_u4EFB_u4F55_u7279_u5F81_u503C_24_5Clambda_24_u6709"><a href="#u5B9A_u740611_28Wielandt_29__u8BBEA_u662Fn_28n_26gt_3B1_29_u9636_u4E0D_u53EF_u7EA6_u975E_u8D1F_u77E9_u9635_uFF0C_u4E14_24_7CB_7C__5Cleq_A_24__u5219_u5BF9_u4E8EB_u7684_u4EFB_u4F55_u7279_u5F81_u503C_24_5Clambda_24_u6709" class="headerlink" title="定理11(Wielandt) 设A是n(n&gt;1)阶不可约非负矩阵，且$|B| \leq A$ 则对于B的任何特征值$\lambda$有"></a>定理11(Wielandt) 设A是n(n&gt;1)阶不可约非负矩阵，且$|B| \leq A$ 则对于B的任何特征值$\lambda$有</h6><span>$$|\lambda| \leq 
\rho(A)$$</span><!-- Has MathJax -->
<p>Proof：设$Bx=\lambda x$则$|B||x| \geq |\lambda||x|$,但是$|B| \leq A$，所以$|\lambda| |x| \leq |B||x| \leq A |x|$，由引理5.2和8知<br><span>$$|\lambda| \leq f_A(|x|) 
\leq \rho(A)$$</span><!-- Has MathJax --><br>证毕。</p>
<p>根据谱半径的连续性，我们马上有如下推论</p>
<ol>
<li>若矩阵A非负，且$|B| \leq A$,则$\rho(B) \leq \rho(A)$</li>
<li>对任意矩阵A，$\rho(A) \leq \rho(|A|)$.(这个直接证明也可以)</li>
</ol>
<blockquote>
<p>本文源自詹兴致所著的《矩阵论》第六章。</p>
</blockquote>
<p>定理虽然很长但是整个过程十分优美，思路十分清晰，仔细分析每一步还是很容易看懂的，并且在证明的过程中就能体会为什么一开始要提出“非负不可约矩阵”的概念了，然后应用连续性把一些结果推广到非负矩阵。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1907年O.Perron发现正矩阵的谱有特别有趣的性质。G.Frobenius在1908-1912年间将Perron的工作推广到不可约非负矩阵的情形，并得到了新的进一步结果。Ferron-Frobenius理论有很多证明方式，下面介绍H.Wielandt的优美证明。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shur定理]]></title>
    <link href="http://yoursite.com/2015/12/16/Shur%E5%AE%9A%E7%90%86/"/>
    <id>http://yoursite.com/2015/12/16/Shur定理/</id>
    <published>2015-12-16T14:10:14.000Z</published>
    <updated>2016-01-26T02:19:05.000Z</updated>
    <content type="html"><![CDATA[<p>在研究一个数学对象时，我们经常会对它进行分类。比如我们通常把数分为：实数，虚数；实数又分成有理数，无理数；当然也有按照正负来分的。还有整数分成素数（也叫质数）和合数，等等。现在我们谈谈矩阵的分类，以下默认矩阵是方的。<br><a id="more"></a></p>
<h4 id="u6570_u5B66_u4E2D_u5206_u7C7B_u4E00_u822C_u662F_u6309_u7167_u7B49_u4EF7_u5173_u7CFB_u5212_u5206_u7B49_u4EF7_u7C7B_u7684_u3002"><a href="#u6570_u5B66_u4E2D_u5206_u7C7B_u4E00_u822C_u662F_u6309_u7167_u7B49_u4EF7_u5173_u7CFB_u5212_u5206_u7B49_u4EF7_u7C7B_u7684_u3002" class="headerlink" title="数学中分类一般是按照等价关系划分等价类的。"></a>数学中分类一般是按照等价关系划分等价类的。</h4><p>所谓等价关系其实就是满足反身性，对称性，传递性的二元关系（总结一下我们等于号的全部性质就知道了）<br>矩阵中最常见的三种等价关系分别是</p>
<ol>
<li>相抵等价—初等变换</li>
<li>合同等价—合同变换</li>
<li>相似等价—相似变换</li>
</ol>
<p>相抵等价完全由秩确定，合同变换我们一般只针对实对称矩阵处理。相似变化是我们讨论最多的也是最复杂的，我们总想把复杂的东西变简单，对于一个矩阵我们总想做变换把它变成最简单形式（称为标准型），相抵等价的标准型和对称矩阵合同等价的标准型都十分简单，但是很不幸的也是最幸运的是，并非所有的矩阵都可以相似于对角阵，相似变换标准型称为若尔当标准型，以纪念若尔当对矩阵相似变换所做的贡献。</p>
<p>然而今天主题并不是上面的任何一种，而是由伟大的数学家<a href="https://en.wikipedia.org/wiki/Issai_Schur" target="_blank" rel="external">Issai Schur</a>提出的酉相似，酉变换的概念和相应定理。</p>
<h4 id="u4EFB_u610F_u590D_u65B9_u9635_u9149_u76F8_u4F3C_u4E8E_u4E0A_u4E09_u89D2_u77E9_u9635"><a href="#u4EFB_u610F_u590D_u65B9_u9635_u9149_u76F8_u4F3C_u4E8E_u4E0A_u4E09_u89D2_u77E9_u9635" class="headerlink" title="任意复方阵酉相似于上三角矩阵"></a>任意复方阵酉相似于上三角矩阵</h4><h6 id="u9149_u77E9_u9635_u548C_u9149_u76F8_u4F3C"><a href="#u9149_u77E9_u9635_u548C_u9149_u76F8_u4F3C" class="headerlink" title="酉矩阵和酉相似"></a>酉矩阵和酉相似</h6><p>一个矩阵称为酉矩阵，如果它的共轭转置是它的逆。<br>复矩阵A与B称为酉相似的，如果存在酉矩阵U使得$B=U^<em> AU$<br>这里$U^</em>$表示U的共轭转置。</p>
<h6 id="u5B9A_u74061-__u5BF9_u4EFB_u610F_u590D_u65B9_u9635A_uFF0C_u5B58_u5728_u9149_u77E9_u9635U_u4F7F_u5F97"><a href="#u5B9A_u74061-__u5BF9_u4EFB_u610F_u590D_u65B9_u9635A_uFF0C_u5B58_u5728_u9149_u77E9_u9635U_u4F7F_u5F97" class="headerlink" title="定理1. 对任意复方阵A，存在酉矩阵U使得"></a>定理1. 对任意复方阵A，存在酉矩阵U使得</h6><span>$$A = U \left( \begin{matrix} 
\lambda_1 &amp; * &amp; * &amp; * \\
 &amp; \lambda_2 &amp; * &amp; * \\
 &amp; &amp; \ddots &amp; * \\
 &amp; &amp; &amp;  \lambda_n
\end{matrix} \right)U^*$$</span><!-- Has MathJax -->
<p>其中 <span>$\lambda_1,\lambda_2,\cdots,\lambda_n$</span><!-- Has MathJax --> 为A的全部特征值。<br>Proof：设 $\alpha_1$ 是A的特征值 $\lambda_1$ 对应的特征向量，将 $\alpha_1$ 扩充为$\mathbf{C}^n$的一组标准正交基 <span>$P=(\alpha_1,\alpha_2,\cdots,\alpha_n)$</span><!-- Has MathJax --> ，则<span>$A = P \left( \begin{matrix} \lambda_1 &amp; * \\ \mathbf{0} &amp; B \end{matrix} \right)P^*$</span><!-- Has MathJax --> 。对复矩阵的阶数应用数学归纳法，存在n-1阶酉矩阵Q使得<br><span>$$B = Q \left( \begin{matrix} \lambda_2 &amp; * &amp; *  \\
 &amp; \ddots &amp; * \\
 &amp; &amp; \lambda_n \end{matrix} \right)Q^*$$</span><!-- Has MathJax --><br>因此<br><span>$$A = U \left( \begin{matrix} 
\lambda_1 &amp; * &amp; * &amp; * \\
 &amp; \lambda_2 &amp; * &amp; * \\
 &amp; &amp; \ddots &amp; * \\
 &amp; &amp; &amp;  \lambda_n
\end{matrix} \right)U^*$$</span><!-- Has MathJax --><br>其中<span>$U = P \left( \begin{matrix} 1 &amp;  \\ &amp; Q \end{matrix} \right)$</span><!-- Has MathJax -->是n阶酉矩阵。证毕。</p>
<h4 id="u77E9_u9635_u9149_u76F8_u4F3C_u4E8E_u5BF9_u89D2_u9635_u5F53_u4E14_u4EC5_u5F53_u5B83_u662F_u6B63_u89C4_u77E9_u9635"><a href="#u77E9_u9635_u9149_u76F8_u4F3C_u4E8E_u5BF9_u89D2_u9635_u5F53_u4E14_u4EC5_u5F53_u5B83_u662F_u6B63_u89C4_u77E9_u9635" class="headerlink" title="矩阵酉相似于对角阵当且仅当它是正规矩阵"></a>矩阵酉相似于对角阵当且仅当它是正规矩阵</h4><h6 id="u6B63_u89C4_u77E9_u9635"><a href="#u6B63_u89C4_u77E9_u9635" class="headerlink" title="正规矩阵"></a>正规矩阵</h6><p>矩阵A称为正规矩阵(<em>normal matrix</em>)，如果$ A^ <em>A=AA^ </em> $。显然酉矩阵，Hermite阵，反Hermite阵都是正规矩阵。<br>定理2（Issai Schur）矩阵A酉相似于对角阵的充分必要条件是A是正规矩阵。<br>Proof：必要性显然，下证明充分性，<br>由定理1知，存在酉矩阵U使得：</p>
<span>$$A = U \left( \begin{matrix} 
\lambda_1 &amp; * &amp; * &amp; * \\
 &amp; \lambda_2 &amp; * &amp; * \\
 &amp; &amp; \ddots &amp; * \\
 &amp; &amp; &amp;  \lambda_n
\end{matrix} \right)U^*$$</span><!-- Has MathJax -->
<p>若A是规范矩阵，则<br><span>$$A^* A = U \left( \begin{matrix} 
\overline{\lambda_1} &amp;  &amp;  &amp;  \\
* &amp; \overline{\lambda_2} &amp;  &amp;  \\
* &amp; * &amp; \ddots &amp; \\
* &amp; * &amp; * &amp;  \overline{\lambda_n}
\end{matrix} \right)

\left( \begin{matrix} 
\lambda_1 &amp; * &amp; * &amp; * \\
 &amp; \lambda_2 &amp; * &amp; * \\
 &amp; &amp; \ddots &amp; * \\
 &amp; &amp; &amp;  \lambda_n
\end{matrix} \right)U^*
=
U \left( \begin{matrix} 
\lambda_1 &amp; * &amp; * &amp; * \\
 &amp; \lambda_2 &amp; * &amp; * \\
 &amp; &amp; \ddots &amp; * \\
 &amp; &amp; &amp;  \lambda_n
\end{matrix} \right)
\left( \begin{matrix} 
\overline{\lambda_1} &amp;  &amp;  &amp;  \\
* &amp; \overline{\lambda_2} &amp;  &amp;  \\
* &amp; * &amp; \ddots &amp; \\
* &amp; * &amp; * &amp;  \overline{\lambda_n}
\end{matrix} \right) U^*
=AA^*$$</span><!-- Has MathJax --><br>因此<br><span>$$\left( \begin{matrix} 
\overline{\lambda_1} &amp;  &amp;  &amp;  \\
* &amp; \overline{\lambda_2} &amp;  &amp;  \\
* &amp; * &amp; \ddots &amp; \\
* &amp; * &amp; * &amp;  \overline{\lambda_n}
\end{matrix} \right)

\left( \begin{matrix} 
\lambda_1 &amp; * &amp; * &amp; * \\
 &amp; \lambda_2 &amp; * &amp; * \\
 &amp; &amp; \ddots &amp; * \\
 &amp; &amp; &amp;  \lambda_n
\end{matrix} \right)
=
\left( \begin{matrix} 
\lambda_1 &amp; * &amp; * &amp; * \\
 &amp; \lambda_2 &amp; * &amp; * \\
 &amp; &amp; \ddots &amp; * \\
 &amp; &amp; &amp;  \lambda_n
\end{matrix} \right)
\left( \begin{matrix} 
\overline{\lambda_1} &amp;  &amp;  &amp;  \\
* &amp; \overline{\lambda_2} &amp;  &amp;  \\
* &amp; * &amp; \ddots &amp; \\
* &amp; * &amp; * &amp;  \overline{\lambda_n}
\end{matrix} \right)$$</span><!-- Has MathJax --><br>考虑矩阵两端(1,1)位置得到<br><span>$$\overline{\lambda_1}\lambda_1 ＝ \lambda_1
\overline{\lambda_1}+\sigma^2$$</span><!-- Has MathJax --><br>其中$ \sigma^2 $是上三角矩阵<br><span>$$\left( \begin{matrix} 
\lambda_1 &amp; * &amp; * &amp; * \\
 &amp; \lambda_2 &amp; * &amp; * \\
 &amp; &amp; \ddots &amp; * \\
 &amp; &amp; &amp;  \lambda_n
\end{matrix} \right)$$</span><!-- Has MathJax --><br>的第一行的非对角元绝对值之平方和，因此由$ \sigma^2 $可知上三角矩阵的第一行非对角元全为0，类似的考察矩阵两端(2,2)的位置，一直到(n,n)的位置即可知道上面矩阵是对角阵，证毕。</p>
<p>上述定理给出了酉相似于对角型的充分必要条件，而且条件十分易于判断。整个过程简洁优美。另外由于酉矩阵条件数恒定为1，有其数值稳定性，因此经常用于实际计算中，例如QR方法涉及的两个矩阵变换Househoulder变换和Givens变换都是酉变换。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在研究一个数学对象时，我们经常会对它进行分类。比如我们通常把数分为：实数，虚数；实数又分成有理数，无理数；当然也有按照正负来分的。还有整数分成素数（也叫质数）和合数，等等。现在我们谈谈矩阵的分类，以下默认矩阵是方的。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cayley-Hamilton定理]]></title>
    <link href="http://yoursite.com/2015/12/16/Cayley-Hamilton%E5%AE%9A%E7%90%86/"/>
    <id>http://yoursite.com/2015/12/16/Cayley-Hamilton定理/</id>
    <published>2015-12-16T04:37:33.000Z</published>
    <updated>2016-01-20T13:14:37.000Z</updated>
    <content type="html"><![CDATA[<p>大一学了矩阵之后,一直很喜欢它，因为它形式简洁优美，又不缺乏技巧，是抽象和具体的桥梁，又有其实用性，成为现代数学最基础的工具之一。个人认为，矩阵中最优美的定理非Cayley-Hamilton定理（矩阵的特征多项式是它的一个化零多项式）莫属了。详细表述和证明如下：</p>
<a id="more"></a>
<p>n阶矩阵A的特征多项式为：<br><span>$$\phi(\lambda)=det(\lambda I - A) = a_n \lambda^n +
a_{n-1} \lambda^{n-1} + \cdots + a_1 \lambda + a_0$$</span><!-- Has MathJax --></p>
<p>设$\lambda I - A$的伴随矩阵为B，则B中元素为关于$\lambda$的次数小于n的多项式，不妨设<br><span>$$B = \lambda^{n-1} B_ {n-1} + \lambda^{n-2} B_ {n-2}
+ \cdots + \lambda B_1 + B_0$$</span><!-- Has MathJax --></p>
<p>所以<br><span>$$(\lambda I - A)B = \lambda^n B_ {n-1} + \lambda^{n-1} (B_ {n-2} - AB_ {n-1})
+ \cdots + \lambda (B_0 - AB_1) - AB_0$$</span><!-- Has MathJax --><br>又因为B是A的伴随矩阵，我们有<span>$(\lambda I - A)B = det(\lambda I - A) I$</span><!-- Has MathJax --></p>
<p>比较系数得到<br><span>$$\left\{ 
\begin{array}{l} 
B_ {n-1} = a_n I \\
B_ {n-2} - AB_ {n-1} = a_{n-1} I \\
\cdots \\
B_0 - AB_1 = a_1 I \\
-AB_0 = a_0 I
\end{array} \right.$$</span><!-- Has MathJax --><br>对上式分别左乘<span>$A^n,A^{n-1},\cdots,A,I$</span><!-- Has MathJax -->得到：</p>
<span>$$\left\{ 
\begin{array}{l} 
A^n B_ {n-1} = a_n A^n \\
A^{n-1} B_ {n-2} - A^n B_ {n-1} = a_{n-1} A^{n-1} \\
\cdots \\
A B_0 - A^2 B_1 = a_1 A \\
-AB_0 = a_0 I
\end{array} \right.$$</span><!-- Has MathJax -->
<p>再将上式相加得到最终结果</p>
<span>$$\phi(A)= a_ n A^n + a_{n-1} A^{n-1} + \cdots + a_1 A +
a_0 I = \mathbf{0}$$</span><!-- Has MathJax -->
<p>上述定理优美在于从形式上，<span>$\phi(\lambda)=det(\lambda I - A)$</span><!-- Has MathJax -->取 <span>$\lambda = A$</span><!-- Has MathJax -->带入恰好也是0（注意数字0和零矩阵的差别），虽然说这样做是完全没有道理。作为直接推论我们知道，一个n阶方阵的任何次方都可以被它的不超过n次的幂线性表出。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>大一学了矩阵之后,一直很喜欢它，因为它形式简洁优美，又不缺乏技巧，是抽象和具体的桥梁，又有其实用性，成为现代数学最基础的工具之一。个人认为，矩阵中最优美的定理非Cayley-Hamilton定理（矩阵的特征多项式是它的一个化零多项式）莫属了。详细表述和证明如下：</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[仅在一点连续的函数例子]]></title>
    <link href="http://yoursite.com/2015/12/16/%E4%BB%85%E5%9C%A8%E4%B8%80%E7%82%B9%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%87%BD%E6%95%B0%E4%BE%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2015/12/16/仅在一点连续的函数例子/</id>
    <published>2015-12-15T16:26:38.000Z</published>
    <updated>2015-12-15T16:53:29.000Z</updated>
    <content type="html"><![CDATA[<p>在一元微积分中，有一个广为人知的结论：一元函数在一点可导，必在该点连续，即可导必连续。</p>
<p>自然会有这样一个问题：</p>
<pre><code>一元函数在一点可导能否推出它在该点的一个小邻域连续呢？
</code></pre><p>这个想法是很自然的，不严格的思考可能会认为应该是对的,但是它并不成立。下面给出一个反例：</p>
<p>\[ f(x) = x^2 D(x) = \left\{<br>\begin{array}{ll}<br>0 &amp; x \in \mathbb{Q} \\<br>x^2 &amp; x \notin \mathbb{Q}<br>\end{array} \right. \]</p>
<p>其中$D(x)$为Dirichlet函数。<br><a id="more"></a><br>容易验证函数$f(x)$在$x=0$处可导，但在$x \neq 0$处不连续。即否定了上述问题。</p>
<p>最后，类似地，我们还可以通过Dirichlet函数构造$\mathbb{R}$上一些仅在有限个点连续的函数。也可以通过周期函数构造仅在所有整数点连续的函数。但是由Baire纲定理可以证明，不存在在所有有理数点连续，无理点间断的函数。最后Riemann函数给出了一个在所有有理数点间断，无理点连续的函数。这些反例使得人们对函数连续的概念有了更感性的认识。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在一元微积分中，有一个广为人知的结论：一元函数在一点可导，必在该点连续，即可导必连续。</p>
<p>自然会有这样一个问题：</p>
<pre><code>一元函数在一点可导能否推出它在该点的一个小邻域连续呢？
</code></pre><p>这个想法是很自然的，不严格的思考可能会认为应该是对的,但是它并不成立。下面给出一个反例：</p>
<p>\[ f(x) = x^2 D(x) = \left\{<br>\begin{array}{ll}<br>0 &amp; x \in \mathbb{Q} \\<br>x^2 &amp; x \notin \mathbb{Q}<br>\end{array} \right. \]</p>
<p>其中$D(x)$为Dirichlet函数。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[计算器程序]]></title>
    <link href="http://yoursite.com/2015/12/15/%E8%AE%A1%E7%AE%97%E5%99%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2015/12/15/计算器程序/</id>
    <published>2015-12-15T15:31:38.000Z</published>
    <updated>2015-12-15T15:55:04.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u8BA1_u7B97_u5668_u5230_u5904_u90FD_u6709_uFF0C_u6709_u5565_u597D_u5199_u7684_u5462_uFF1F"><a href="#u8BA1_u7B97_u5668_u5230_u5904_u90FD_u6709_uFF0C_u6709_u5565_u597D_u5199_u7684_u5462_uFF1F" class="headerlink" title="计算器到处都有，有啥好写的呢？"></a>计算器到处都有，有啥好写的呢？</h4><p>我们在写程序时，对于长串计算，我们通常直接输入了，让计算机高级语言（例如C++）给我们算就行了。但是，仔细想想这件事其实并不简单。</p>
<pre><code>ps:最处想做这件事的原因是：我在大学想写一个带GUI界面的计算器，就在这里被卡住了。
</code></pre><p>其实这是一个很有名的问题，大家有兴趣可以搜一下 <a href="http://baike.baidu.com/link?url=K67J7hWFkpdwOzjAA-nalFK4JqnnLI5TPtK1Dx7dOBn0P5WhAsq09j0e4qBI590vomEWc0w2gtCFWreeta0gr_" target="_blank" rel="external">逆波兰式</a><br><a id="more"></a></p>
<h4 id="u9006_u6CE2_u5170_u5F0F"><a href="#u9006_u6CE2_u5170_u5F0F" class="headerlink" title="逆波兰式"></a>逆波兰式</h4><p>逆波兰式即为后缀表达式，我们生活中算数表达式一般都是中序表达式。人类易于理解中序表达式，但计算机更容易处理后缀表达式。</p>
<h4 id="u76F4_u5954_u89E3_u51B3_u65B9_u6848"><a href="#u76F4_u5954_u89E3_u51B3_u65B9_u6848" class="headerlink" title="直奔解决方案"></a>直奔解决方案</h4><p>我们的做法基本分</p>
<ol>
<li>确定好符号集和它们的优先级；</li>
<li>中序表达式转化成后缀表达式；</li>
<li>根据后缀表达式得到最终结果。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span>  </span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x7fffffff</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;    <span class="comment">//set priority level  </span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">'='</span>||a==<span class="string">'('</span>)  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">'+'</span>||a==<span class="string">'-'</span>)  <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">'*'</span>||a==<span class="string">'/'</span>)  <span class="keyword">return</span> <span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getSuffixExpression</span><span class="params">(<span class="built_in">string</span> a)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; ope;  </span><br><span class="line">    ope.push(<span class="string">'='</span>);  </span><br><span class="line">    <span class="built_in">string</span> ans;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=a.size();++i)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=<span class="string">'0'</span>&amp;&amp;a[i]&lt;=<span class="string">'9'</span>)&#123;  </span><br><span class="line">            ans.push_back(a[i]);  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">'('</span>)&#123;  </span><br><span class="line">            ope.push(<span class="string">'('</span>);  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">')'</span>)&#123;  </span><br><span class="line">            <span class="keyword">while</span>(!ope.empty()&amp;&amp;ope.top()!=<span class="string">'('</span>)&#123;  </span><br><span class="line">                ans.push_back(ope.top());  </span><br><span class="line">                ope.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            ope.pop();<span class="comment">// push left bracket  </span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]!=<span class="string">'+'</span>&amp;&amp;a[i]!=<span class="string">'-'</span>&amp;&amp;a[i]!=<span class="string">'*'</span>&amp;&amp;a[i]!=<span class="string">'/'</span>)&#123;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;endl;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pre(a[i])&gt;pre(ope.top()))&#123;  </span><br><span class="line">            ope.push(a[i]);  </span><br><span class="line">            ans.push_back(<span class="string">' '</span>);  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">while</span>(pre(a[i])&lt;=pre(ope.top()))&#123;  </span><br><span class="line">                ans.push_back(ope.top());  </span><br><span class="line">                ope.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            ope.push(a[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(ope.top()!=<span class="string">'='</span>)&#123;  </span><br><span class="line">        ans.push_back(ope.top());  </span><br><span class="line">        ope.pop();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">(<span class="built_in">string</span> a)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">string</span> b=getSuffixExpression(a);  </span><br><span class="line">    <span class="keyword">if</span>(b.empty())   <span class="keyword">return</span> INF;  </span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=b.size();++i)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(b[i]==<span class="string">' '</span>)   <span class="keyword">continue</span>;  </span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=<span class="string">'0'</span>&amp;&amp;b[i]&lt;=<span class="string">'9'</span>)&#123;  </span><br><span class="line">            <span class="keyword">int</span> t=<span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">while</span>(i!=b.size()&amp;&amp;b[i]&gt;=<span class="string">'0'</span>&amp;&amp;b[i]&lt;=<span class="string">'9'</span>)&#123;  </span><br><span class="line">                t=t*<span class="number">10</span>+b[i++]-<span class="string">'0'</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            --i;  </span><br><span class="line">            s.push(t);  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">int</span> x,y;  </span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;  </span><br><span class="line">                y=s.top();  </span><br><span class="line">                s.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;  </span><br><span class="line">                x=s.top();  </span><br><span class="line">                s.pop();  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;endl;  </span><br><span class="line">                <span class="keyword">return</span> INF;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">switch</span>(b[i])&#123;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:  </span><br><span class="line">                s.push(x+y);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:  </span><br><span class="line">                s.push(x-y);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:  </span><br><span class="line">                s.push(x*y);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:  </span><br><span class="line">                s.push(x/y);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> ans=s.top();  </span><br><span class="line">    s.pop();  </span><br><span class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> ans;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">return</span> INF;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">string</span> a;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(get_ans(a)!=INF)&#123;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;get_ans(a)&lt;&lt;endl;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u8BA1_u7B97_u5668_u5230_u5904_u90FD_u6709_uFF0C_u6709_u5565_u597D_u5199_u7684_u5462_uFF1F"><a href="#u8BA1_u7B97_u5668_u5230_u5904_u90FD_u6709_uFF0C_u6709_u5565_u597D_u5199_u7684_u5462_uFF1F" class="headerlink" title="计算器到处都有，有啥好写的呢？"></a>计算器到处都有，有啥好写的呢？</h4><p>我们在写程序时，对于长串计算，我们通常直接输入了，让计算机高级语言（例如C++）给我们算就行了。但是，仔细想想这件事其实并不简单。</p>
<pre><code>ps:最处想做这件事的原因是：我在大学想写一个带GUI界面的计算器，就在这里被卡住了。
</code></pre><p>其实这是一个很有名的问题，大家有兴趣可以搜一下 <a href="http://baike.baidu.com/link?url=K67J7hWFkpdwOzjAA-nalFK4JqnnLI5TPtK1Dx7dOBn0P5WhAsq09j0e4qBI590vomEWc0w2gtCFWreeta0gr_">逆波兰式</a><br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[产生520的复杂代码]]></title>
    <link href="http://yoursite.com/2015/12/15/%E4%BA%A7%E7%94%9F520%E7%9A%84%E5%A4%8D%E6%9D%82%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2015/12/15/产生520的复杂代码/</id>
    <published>2015-12-15T15:23:16.000Z</published>
    <updated>2015-12-15T15:31:24.000Z</updated>
    <content type="html"><![CDATA[<p>想想我当初也是厉害，貌似是在2014年情人节在网吧写的代码，简直强的不行。<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a, b) memset(a, b, sizeof(a))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(-<span class="number">1.0</span>);</span><br><span class="line"><span class="comment">/**********************************</span><br><span class="line">*</span><br><span class="line">* composed by CZP10110057 at ECUST</span><br><span class="line">*</span><br><span class="line">***********************************/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5000006</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000007</span>;</span><br><span class="line"><span class="keyword">bool</span> temp[N];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">700000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    p[t++]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> kill=<span class="keyword">int</span>(<span class="built_in">sqrt</span>(MAX+<span class="number">0.1</span>))+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;kill;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!temp[i&gt;&gt;<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i;j&lt;MAX;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">                temp[j&gt;&gt;<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kill=MAX&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;kill;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!temp[i])&#123;</span><br><span class="line">            p[t++]=i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r*=x;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        x*=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	isprime();</span><br><span class="line">	<span class="keyword">int</span> myHeart=<span class="number">1</span>;</span><br><span class="line">	myHeart*=p[mypow(p[<span class="number">0</span>],p[<span class="number">0</span>]*p[<span class="number">0</span>])];</span><br><span class="line">	myHeart*=p[<span class="number">2</span>]*mypow(p[<span class="number">0</span>],p[<span class="number">1</span>]);</span><br><span class="line">	myHeart*=p[p[mypow(p[<span class="number">2</span>],p[<span class="number">0</span>])]];</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;myHeart&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>想想我当初也是厉害，貌似是在2014年情人节在网吧写的代码，简直强的不行。<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[素数筛选]]></title>
    <link href="http://yoursite.com/2015/12/15/%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89/"/>
    <id>http://yoursite.com/2015/12/15/素数筛选/</id>
    <published>2015-12-15T15:07:44.000Z</published>
    <updated>2015-12-15T15:20:09.000Z</updated>
    <content type="html"><![CDATA[<p>判断一个数是否为素数，是一个很古老的问题，这里给出一个素数筛选的函数和调用实例。当然这里也有限制，要求数不能超过1e7。当然适当修改代码或者对于不同的需求可以相应修改达到不同目的。下面代码是提交到hdu2879上排行第一的代码：<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>    //140MS	7772K</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5000006</span>;    <span class="comment">//允许的最大数组为2500*2500</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000007</span>;</span><br><span class="line"><span class="keyword">bool</span> temp[N];</span><br><span class="line"><span class="keyword">int</span> prim[<span class="number">700000</span>];       <span class="comment">// 10^7内的素数不超过700000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isprime</span><span class="params">()</span></span>&#123;          <span class="comment">//可以返回小于MAX的素数个数</span></span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    prim[t++]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> kill=<span class="keyword">int</span>(<span class="built_in">sqrt</span>(<span class="number">1.0</span>*MAX))+<span class="number">1</span>;    <span class="comment">//换时间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;kill;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!temp[i&gt;&gt;<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i;j&lt;MAX;j+=i&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">                temp[j&gt;&gt;<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kill=MAX&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=kill;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!temp[i])&#123;</span><br><span class="line">            prim[t++]=i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">__<span class="function">int64 <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> n,__int64 m)</span></span>&#123;</span><br><span class="line">    __int64 x=<span class="number">2</span>,r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=r*x%m;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        x=x*x%m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//printf("%d\n",isprime());</span></span><br><span class="line">    isprime();</span><br><span class="line">    <span class="keyword">int</span> T,n;</span><br><span class="line">    __int64 m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%I64d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(prim[s]&lt;=n&amp;&amp;prim[s]!=<span class="number">0</span>)&#123;</span><br><span class="line">            r+=n/prim[s++];     <span class="comment">//不会超int</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>,mypow(r,m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该文最早是2014-03-02写在csdn上的，现在转移过来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>判断一个数是否为素数，是一个很古老的问题，这里给出一个素数筛选的函数和调用实例。当然这里也有限制，要求数不能超过1e7。当然适当修改代码或者对于不同的需求可以相应修改达到不同目的。下面代码是提交到hdu2879上排行第一的代码：<br>]]>
    
    </summary>
    
  </entry>
  
</feed>
