<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[0.肆玖]]></title>
  <subtitle><![CDATA[原谅我一生放荡不羁是傻逼]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://dna049.com/"/>
  <updated>2016-04-10T12:40:06.000Z</updated>
  <id>http://dna049.com/</id>
  
  <author>
    <name><![CDATA[dna049]]></name>
    <email><![CDATA[dna049@foxmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[C++ Template dna049]]></title>
    <link href="http://dna049.com/2016/04/10/C-Template-dna049/"/>
    <id>http://dna049.com/2016/04/10/C-Template-dna049/</id>
    <published>2016-04-10T12:40:06.000Z</published>
    <updated>2016-04-10T12:40:06.000Z</updated>
    <content type="html"><![CDATA[<p>突然想到在此留点模板貌似是个不错的选择也 0.0</p>
<blockquote>
<p>虽说程序需求千变万化，但是一些短小精湛的函数块还是很值得整理收藏的。<br><a id="more"></a></p>
</blockquote>
<h3 id="u901A_u7528_u4EE3_u7801_u5757"><a href="#u901A_u7528_u4EE3_u7801_u5757" class="headerlink" title="通用代码块"></a>通用代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6570_u8BBA_u7BC7"><a href="#u6570_u8BBA_u7BC7" class="headerlink" title="数论篇"></a>数论篇</h2><h4 id="Great_Common_divisor"><a href="#Great_Common_divisor" class="headerlink" title="Great Common divisor"></a>Great Common divisor</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(a&amp;&amp;b&amp;&amp;(a&gt;b?a%=b:b%=a));</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span></span>&#123;	<span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL&amp; x,LL&amp; y)</span></span>&#123;    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;    &#125;    LL d=exgcd(b,a%b,x,y);</span><br><span class="line">    LL t=x;x=y;y=t-a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;&#125;</span><br></pre></td></tr></table></figure>
<p>当然用直接 GNU 内建函数 __gcd</p>
<h4 id="u6A21_u4E58_u6CD5_u9006_u5143"><a href="#u6A21_u4E58_u6CD5_u9006_u5143" class="headerlink" title="模乘法逆元"></a>模乘法逆元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a,LL p)</span></span>&#123;     <span class="comment">// 0&lt;a&lt;p and gcd(a,p)=1</span>    <span class="keyword">if</span>(a==<span class="number">1</span>)    <span class="keyword">return</span> <span class="number">1</span>;    <span class="keyword">return</span> (p-p/a)*inv(p%a,p)%p;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5FEB_u901F_u6A21_u52A0_u6CD5_u4E58_u6CD5"><a href="#u5FEB_u901F_u6A21_u52A0_u6CD5_u4E58_u6CD5" class="headerlink" title="快速模加法乘法"></a>快速模加法乘法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul_mod</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;	    LL r=<span class="number">0</span>;    <span class="keyword">while</span>(n)&#123;        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;            r+=x;            <span class="keyword">if</span>(r&gt;=m)    r-=m;        &#125;        n&gt;&gt;=<span class="number">1</span>;x&lt;&lt;=<span class="number">1</span>;        <span class="keyword">if</span>(x&gt;=m)    x-=m;    &#125;    <span class="keyword">return</span> r;&#125;</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;    LL r=<span class="number">1</span>;    <span class="keyword">while</span>(n)&#123;        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) 	r=r*x%p;        n&gt;&gt;=<span class="number">1</span>;  	x=x*x%p;    &#125;    <span class="keyword">return</span> r;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6A21_u6C42_u548C"><a href="#u6A21_u6C42_u548C" class="headerlink" title="模求和"></a>模求和</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LL getSum(LL a,LL n,LL p)&#123; //    a^1+a^2+...+a^n mod p(suit for matrix)    LL r=0,x=1;    while(n)&#123;        if(n&amp;1) r=(r+x*pow_mod(a,n,p))%p;        n&gt;&gt;=1;        x=x*(1+pow_mod(a,n,p))%p;    &#125;    return r;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6A21_u5F00_u6839_u53F7"><a href="#u6A21_u5F00_u6839_u53F7" class="headerlink" title="模开根号"></a>模开根号</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LL modsqrt(LL a,LL p)&#123;  // find x such that x*x=a mod p;    if(p==2)    return (a&amp;1)?1:-1;    LL q=(p-1)&gt;&gt;1;    if(pow_mod(a,q,p)!=1)   return -1;  // no answer    if(q&amp;1) return pow_mod(a,(q+1)&gt;&gt;1,p);    LL b,cnt=1;    while(pow_mod(b=rand()%p,q,p)!=1);    while(!(q&amp;1))   ++cnt,q&gt;&gt;=1;    LL s,d,c=pow_mod(b,q,p),t=pow_mod(a,q,p),r=pow_mod(a,(q+1)&gt;&gt;1,p);// r*r=t*a;    while(t!=1)&#123;        for(s=1;s&lt;cnt&amp;&amp;pow_mod(t,1&lt;&lt;s,p)!=1;++s);        d=pow_mod(c,1&lt;&lt;(cnt-s-1),p);        r=(r*d)%p;c=d*d%p;t=t*c%p;        cnt=s;    &#125;    return r&lt;p-r?r:p-r;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u7EC4_u5408_u6570"><a href="#u7EC4_u5408_u6570" class="headerlink" title="组合数"></a>组合数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i+m&gt;n;--i)&#123;</span><br><span class="line">        ans = ans*i/(n-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_C</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>]=C[<span class="number">1</span>][<span class="number">0</span>]=C[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;++i)&#123;  </span><br><span class="line">        c[i][<span class="number">0</span>]=c[i][i]=<span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j)&#123;</span><br><span class="line">        	c[i][j]=c[i-<span class="number">1</span>][j]+c[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="N_u4EE5_u5185_u7D20_u6570_u7B5B"><a href="#N_u4EE5_u5185_u7D20_u6570_u7B5B" class="headerlink" title="N以内素数筛"></a>N以内素数筛</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> np[N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getprime</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) p[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt &amp;&amp; i * p[j] &lt; N; ++j) &#123;</span><br><span class="line">            np[i * p[j]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isp</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;N)	<span class="keyword">return</span> !np[n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;p[i]*p[i]&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%p[i]==<span class="number">0</span>)	<span class="keyword">return</span> <span class="literal">false</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5927_u7D20_u6570Miller-Rabin_u6982_u7387_u5224_u522B_u6CD5"><a href="#u5927_u7D20_u6570Miller-Rabin_u6982_u7387_u5224_u522B_u6CD5" class="headerlink" title="大素数Miller-Rabin概率判别法"></a>大素数Miller-Rabin概率判别法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Witness</span><span class="params">(LL a,LL n,LL m,<span class="keyword">int</span> t)</span></span>&#123;    LL x=pow_mod(a,m,n);    <span class="keyword">if</span>(x==<span class="number">1</span>||x==n-<span class="number">1</span>)    <span class="keyword">return</span> <span class="literal">false</span>;    <span class="keyword">while</span>(t--)&#123;        x=mul(x,x,n);        <span class="keyword">if</span>(x==n-<span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="function"><span class="keyword">bool</span> <span class="title">Rabin</span><span class="params">(LL n)</span></span>&#123;    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)     <span class="keyword">return</span> <span class="literal">false</span>;    <span class="keyword">if</span>(n==<span class="number">2</span>)    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="keyword">if</span>(!(n&amp;<span class="number">1</span>))  <span class="keyword">return</span> <span class="literal">false</span>;    LL m=n-<span class="number">1</span>;    <span class="keyword">int</span> t=<span class="number">0</span>,cnt=<span class="number">33</span>;    <span class="keyword">while</span>(!(m&amp;<span class="number">1</span>))&#123;        ++t;m&gt;&gt;=<span class="number">1</span>;    &#125;    <span class="keyword">while</span>(cnt--)&#123;        LL a=rand()%(n-<span class="number">1</span>)+<span class="number">1</span>;        <span class="keyword">if</span>(Witness(a,n,m,t))    <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5927_u6574_u6570_u7684_u6700_u5C0F_u7D20_u56E0_u5B50"><a href="#u5927_u6574_u6570_u7684_u6700_u5C0F_u7D20_u56E0_u5B50" class="headerlink" title="大整数的最小素因子"></a>大整数的最小素因子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">pollard</span><span class="params">(LL n,<span class="keyword">int</span> c)</span></span>&#123;    LL x=rand()%(n-<span class="number">1</span>)+<span class="number">1</span>;    LL y=x,i=<span class="number">1</span>,k=<span class="number">2</span>;    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;        x=(mul(x,x,n)+c)%n;        LL d=gcd(y-x+n,n);        <span class="keyword">if</span>(d&gt;<span class="number">1</span>)    <span class="keyword">return</span> d;        <span class="keyword">if</span>(++i==k)&#123; <span class="comment">// I don't understand</span>            y=x;            k&lt;&lt;=<span class="number">1</span>;        &#125;    &#125;&#125;LL ans;<span class="function"><span class="keyword">void</span> <span class="title">findp</span><span class="params">(LL n)</span></span>&#123;    <span class="keyword">if</span>(Rabin(n))&#123;        ans=min(ans,n);        <span class="keyword">return</span>;    &#125;    LL p=n;    <span class="keyword">while</span>(p&gt;=n) p=pollard(p,rand() % (n-<span class="number">1</span>) +<span class="number">1</span>);    findp(p);    findp(n/p);&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Mobius_function"><a href="#Mobius_function" class="headerlink" title="Mobius function"></a>Mobius function</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> np[N];</span><br><span class="line"><span class="keyword">int</span> mu[N],p[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>,cnt = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) &#123;</span><br><span class="line">            p[cnt++] = i;</span><br><span class="line">            mu[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt &amp;&amp; i * p[j] &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = i * p[j];</span><br><span class="line">            np[t] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j])   mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Euler_u2019s_totient_function"><a href="#Euler_u2019s_totient_function" class="headerlink" title="Euler’s totient function"></a>Euler’s totient function</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">phi</span><span class="params">(LL x)</span></span>&#123;    LL r=x;    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;p[i]*p[i]&lt;=x;++i)&#123;        <span class="keyword">if</span>(x%p[i]==<span class="number">0</span>)&#123;            r=r/p[i]*(p[i]-<span class="number">1</span>);            <span class="keyword">while</span>(x%p[i]==<span class="number">0</span>)    x/=p[i];        &#125;    &#125;    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) r=r/x*(x-<span class="number">1</span>);    <span class="keyword">return</span> r;&#125;<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> phi[N];<span class="function"><span class="keyword">void</span> <span class="title">getphi</span><span class="params">()</span></span>&#123;    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i!=N;++i)   phi[i]=i;    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;i+=<span class="number">2</span>)   phi[i]&gt;&gt;=<span class="number">1</span>;    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i+=<span class="number">2</span>)&#123;        <span class="keyword">if</span>(phi[i]!=i)	<span class="keyword">continue</span>;        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j+=i)	phi[j]=phi[j]/i*(i-<span class="number">1</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6C42_u5947_u7D20_u6570_u7684_u4E00_u4E2A_u539F_u6839"><a href="#u6C42_u5947_u7D20_u6570_u7684_u4E00_u4E2A_u539F_u6839" class="headerlink" title="求奇素数的一个原根"></a>求奇素数的一个原根</h4><p>首先，模 $m$ 有原根的充要条件是：$m=2,4,p^a,2p^a$，其中$p$为奇素数。<br>对于求模$p$的原根方法：对 $p-1$ 素因子分解：$p-1 = p_1^{a_1} \cdots p_s^{a_s}$ 若恒有<br>$$ g^{\frac{p-1}{p_i}} \neq 1(mod \; p) $$<br>则 $g$ 是 模$p$的原根。对于 $p^a$ 可以用 $p$ 的原根简单构造，而 $2p^a$ 的原根为 $p^a$ 的原根 与 $p^a$ 的原根和 $p^a$的和中奇数者。(证明见P150《数论基础》潘承洞)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factor</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; p[i]*p[i]&lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%p[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            fact[cnt++] = p[i];</span><br><span class="line">            <span class="keyword">while</span>(n%p[i]==<span class="number">0</span>) n /= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) fact[cnt++] = n;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">proot</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; <span class="comment">// p must be odd prime</span></span><br><span class="line">    <span class="keyword">int</span> cnt = factor(p-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;p;++i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pow_mod(i,(p-<span class="number">1</span>)/fact[j],p)==<span class="number">1</span>)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)    <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>求所有原根见<a href="http://dna049.com/2016/02/16/二次剩余和Guass互反律/">我之前的博文</a></p>
</blockquote>
<h4 id="u6570_u8BBA_u51FD_u6570_u7684Dirichlet_u4E58_u79EF"><a href="#u6570_u8BBA_u51FD_u6570_u7684Dirichlet_u4E58_u79EF" class="headerlink" title="数论函数的Dirichlet乘积"></a>数论函数的Dirichlet乘积</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Dirichlet&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> a[N],n;</span><br><span class="line">    Dirichlet(<span class="keyword">int</span> _n = <span class="number">0</span>)&#123;</span><br><span class="line">        n=_n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            a[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Dirichlet <span class="keyword">operator</span>*(<span class="keyword">const</span> Dirichlet&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="function">Dirichlet <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i*j&lt;=n;++j)&#123;</span><br><span class="line">                R.a[i*j]=a[i]*A.a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">LL <span class="title">Dirichlet</span><span class="params">(<span class="keyword">int</span> n,LL a[],LL b[])</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">1</span>;s*s&lt;=n;++s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%s==<span class="number">0</span>)&#123;</span><br><span class="line">            ans + = a[s]*b[n/s];</span><br><span class="line">            <span class="keyword">if</span>(s*s!=n)  ans+=b[s]*a[n/s];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u7EBF_u6027_u540C_u4F59_u65B9_u7A0B"><a href="#u7EBF_u6027_u540C_u4F59_u65B9_u7A0B" class="headerlink" title="线性同余方程"></a>线性同余方程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modeq</span><span class="params">(LL a,LL b,LL n)</span></span>&#123; <span class="comment">// a*x=b mod n return x</span>    LL x,y,d;    d=exgcd(a,n,x,y);    <span class="keyword">if</span>(b%d!=<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;    a/=d;n/=d;b/=d;    <span class="keyword">return</span> ((x*b)%n+n)%n;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u4E2D_u56FD_u5269_u4F59_u5B9A_u7406"><a href="#u4E2D_u56FD_u5269_u4F59_u5B9A_u7406" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">chinaRemain</span><span class="params">(<span class="keyword">int</span> n,LL a[],LL m[])</span></span>&#123;<span class="comment">//x=a[i] mod m[i]</span>    LL x,y,a1,a2,m1,m2,d;    a1=a[<span class="number">0</span>],m1=m[<span class="number">0</span>];    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;        a2=a[i],m2=m[i];        d=exgcd(m1,m2,x,y);        <span class="keyword">if</span>((a2-a1)%d!=<span class="number">0</span>)    <span class="keyword">return</span> -<span class="number">1</span>;        a1+=(((a2-a1)/d*x)%m2+m2)%m2*m1;        m1=m1/d*m2;        a1=(a1%m1+m1)%m1;    &#125;    <span class="keyword">return</span> a1;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">double</span> *x,<span class="keyword">double</span> *y,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = len&gt;&gt;<span class="number">1</span>; i &lt;len-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">double</span> tmp=x[i];x[i]=x[j];x[j]=tmp;</span><br><span class="line">            tmp=y[i];y[i]=y[j];y[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = len/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= k)&#123;</span><br><span class="line">            j -= k;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j += k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(<span class="keyword">double</span> *x,<span class="keyword">double</span> *y,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen,<span class="keyword">bool</span> isInverse)</span></span>&#123;</span><br><span class="line">    change(x,y,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">2</span>;step&lt;=len;step&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> half=step&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> theta=PI/half;</span><br><span class="line">        <span class="keyword">double</span> wmx=<span class="built_in">cos</span>(theta),wmy=<span class="built_in">sin</span>(theta);</span><br><span class="line">        <span class="keyword">if</span>(isInverse)   wmy=-wmy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i+=step)&#123;</span><br><span class="line">            <span class="keyword">double</span> wx=<span class="number">1</span>,wy=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;half;++j)&#123;</span><br><span class="line">                <span class="keyword">double</span> cx=x[i+j],cy=y[i+j];</span><br><span class="line">                <span class="keyword">double</span> dx=x[i+j+half],dy=y[i+j+half];</span><br><span class="line">                <span class="keyword">double</span> ex=dx*wx-dy*wy,ey=dx*wy+dy*wx;</span><br><span class="line">                x[i+j]=cx+ex;y[i+j]=cy+ey;</span><br><span class="line">                x[i+j+half]=cx-ex;y[i+j+half]=cy-ey;</span><br><span class="line">                <span class="keyword">double</span> tmp=wx*wmx-wy*wmy;</span><br><span class="line">                wy=wx*wmy+wy*wmx;wx=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isInverse) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        x[i]/=len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5229_u7528FFT_u7684_u591A_u9879_u5F0F_u4E58_u6CD5"><a href="#u5229_u7528FFT_u7684_u591A_u9879_u5F0F_u4E58_u6CD5" class="headerlink" title="利用FFT的多项式乘法"></a>利用FFT的多项式乘法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b,<span class="keyword">int</span> len,<span class="keyword">int</span> loglen,<span class="keyword">bool</span> same)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">        ax[i]=a[i];bx[i]=b[i];</span><br><span class="line">        ay[i]=by[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fft(ax,ay,len,loglen,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!same) fft(bx,by,len,loglen,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">            bx[i]=ax[i];by[i]=ay[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">        <span class="keyword">double</span> cx=ax[i]*bx[i]-ay[i]*by[i];</span><br><span class="line">        <span class="keyword">double</span> cy=ax[i]*by[i]+ay[i]*bx[i];</span><br><span class="line">        ax[i]=cx;ay[i]=cy;</span><br><span class="line">    &#125;</span><br><span class="line">    fft(ax,ay,len,loglen,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">        a[i]=(<span class="keyword">int</span>)(ax[i]+<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=q-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        a[i+q-p]=(a[i+q-p]+ta*a[q+i])%M;</span><br><span class="line">        a[i]=(a[i]+tb*a[q+i])%M;</span><br><span class="line">        a[i+q]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u591A_u9879_u5F0F_u7C7B"><a href="#u591A_u9879_u5F0F_u7C7B" class="headerlink" title="多项式类"></a>多项式类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Node&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c,d;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> _c,<span class="keyword">int</span> _d):c(_c),d(_d)&#123;next=<span class="literal">NULL</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Poly&#123;     <span class="comment">// a0+a1*x+..+an*x^n</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="keyword">const</span> Poly&amp; A)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.head-&gt;c==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A.head-&gt;d==<span class="number">0</span>)    os&lt;&lt;<span class="string">"-1"</span>;</span><br><span class="line">            <span class="keyword">if</span>(A.head-&gt;d==<span class="number">1</span>)    os&lt;&lt;<span class="string">"-x"</span>;</span><br><span class="line">            <span class="keyword">if</span>(A.head-&gt;d&gt;<span class="number">1</span>)     os&lt;&lt;<span class="string">"-x^"</span>&lt;&lt;(A.head-&gt;d);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            os&lt;&lt;A.head-&gt;c;</span><br><span class="line">            <span class="keyword">if</span>(A.head-&gt;d==<span class="number">1</span>)    os&lt;&lt;<span class="string">"x"</span>;</span><br><span class="line">            <span class="keyword">if</span>(A.head-&gt;d&gt;<span class="number">1</span>)     os&lt;&lt;<span class="string">"x^"</span>&lt;&lt;(A.head-&gt;d);</span><br><span class="line">        &#125;</span><br><span class="line">        Node* p=A.head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;c&gt;<span class="number">0</span>)      os&lt;&lt;<span class="string">"+"</span>;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;c==-<span class="number">1</span>)    os&lt;&lt;<span class="string">"-"</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;c!=<span class="number">1</span>)     os&lt;&lt;(p-&gt;c);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;d&gt;<span class="number">1</span>)  os&lt;&lt;<span class="string">"x^"</span>&lt;&lt;(p-&gt;d);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;d==<span class="number">1</span>) os&lt;&lt;<span class="string">"x"</span>;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> Size;</span><br><span class="line">    Node *head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Poly()&#123;</span><br><span class="line">        head=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        Size=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        head=<span class="keyword">new</span> Node(x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(x)   Size=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>    Size=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly(<span class="keyword">int</span>* a,<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>) &#123;Poly();<span class="keyword">return</span>;&#125;</span><br><span class="line">        head=<span class="literal">NULL</span>;</span><br><span class="line">        Node* p;</span><br><span class="line">        <span class="keyword">for</span>(Size=n-<span class="number">1</span>;Size!=-<span class="number">1</span>&amp;&amp;a[Size]==<span class="number">0</span>;--Size);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Size;i!=-<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i])&#123;</span><br><span class="line">                p=<span class="keyword">new</span> Node(a[i],i);</span><br><span class="line">                p-&gt;next=head;</span><br><span class="line">                head=p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)  head=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//  if(head==NULL) new (this)poly();</span></span><br><span class="line">    &#125;</span><br><span class="line">    Poly(<span class="keyword">const</span> Poly&amp; A)&#123;</span><br><span class="line">        head=<span class="keyword">new</span> Node(A.head-&gt;c,A.head-&gt;d);</span><br><span class="line">        Size=A.Size;</span><br><span class="line">        Node *Ap=A.head-&gt;next,*p=head,*tp;</span><br><span class="line">        <span class="keyword">while</span>(Ap!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tp=<span class="keyword">new</span> Node(Ap-&gt;c,Ap-&gt;d);</span><br><span class="line">            p-&gt;next=tp;p=tp;</span><br><span class="line">            Ap=Ap-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Poly()&#123;</span><br><span class="line">        del();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node* p;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p=head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span>(head);</span><br><span class="line">            head=p;</span><br><span class="line">        &#125;</span><br><span class="line">        Size=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Poly&amp; A)&#123;</span><br><span class="line">        del();</span><br><span class="line">        Size=A.Size;</span><br><span class="line">        head=<span class="keyword">new</span> Node(A.head-&gt;c,A.head-&gt;d);</span><br><span class="line">        Node *Ap=A.head-&gt;next,*p=head,*tp;</span><br><span class="line">        <span class="keyword">while</span>(Ap!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tp=<span class="keyword">new</span> Node(Ap-&gt;c,Ap-&gt;d);</span><br><span class="line">            p-&gt;next=tp;p=tp;</span><br><span class="line">            Ap=Ap-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly <span class="keyword">operator</span>+(<span class="keyword">const</span> Poly&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Size&lt;A.Size) <span class="keyword">return</span> add(A,*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span>            <span class="keyword">return</span> add(*<span class="keyword">this</span>,A);</span><br><span class="line">    &#125;</span><br><span class="line">    Poly <span class="keyword">operator</span>-()<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="function">Poly <span class="title">R</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        Node *Rp=R.head;</span><br><span class="line">        <span class="keyword">while</span>(Rp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Rp-&gt;c=-Rp-&gt;c;</span><br><span class="line">            Rp=Rp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly <span class="keyword">operator</span>-(<span class="keyword">const</span> Poly&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Size&lt;A.Size) <span class="keyword">return</span> add(-A,*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span>            <span class="keyword">return</span> add(*<span class="keyword">this</span>,-A);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">mul</span><span class="params">(<span class="keyword">int</span> tc,<span class="keyword">int</span> td)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tc==<span class="number">0</span>)       <span class="keyword">return</span> Poly();</span><br><span class="line">        <span class="keyword">if</span>(Size==-<span class="number">1</span>)    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="function">Poly <span class="title">R</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        Node *Rp=R.head;</span><br><span class="line">        <span class="keyword">while</span>(Rp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Rp-&gt;c*=tc;</span><br><span class="line">            Rp-&gt;d+=td;</span><br><span class="line">            R.Size=Rp-&gt;d;</span><br><span class="line">            Rp=Rp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly <span class="keyword">operator</span>*(Poly&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Poly R;</span><br><span class="line">        Node *Ap=A.head;</span><br><span class="line">        <span class="keyword">while</span>(Ap!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            R=R+mul(Ap-&gt;c,Ap-&gt;d);</span><br><span class="line">            Ap=Ap-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> td)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        Node *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;d&lt;td) p=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>||p-&gt;d&gt;td)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> td)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        Node *p=head;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;d&lt;=td)&#123;</span><br><span class="line">            ans+=p-&gt;c;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Poly <span class="title">add</span><span class="params">(<span class="keyword">const</span> Poly&amp; A,<span class="keyword">const</span> Poly&amp; B)</span></span>&#123;    <span class="comment">//A.Size&gt;=B.Size</span></span><br><span class="line">        <span class="function">Poly <span class="title">R</span><span class="params">(A)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(B.Size==-<span class="number">1</span>)   <span class="keyword">return</span> R;</span><br><span class="line">        Node *Bp=B.head,*Rp=R.head,*tp;</span><br><span class="line">        <span class="keyword">if</span>(R.head-&gt;d&gt;B.head-&gt;d)&#123;</span><br><span class="line">            tp=<span class="keyword">new</span> Node(B.head-&gt;c,B.head-&gt;d);</span><br><span class="line">            tp-&gt;next=R.head;</span><br><span class="line">            Rp=R.head=tp;</span><br><span class="line">            Bp=Bp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(Bp!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Rp-&gt;d==Bp-&gt;d)&#123;</span><br><span class="line">                Rp-&gt;c+=Bp-&gt;c;</span><br><span class="line">                Bp=Bp-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(Rp-&gt;next-&gt;d&gt;Bp-&gt;d)&#123;</span><br><span class="line">                    tp=<span class="keyword">new</span> Node(Bp-&gt;c,Bp-&gt;d);</span><br><span class="line">                    tp-&gt;next=Rp-&gt;next;</span><br><span class="line">                    Rp-&gt;next=tp;Rp=tp;</span><br><span class="line">                    Bp=Bp-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> Rp=Rp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(R.head-&gt;next!=<span class="literal">NULL</span>&amp;&amp;R.head-&gt;c==<span class="number">0</span>)&#123;</span><br><span class="line">            Rp=R.head;</span><br><span class="line">            R.head=Rp-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span>(Rp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(R.head-&gt;c==<span class="number">0</span>)    R.Size=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>                R.Size=R.head-&gt;d;</span><br><span class="line">        Rp=R.head;</span><br><span class="line">        <span class="keyword">while</span>(Rp-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Rp-&gt;next-&gt;c==<span class="number">0</span>)&#123;</span><br><span class="line">                tp=Rp-&gt;next;</span><br><span class="line">                Rp-&gt;next=tp-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span>(tp);</span><br><span class="line">            &#125;</span><br><span class="line">            Rp=Rp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u5927_u6570_u52A0_u4E58_u7C7B"><a href="#u5927_u6570_u52A0_u4E58_u7C7B" class="headerlink" title="大数加乘类"></a>大数加乘类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BigInt&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">262</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> len,a[N];</span><br><span class="line">    BigInt()&#123;</span><br><span class="line">        len=<span class="number">1</span>;clr(a,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt(<span class="keyword">char</span> *s)&#123;</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slen=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">while</span>(slen&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--slen&gt;=<span class="number">0</span>) a[len]=s[slen]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(--slen&gt;=<span class="number">0</span>) a[len]+=<span class="number">10</span>*(s[slen]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(--slen&gt;=<span class="number">0</span>) a[len]+=<span class="number">100</span>*(s[slen]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(--slen&gt;=<span class="number">0</span>) a[len]+=<span class="number">1000</span>*(s[slen]-<span class="string">'0'</span>);</span><br><span class="line">            ++len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[x];</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInt&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        BigInt R;</span><br><span class="line">        R.len=max(len,A.len);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=R.len;++i)&#123;</span><br><span class="line">            res=a[i]+A.a[i]+res;</span><br><span class="line">            R[i]=res%<span class="number">10000</span>;</span><br><span class="line">            res/=<span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;res;res/=<span class="number">10000</span>)  R[R.len++]=res%<span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)<span class="keyword">const</span>&#123;    <span class="comment">//x&lt;1e5</span></span><br><span class="line">        BigInt R;</span><br><span class="line">        <span class="keyword">int</span> res=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">            res+=a[i];</span><br><span class="line">            R[i]=res%<span class="number">10000</span>;</span><br><span class="line">            res/=<span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        R.len=len;</span><br><span class="line">        <span class="keyword">for</span>(;res;res/=<span class="number">10000</span>)  R[R.len++]=res%<span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>-(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)<span class="keyword">const</span>&#123;    <span class="comment">//x&lt;=10000</span></span><br><span class="line">        BigInt R=*<span class="keyword">this</span>;</span><br><span class="line">        R[<span class="number">0</span>]-=x;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(R[k]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            R[k]+=<span class="number">10000</span>;</span><br><span class="line">            R[++k]-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(R.len&gt;<span class="number">1</span>&amp;&amp;R[R.len-<span class="number">1</span>]==<span class="number">0</span>)    --R.len;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">BigInt <span class="title">getHalf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BigInt R=*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=R.len-<span class="number">1</span>;i!=-<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&amp;<span class="number">1</span>) R[i]+=<span class="number">10000</span>;</span><br><span class="line">            x=R[i]&amp;<span class="number">1</span>;</span><br><span class="line">            R[i]&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len&gt;<span class="number">1</span>&amp;&amp;R[R.len-<span class="number">1</span>]==<span class="number">0</span>) --R.len;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)&#123; <span class="comment">//x&lt;=100000;</span></span><br><span class="line">        BigInt R;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)&#123;</span><br><span class="line">            res+=a[i]*x;</span><br><span class="line">            R[i]=res%<span class="number">10000</span>;</span><br><span class="line">            res/=<span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        R.len=len;</span><br><span class="line">        <span class="keyword">if</span>(res) R[R.len++]=res;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[len-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%04d"</span>,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u77E9_u9635_u7C7B"><a href="#u77E9_u9635_u7C7B" class="headerlink" title="矩阵类"></a>矩阵类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">LL mod;</span><br><span class="line"><span class="keyword">class</span> Matrix&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">2</span>; <span class="comment">//col</span></span><br><span class="line">    LL a[N][N];</span><br><span class="line">    Matrix(<span class="keyword">int</span> a00=<span class="number">0</span>,<span class="keyword">int</span> a01=<span class="number">0</span>, <span class="keyword">int</span> a10=<span class="number">0</span>,<span class="keyword">int</span> a11=<span class="number">0</span>)&#123;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>]=a00;a[<span class="number">0</span>][<span class="number">1</span>]=a01;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">0</span>]=a10;a[<span class="number">1</span>][<span class="number">1</span>]=a11;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                R.a[i][j]=a[i][j]+A.a[i][j];</span><br><span class="line">                <span class="keyword">if</span>(R.a[i][j]&gt;=mod)   R.a[i][j]-=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                    R.a[i][j] = (R.a[i][j]+a[i][k]*A.a[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix A,LL n)</span></span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">R</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) R=R*A;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h2><h4 id="u5E76_u67E5_u96C6"><a href="#u5E76_u67E5_u96C6" class="headerlink" title="并查集"></a>并查集</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = x;</span><br><span class="line">    <span class="keyword">while</span>(ans!=p[ans])  ans=p[ans];</span><br><span class="line">    <span class="keyword">while</span>(x!=ans)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = p[x];</span><br><span class="line">        p[x] = ans;</span><br><span class="line">        x = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6570_u72B6_u6570_u7EC4"><a href="#u6570_u72B6_u6570_u7EC4" class="headerlink" title="数状数组"></a>数状数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeArray&#123;</span><br><span class="line">    LL s[N];</span><br><span class="line">    <span class="keyword">int</span> Size;</span><br><span class="line">    TreeArray()&#123;&#125;</span><br><span class="line">    TreeArray(<span class="keyword">int</span> _S):Size(_S)&#123;clr(s,<span class="number">0</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n&amp;(-n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(id&lt;=Size)&#123;</span><br><span class="line">            s[id]+=p;</span><br><span class="line">            id+=lowbit(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        LL r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(id)&#123;</span><br><span class="line">            r+=s[id];</span><br><span class="line">            id-=lowbit(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="u7EBF_u6BB5_u6811"><a href="#u7EBF_u6BB5_u6811" class="headerlink" title="线段树"></a>线段树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line">LL sum[N&lt;&lt;<span class="number">2</span>],col[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    sum[rt]=sum[lrt]+sum[rrt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(col[rt])&#123;</span><br><span class="line">        col[lrt]+=col[rt];</span><br><span class="line">        col[rrt]+=col[rt];</span><br><span class="line">        sum[lrt]+=(m-(m&gt;&gt;<span class="number">1</span>))*col[rt];</span><br><span class="line">        sum[rrt]+=(m&gt;&gt;<span class="number">1</span>)*col[rt];</span><br><span class="line">        col[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;sum[rt]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    col[rt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(lson);</span><br><span class="line">    build(rson);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;R&gt;=r)&#123;</span><br><span class="line">        sum[rt]+=p*(r-l+<span class="number">1</span>);</span><br><span class="line">        col[rt]+=p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(rt,r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=m)      update(L,R,p,lson);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;m)       update(L,R,p,rson);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;R&gt;=r)  <span class="keyword">return</span> sum[rt];</span><br><span class="line">    PushDown(rt,r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=m)    ans+=query(L,R,lson);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;m)     ans+=query(L,R,rson);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RMQ__u6C42_u533A_u95F4_u6700_u5C0F_u503C"><a href="#RMQ__u6C42_u533A_u95F4_u6700_u5C0F_u503C" class="headerlink" title="RMQ 求区间最小值"></a>RMQ 求区间最小值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> RMQ&#123;<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10004</span>;<span class="keyword">public</span>:    <span class="keyword">int</span> n;    <span class="keyword">int</span> a[N][<span class="number">20</span>]; <span class="comment">//a[i][j]=max(a[i][0]---a[i+2^j-1])</span>    RMQ(<span class="keyword">int</span>* s,<span class="keyword">int</span> _n):n(_n)&#123;        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;++i)   a[i][<span class="number">0</span>]=s[i];        <span class="keyword">int</span> len=(<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(n))/<span class="built_in">log</span>(<span class="number">2.0</span>))+<span class="number">2</span>;        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=len;++i)&#123;            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n-(<span class="number">1</span>&lt;&lt;i);++j)&#123;                a[j][i]=max(a[j][i-<span class="number">1</span>],a[j+(<span class="number">1</span>&lt;&lt;(i-<span class="number">1</span>))][i-<span class="number">1</span>]);            &#125;        &#125;    &#125;    <span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;        <span class="keyword">if</span>(r&gt;=n)    r=n-<span class="number">1</span>;        <span class="keyword">if</span>(l&lt;<span class="number">0</span>) l=<span class="number">0</span>;        <span class="keyword">int</span> len=(<span class="keyword">int</span>)(<span class="built_in">log</span>(<span class="keyword">double</span>(r-l+<span class="number">1</span>))/<span class="built_in">log</span>(<span class="number">2.0</span>));        <span class="keyword">return</span> max(a[l][len],a[r-(<span class="number">1</span>&lt;&lt;len)+<span class="number">1</span>][len]);    &#125;&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="u80CC_u5305"><a href="#u80CC_u5305" class="headerlink" title="背包"></a>背包</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> r[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pack</span><span class="params">(<span class="keyword">int</span> cash,<span class="keyword">int</span> num,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">0</span>||w==<span class="number">0</span>||v==<span class="number">0</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>)&#123; <span class="comment">//  0-1背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=cash;i&gt;=v;--i)</span><br><span class="line">            r[i]=max(r[i],r[i-v]+w);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num*v&gt;=cash-v+<span class="number">1</span>)&#123; <span class="comment">//完全背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=v;i&lt;=cash;++i)</span><br><span class="line">            r[i]=max(r[i],r[i-v]+w);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q[MAX],s[MAX],head,tail;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;v;++j)&#123;   <span class="comment">//多重背包</span></span><br><span class="line">        q[<span class="number">0</span>]=r[j];s[<span class="number">0</span>]=head=tail=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,k=j+v;k&lt;=cash;++i,k+=v)&#123;</span><br><span class="line">            q[i]=r[k]-i*w;</span><br><span class="line">            <span class="keyword">while</span>(s[head]&lt;i-num)    ++head;</span><br><span class="line">            <span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[tail]&lt;q[i]) --tail;</span><br><span class="line">            s[++tail]=i;</span><br><span class="line">            q[tail]=q[i];</span><br><span class="line">            r[k]=q[head]+i*w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5B57_u7B26_u4E32_u5339_u914D_u7684Sunday_u7B97_u6CD5"><a href="#u5B57_u7B26_u4E32_u5339_u914D_u7684Sunday_u7B97_u6CD5" class="headerlink" title="字符串匹配的Sunday算法"></a>字符串匹配的Sunday算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ASSIZE=<span class="number">256</span>;</span><br><span class="line"><span class="keyword">int</span> tp[ASSIZE];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getTp</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sLen=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=ASSIZE;++i)&#123;</span><br><span class="line">        tp[i]=sLen+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p=s;*p;++p)&#123;</span><br><span class="line">        tp[*p]=sLen-(p-s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sunday</span><span class="params">(<span class="keyword">char</span> *ps,<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    getTp(s);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *t,*p,*tx=ps;</span><br><span class="line">    <span class="keyword">int</span> pLen=<span class="built_in">strlen</span>(ps);</span><br><span class="line">    <span class="keyword">int</span> sLen=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(tx+sLen&lt;=ps+pLen)&#123;</span><br><span class="line">        <span class="keyword">for</span>(t=tx,p=s;*p;++p,++t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*p!=*t)  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*p==<span class="string">'\0'</span>)    <span class="keyword">return</span> tx-ps;</span><br><span class="line">        tx+=tp[tx[sLen]];       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u5B57_u7B26_u4E32_u5339_u914D_u7684KMP_u7B97_u6CD5"><a href="#u5B57_u7B26_u4E32_u5339_u914D_u7684KMP_u7B97_u6CD5" class="headerlink" title="字符串匹配的KMP算法"></a>字符串匹配的KMP算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">int</span> *next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>,k=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sLen=<span class="built_in">strlen</span>(s)-<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;sLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==-<span class="number">1</span>||s[j]==s[k])&#123;</span><br><span class="line">            next[++j]=++k;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k=next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *p,<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pLen=<span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">int</span> sLen=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> *next=<span class="keyword">new</span> <span class="keyword">int</span>[sLen];</span><br><span class="line">    getNext(s,next);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;pLen&amp;&amp;j&lt;sLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==-<span class="number">1</span>||p[i]==s[j])&#123;</span><br><span class="line">            ++i;++j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] next;</span><br><span class="line">    <span class="keyword">if</span>(j==sLen) <span class="keyword">return</span> i-j;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u4F18_u5148_u961F_u5217_u548C_u5355_u8C03_u6808"><a href="#u4F18_u5148_u961F_u5217_u548C_u5355_u8C03_u6808" class="headerlink" title="优先队列和单调栈"></a>优先队列和单调栈</h4><p>可以使用<a href="http://www.cplusplus.com/reference/" target="_blank" rel="external">C++ STL</a> 的 priority_queue，查找可用 lower_bound 和 upper_bound 。</p>
<h2 id="u56FE_u8BBA"><a href="#u56FE_u8BBA" class="headerlink" title="图论"></a>图论</h2><h4 id="u6700_u5927_u6D41"><a href="#u6700_u5927_u6D41" class="headerlink" title="最大流"></a>最大流</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node&#123;</span><br><span class="line">    <span class="keyword">int</span> t,w,next;</span><br><span class="line">&#125;a[N*N];</span><br><span class="line"><span class="keyword">int</span> n,ss,head[N],p[N],flow[N],c[N],h[N],numh[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    a[ss].t=y;</span><br><span class="line">    a[ss].w=w;</span><br><span class="line">    a[ss].next=head[x];</span><br><span class="line">    head[x]=ss++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow,ans=<span class="number">0</span>,neck,k;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(numh,<span class="number">0</span>,<span class="keyword">sizeof</span>(numh));</span><br><span class="line">    <span class="built_in">memset</span>(p,-<span class="number">1</span>,<span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)   c[i]=head[i];</span><br><span class="line">    numh[<span class="number">0</span>]=n;</span><br><span class="line">    <span class="keyword">int</span> u=s;</span><br><span class="line">    <span class="keyword">while</span>(h[s]&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==t)&#123;</span><br><span class="line">            flow=<span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i!=t;i=a[c[i]].t)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flow&gt;a[c[i]].w)&#123;</span><br><span class="line">                    neck=i;flow=a[c[i]].w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i!=t;i=a[c[i]].t)&#123;</span><br><span class="line">                a[c[i]].w-=flow;</span><br><span class="line">                a[c[i]^<span class="number">1</span>].w+=flow;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=flow;</span><br><span class="line">            u=neck;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(k=c[u];k!=-<span class="number">1</span>;k=a[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k].w&amp;&amp;h[u]==h[a[k].t]+<span class="number">1</span>)   <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k!=-<span class="number">1</span>)&#123;</span><br><span class="line">            c[u]=k;</span><br><span class="line">            p[a[k].t]=u;</span><br><span class="line">            u=a[k].t;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>==--numh[h[u]]) <span class="keyword">break</span>;</span><br><span class="line">            c[u]=head[u];</span><br><span class="line">            k=n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=-<span class="number">1</span>;i=a[i].next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i].w)  k=min(k,h[a[i].t]);</span><br><span class="line">            &#125;</span><br><span class="line">            h[u]=k+<span class="number">1</span>;</span><br><span class="line">            ++numh[h[u]];</span><br><span class="line">            <span class="keyword">if</span>(u!=s)    u=p[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Stoer-Wagner__u6700_u5C0F_u5272"><a href="#Stoer-Wagner__u6700_u5C0F_u5272" class="headerlink" title="Stoer-Wagner 最小割"></a>Stoer-Wagner 最小割</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">102</span>;</span><br><span class="line"><span class="keyword">int</span> p[N],dis[N],<span class="built_in">map</span>[N][N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mincut</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;++i)   p[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">1</span>,s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i!=n;++i)&#123;</span><br><span class="line">            dis[p[i]]=<span class="built_in">map</span>[p[<span class="number">0</span>]][p[i]];</span><br><span class="line">            <span class="keyword">if</span>(dis[p[i]]&gt;dis[p[t]]) t=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        vis[p[<span class="number">0</span>]]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ret&gt;dis[p[t]]) ret=dis[p[t]];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j!=n;++j)&#123;</span><br><span class="line">                    <span class="built_in">map</span>[p[j]][p[s]]+=<span class="built_in">map</span>[p[j]][p[t]];</span><br><span class="line">                    <span class="built_in">map</span>[p[s]][p[j]]=<span class="built_in">map</span>[p[j]][p[s]];</span><br><span class="line">                &#125;</span><br><span class="line">                p[t]=p[--n];</span><br><span class="line">            &#125;</span><br><span class="line">            vis[p[t]]=<span class="literal">true</span>;</span><br><span class="line">            s=t;t=-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j!=n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[p[j]])&#123;</span><br><span class="line">                    dis[p[j]]+=<span class="built_in">map</span>[p[j]][p[s]];</span><br><span class="line">                    <span class="keyword">if</span>(t==-<span class="number">1</span>||dis[p[j]]&gt;dis[p[t]])  t=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6700_u77ED_u8DEFSPFA"><a href="#u6700_u77ED_u8DEFSPFA" class="headerlink" title="最短路SPFA"></a>最短路SPFA</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">2000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1004</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],rehead[N],dist[N],sc,v[N];</span><br><span class="line"><span class="keyword">struct</span> A&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> g;</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> x,<span class="keyword">int</span> y):id(x),g(y)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> A&amp; a)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> g+dist[id]&gt;a.g+dist[a.id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> Node&#123;</span><br><span class="line">    <span class="keyword">int</span> ed;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    e[sc].ed=y;</span><br><span class="line">    e[sc].w=z;</span><br><span class="line">    e[sc].next=head[x];</span><br><span class="line">    head[x]=sc++;</span><br><span class="line">    e[sc].ed=x;</span><br><span class="line">    e[sc].w=z;</span><br><span class="line">    e[sc].next=rehead[y];</span><br><span class="line">    rehead[y]=sc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    v[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=rehead[u];i!=-<span class="number">1</span>;i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> ed=e[i].ed;</span><br><span class="line">            <span class="keyword">if</span>(dist[ed]&gt;dist[u]+e[i].w)&#123;</span><br><span class="line">                dist[ed]=dist[u]+e[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!v[ed])&#123;</span><br><span class="line">                    v[ed]=<span class="literal">true</span>;</span><br><span class="line">                    q.push(ed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v[u]=<span class="literal">false</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u51E0_u4F55"><a href="#u51E0_u4F55" class="headerlink" title="几何"></a>几何</h2><h4 id="u4E8C_u7EF4_u51F8_u5305"><a href="#u4E8C_u7EF4_u51F8_u5305" class="headerlink" title="二维凸包"></a>二维凸包</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const int N=501;</span><br><span class="line">int vc[N];</span><br><span class="line">struct Node&#123;</span><br><span class="line">    int x,y,id;</span><br><span class="line">    bool operator!=(const Node&amp; A)const&#123;</span><br><span class="line">        return x!=A.x||y!=A.y;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator&lt;(const Node&amp; A)const&#123;</span><br><span class="line">        if(y==A.y)  return x&lt;A.x;</span><br><span class="line">        return y&lt;A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N],q[N];</span><br><span class="line">bool crossLeft(const Node&amp; op,const Node&amp; sp,const Node&amp; ep)&#123;</span><br><span class="line">    return (sp.x-op.x)*(ep.y-op.y)&gt;(sp.y-op.y)*(ep.x-op.x);</span><br><span class="line">&#125;</span><br><span class="line">int graham(int n)&#123;</span><br><span class="line">    sort(p,p+n);</span><br><span class="line">    if(n==0)    return 0;q[0]=p[0];</span><br><span class="line">    if(n==1)    return 1;q[1]=p[1];</span><br><span class="line">    if(n==2)    return 2;q[2]=p[2];</span><br><span class="line">    int top=1;</span><br><span class="line">    for(int i=2;i!=n;++i)&#123;</span><br><span class="line">        while(top&amp;&amp;crossLeft(q[top],p[i],q[top-1])) --top;</span><br><span class="line">        q[++top]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int len=top;</span><br><span class="line">    q[++top]=p[n-2];</span><br><span class="line">    for(int i=n-3;i!=-1;--i)&#123;</span><br><span class="line">        while(top!=len&amp;&amp;crossLeft(q[top],p[i],q[top-1]))    --top;</span><br><span class="line">        q[++top]=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u51E0_u7C7B_u6839_u53F7_u7B97_u6CD5"><a href="#u51E0_u7C7B_u6839_u53F7_u7B97_u6CD5" class="headerlink" title="几类根号算法"></a>几类根号算法</h2><h4 id="1-_24s_28n_29__3D__5Csum__7Bi_3D1_7D_5E_7Bn_7D__5Clfloor__5Cfrac_7Bn_7D_7Bi_7D__5Crfloor__24"><a href="#1-_24s_28n_29__3D__5Csum__7Bi_3D1_7D_5E_7Bn_7D__5Clfloor__5Cfrac_7Bn_7D_7Bi_7D__5Crfloor__24" class="headerlink" title="1.$s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $"></a>1.$s(n) = \sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor $</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(LL n)</span></span>&#123; </span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123; </span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        sum += (j-i+<span class="number">1</span>)*(n/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-_24_5Csum__7Bi_3D1_7D_5En__5Clfloor__5Cfrac_7Bn_7D_7Bi_7D__5Crfloor__5Clfloor__5Cfrac_7Bm_7D_7Bi_7D__5Crfloor_f_28i_29_24"><a href="#2-_24_5Csum__7Bi_3D1_7D_5En__5Clfloor__5Cfrac_7Bn_7D_7Bi_7D__5Crfloor__5Clfloor__5Cfrac_7Bm_7D_7Bi_7D__5Crfloor_f_28i_29_24" class="headerlink" title="2.$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$"></a>2.$\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{i} \rfloor f(i)$</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123; <span class="comment">// g[i]=f[i]+g[i-1]</span></span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j;i&lt;=min(n,m);i=j+<span class="number">1</span>)&#123;</span><br><span class="line">		j=min(n/(n/i),m/(m/i)</span><br><span class="line">		sum += LL(n/i)*(m/i)*(g[j]-g[i-<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-_24h_28n_29__3D__5Cfrac_7Bn_28n-1_29_28n-2_29_7D_7B3_7D_-__5Csum__7Bi_3D2_7D_5En_h_28_5Clfloor__5Cfrac_7Bn_7D_7Bi_7D__5Crfloor_29_24"><a href="#3-_24h_28n_29__3D__5Cfrac_7Bn_28n-1_29_28n-2_29_7D_7B3_7D_-__5Csum__7Bi_3D2_7D_5En_h_28_5Clfloor__5Cfrac_7Bn_7D_7Bi_7D__5Crfloor_29_24" class="headerlink" title="3.$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$"></a>3.$h(n) = \frac{n(n-1)(n-2)}{3} - \sum_{i=2}^n h(\lfloor \frac{n}{i} \rfloor)$</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it = mp.find(n);</span><br><span class="line">    <span class="keyword">if</span> (it != mp.end())  <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    <span class="keyword">int</span> r = LL(n)*(n-<span class="number">1</span>)%M*(n-<span class="number">2</span>)%M*inv3%M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>,j;i&lt;=n;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j = n/(n/i);</span><br><span class="line">        r -= LL(j-i+<span class="number">1</span>)*getans(n/i)%M;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>) r+=M;</span><br><span class="line">    &#125;</span><br><span class="line">    mp.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(n,r));</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="To_Be_Continue"><a href="#To_Be_Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>突然想到在此留点模板貌似是个不错的选择也 0.0</p>
<blockquote>
<p>虽说程序需求千变万化，但是一些短小精湛的函数块还是很值得整理收藏的。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[POJ2559 单调栈]]></title>
    <link href="http://dna049.com/2016/04/10/POJ2559-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>http://dna049.com/2016/04/10/POJ2559-单调栈/</id>
    <published>2016-04-10T11:27:49.000Z</published>
    <updated>2016-04-10T11:44:31.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2559" target="_blank" rel="external">POJ</a>上有一到有趣的题：求一个柱状图中面积最大的矩阵面积为多少?<br> 最暴力的方法当然0.0不值一提，下面看看如何用单调栈的方法解决<br><a id="more"></a><br><img src="poj2559.png" alt="poj2559"></p>
<h2 id="u5355_u8C03_u6808_u3002"><a href="#u5355_u8C03_u6808_u3002" class="headerlink" title="单调栈。"></a>单调栈。</h2><h4 id="u7EF4_u62A4_u5355_u8C03_u6808_uFF1A"><a href="#u7EF4_u62A4_u5355_u8C03_u6808_uFF1A" class="headerlink" title="维护单调栈："></a>维护单调栈：</h4><p>进栈操作：每次入栈前先检验栈顶元素和进栈元素x的大小，如果小于x，就让x直接入栈。如果栈顶元素大于等于x,那么出栈，直到栈空或者栈顶元素小于x</p>
<h4 id="u4F8B_u5B50"><a href="#u4F8B_u5B50" class="headerlink" title="例子"></a>例子</h4><p>$ a[] = \lbrace 1 4 5 2 0 \rbrace$</p>
<ol>
<li>初始栈为空，进栈，栈内元素(1)</li>
<li>4大于1，进栈。栈内元素(1,4)</li>
<li>5大于4，进栈。栈内元素(1,4,5)</li>
<li>2小于5,5出栈，2小于4,4出栈，2大于1,进栈，栈内元素(2)</li>
<li>0要入栈，2出栈，0进栈。栈内元素(0)</li>
</ol>
<h4 id="u7528_u9014_u53EF_u4EE5_u5728__24O_28n_29_24__u65F6_u95F4_u5185_u627E_u5230_24i_24_u4F4D_u7F6E_u5DE6_28_u53F3_29_u8FB9_u9996_u6B21_u6BD4_u5B83_u5C0F_u7684_u4F4D_u7F6E_u3002_u8BE6_u89C1POJ2559_u7684_u4EE3_u7801_u6C42_u89E3"><a href="#u7528_u9014_u53EF_u4EE5_u5728__24O_28n_29_24__u65F6_u95F4_u5185_u627E_u5230_24i_24_u4F4D_u7F6E_u5DE6_28_u53F3_29_u8FB9_u9996_u6B21_u6BD4_u5B83_u5C0F_u7684_u4F4D_u7F6E_u3002_u8BE6_u89C1POJ2559_u7684_u4EE3_u7801_u6C42_u89E3" class="headerlink" title="用途可以在 $O(n)$ 时间内找到$i$位置左(右)边首次比它小的位置。详见POJ2559的代码求解"></a>用途可以在 $O(n)$ 时间内找到$i$位置左(右)边首次比它小的位置。详见POJ2559的代码求解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],L[N],R[N],stk[N]; <span class="comment">//L[i]: max x&lt;i s.t. h[x]&lt;x;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monoStack</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; h[stk[top-<span class="number">1</span>]] &gt;= h[j]) --top;</span><br><span class="line">        L[j] = (top == <span class="number">0</span>?<span class="number">0</span>:stk[top-<span class="number">1</span>]);</span><br><span class="line">        stk[top++] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; h[stk[top-<span class="number">1</span>]] &gt;= h[j]) --top;</span><br><span class="line">        R[j] = top == <span class="number">0</span>?n+<span class="number">1</span>:stk[top-<span class="number">1</span>];</span><br><span class="line">        stk[top++] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,h+i);</span><br><span class="line">        &#125;</span><br><span class="line">        monoStack(n);</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            ans = max(ans,LL(h[i])*(R[i]-L[i]-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://poj.org/problem?id=2559">POJ</a>上有一到有趣的题：求一个柱状图中面积最大的矩阵面积为多少?<br> 最暴力的方法当然0.0不值一提，下面看看如何用单调栈的方法解决<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[love math love gcd]]></title>
    <link href="http://dna049.com/2016/04/10/love-math-love-gcd/"/>
    <id>http://dna049.com/2016/04/10/love-math-love-gcd/</id>
    <published>2016-04-10T06:05:22.000Z</published>
    <updated>2016-04-10T10:32:47.000Z</updated>
    <content type="html"><![CDATA[<p>关于gcd的博文已经写过三篇了，为什么还要写呢？(任意中文输入法下输入gcd)你就懂了0.0<br><a id="more"></a></p>
<h2 id="u8BA1_u7B97__24f_28n_29__3D__5Csum__7Bi_3D1_7D_5En__5Csum__7Bj_3D1_7D_5En__5Bgcd_28i_2Cj_29_3D_3D1_5D_24"><a href="#u8BA1_u7B97__24f_28n_29__3D__5Csum__7Bi_3D1_7D_5En__5Csum__7Bj_3D1_7D_5En__5Bgcd_28i_2Cj_29_3D_3D1_5D_24" class="headerlink" title="计算 $f(n) = \sum_{i=1}^n \sum_{j=1}^n [gcd(i,j)==1]$"></a>计算 $f(n) = \sum_{i=1}^n \sum_{j=1}^n [gcd(i,j)==1]$</h2><p>这里给出 $f(n)$ 的两个计算公式。</p>
<p>$$<br>n^2 = \sum_{d=1}^n \sum_{i=1}^{n} \sum_{j=1}^n [gcd(i,j)==d] =<br>\sum_{d=1}^n \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} [gcd(i,j)==1] = \sum_{d=1}^n f(\lfloor \frac{n}{d} \rfloor)<br>$$<br>因此由<a href="http://dna049.com/2016/01/03/Several-Algorithms-of-root-Complex/">之前的博文</a>可用记忆化搜索的方法求出$f(n)$ </p>
<p>$$<br>f(n) = \sum_{i=1}^n \sum_{j=1}^n [gcd(i,j)==1] =<br>\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}  \sum_{d|i,d|j} \mu(d) = \sum_{d=1}^n \mu(d) (\lfloor \frac{n}{d} \rfloor)^2<br>$$<br>因此由<a href="http://dna049.com/2016/01/03/Several-Algorithms-of-root-Complex/">博文</a> 在预处理后可根号算法快速求出。</p>
<p>为什么两个完全不同的式子都可以计算呢。实际上这是由<a href="http://dna049.com/2016/01/20/数论函数的Dirichlet积/">广义Dirchilet</a> 性质决定的。</p>
<h2 id="hdu5663_u4E00_u4E2A_u66F4_u590D_u6742_u7684_u4F8B_u5B50"><a href="#hdu5663_u4E00_u4E2A_u66F4_u590D_u6742_u7684_u4F8B_u5B50" class="headerlink" title="hdu5663一个更复杂的例子"></a>hdu5663一个更复杂的例子</h2><p>计算 $r(n,m)=\sum_{i=1}^n \sum_{j=1}^m f(gcd(i,j))$，其中$f(n)＝0$ 若 $n$ 是平方数，否则为 $1$。<br>解：我们不妨设 $n \leq m$。<br>$$<br>\begin{aligned}<br>r(n,m) &amp;=\sum_{i=1}^n \sum_{j=1}^m f(gcd(i,j)) \\<br>&amp;= \sum_{d=1}^n f(d) \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}  \sum_{t|i,t|j} \mu(t) \\<br>&amp;= \sum_{d=1}^n f(d) \sum_{t=1}^{\lfloor \frac{n}{d} \rfloor} \mu(t) \lfloor \frac{n}{dt} \rfloor \lfloor \frac{m}{dt} \rfloor \\<br>&amp;= \sum_{G=1}^n \lfloor \frac{n}{G} \rfloor \lfloor \frac{m}{G} \rfloor \sum_{t|G} \mu(t)f(\frac{G}{t})<br>\end{aligned}<br>$$<br>据此，我们可以给出下面代码。(上面过程技巧性很强，要充分利用 $\mu$ 的强大力量)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> mu[N],g[N],p[N],np[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) &#123;</span><br><span class="line">            p[cnt++] = i;</span><br><span class="line">            mu[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt &amp;&amp; i * p[j] &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = i * p[j];</span><br><span class="line">            np[t] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p[j])   mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i*i*j&lt;N;++j)&#123;</span><br><span class="line">            g[i*i*j] += mu[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)    g[i]+=g[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        LL ans = LL(n)*m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j;i&lt;=min(n,m);i=j+<span class="number">1</span>)&#123;</span><br><span class="line">            j=min(n/(n/i),m/(m/i));</span><br><span class="line">            ans -= LL(n/i)*(m/i)*(g[j]-g[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于gcd的博文已经写过三篇了，为什么还要写呢？(任意中文输入法下输入gcd)你就懂了0.0<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Lie Algebra]]></title>
    <link href="http://dna049.com/2016/04/08/Lie-Algebra/"/>
    <id>http://dna049.com/2016/04/08/Lie-Algebra/</id>
    <published>2016-04-08T15:10:08.000Z</published>
    <updated>2016-04-08T15:10:08.000Z</updated>
    <content type="html"><![CDATA[<p>近期在整理 Lie Algebra 课的笔记，还是很喜欢这门课的，主要是本科时候矩阵玩的特别6，然后 Lie Algebra 可以认为是矩阵的推广版本。里面的证明技巧性相当强。我之所以喜欢数学很大程度与数学技巧有关。但是我的导师说，这些虽然很有技巧，但是你花时间都是可以处理的，会技巧没什么了不起，脑袋稍微好一点就能做这种事，长期技巧的训练其实意义并不大，应该更关注数学内部的东西，具体说就是一个代数对象的结构，分类，不变量，对象之间的同构。一个概念有哪些等价形式，与其它概念之间的关系，搞清楚这些更为重要，它们的证明只要大致知道怎么过来的就行。我们并不要把证明的细节放在心中，因为我们已经经过了多年的训练，相信我们通过大致步骤就能给出详细的证明，只是花的时间多少罢了。当然初学一个东西，去抠它的细节是无可厚非的。<br>以上纯属废话 0.0<br><a id="more"></a> </p>
<h3 id="u5B9A_u4E49"><a href="#u5B9A_u4E49" class="headerlink" title="定义"></a>定义</h3><p>交换环 $K$ 上的模 $L$，以及一个运算 $L \times L \to L,(x,y) \mapsto [x,y]$ 称为 $x,y$ 的 Lie 括号，或交换子，称 $L$ 是 $K$ 上的 <a href="https://en.wikipedia.org/wiki/Lie_algebra" target="_blank" rel="external">Lie Algebra</a> 如果满足如下公理。<br>L1. $[\cdot,\cdot]$ 是双线性的；<br>L2. $[x,x]=0$ 对任意 $x \in L$ 成立；<br>L3. $[x,[y,z]]+[y,[z,x]]+[z,[x,y]]=0$ (Jacobi 恒等式)</p>
<p>若$[L,L]=0$ 则上面结论显然成立，此时称为 Abelian Lie Algebra。令 $Z(L) = \lbrace x \in L \;|\; [x,L] = 0 \rbrace$</p>
<p>我们通常并不考虑如此一般情形下的 Lie 代数，一般我们令交换环 $K$ 是域 $F$，并且域 $F$ 很多时候要求是代数闭域，且特征为0。另外我们大多考虑 $L$ 是 $F$ 上的有限维线性空间。</p>
<p>子，理想，商，同态，表示等一系列的概念和其它代数结构几乎一致。基本上可以划入范畴中。另外单，半单，Radical等这些概念也于环里面的类似。</p>
<h3 id="u6837_u677F_Lie_Algebra"><a href="#u6837_u677F_Lie_Algebra" class="headerlink" title="样板 Lie Algebra"></a>样板 Lie Algebra</h3><p>对于 $V$ 是 $F$ 上有限维线性空间，用 $End V$ 表示 $V$ 到 $V$ 的线性变换全体按照元素的复合构成了 $F$ 上的线性空间且$dim End V = (dim V)^2$。也构成了 $End V$ 是一个结合F-代数。而任何结合代数都可以诱导一个 Lie 代数。定义 $[x,y]=xy-yx$ 即可。为了跟原来的代数区别，我们用 $\mathbb{gl}(V)$ 代替 $End V$，称为 general linear algebra。它在 $Lie$ 代数中充当的角色很类似于置换群在群中的角色。我们知道半单Lie代数同构于$\mathbb{gl}(V)$ 的一个子Lie代数。</p>
<h3 id="u5BFC_u5B50_u548C_u4F34_u968F_u8868_u793A"><a href="#u5BFC_u5B50_u548C_u4F34_u968F_u8868_u793A" class="headerlink" title="导子和伴随表示"></a>导子和伴随表示</h3><p>我们称一个 $F-$代数 $A$（可以非结合）也可以借助导子(derivation)诱导一个Lie代数，称一个导子是指一个线性映射 $\delta: A \to A$ 满足 $\delta(ab)=\delta(a)b+a\delta(b)$。易知导子 $Der A$ 全体构成了 $End A$ 的一个子空间，由于 $[\delta,\delta’] \in Der A$，因此 $Der A$ 构成了 $\mathbb{gl}(V)$的一个子Lie代数。<br>由于Lie代数 $L$ 也是 $F-$代数,因此我们也可以定义 $Der L$。这是的导子本质上就是Jacobi恒等式的变形。<br>定义 $ad_x: L \to L,y \mapsto [x,y]$，实际上 $ad_x \in Der L$。$L \to Der L,x \mapsto ad_x$ 称为 $L$ 的伴随表示(adiont representation)。</p>
<h3 id="u53EF_u89E3_u548C_u5E42_u96F6"><a href="#u53EF_u89E3_u548C_u5E42_u96F6" class="headerlink" title="可解和幂零"></a>可解和幂零</h3><p>对于给定Lie代数 $L$，我们有理想降链<br>$L^{(0)} = L,L^{(1)}=[L^{(0)},L^{(0)}],\cdots,L^{(i)}=[L^{(i-1)},L^{(i-1)}],\cdots$。若存在 $n$ 使得 $L^{(n)} = 0$ 则称 $L$ 可解(slovable)。</p>
<ol>
<li>若$L$ 可解，$L$ 的子代数和同态像可解</li>
<li>$I$ 是 $L$ 的可解理想，若 $L/I$ 可解，则 $L$ 可解。</li>
<li>$I,J$ 是 $J$ 的可解理想，则 $I+J$ 也是。</li>
</ol>
<p>由上述性质可知，$L$ 有唯一的极大可解理想。即为 $Rad L$,若 $Rad L =0$ 则称之为<strong>半单</strong>的，等价于 $L$ 无非零abelian理想。另外 我们称 $x \in End V$ 半单，若 $x$ 的极小多项式无重根。</p>
<p>对于给定Lie代数 $L$，我们有理想降链<br>$L^0 = L,L^1=[L^0,L^0],\cdots,L^i=[L^{i-1},L^{i-1}],\cdots $。若存在 $n$ 使得 $L^{n} = 0$ 则称 $L$ 幂零(nilpotent)。</p>
<ol>
<li>若$L$ 幂零，$L$ 的子代数和同态像幂零。</li>
<li>若 $L/Z(L)$ 幂零。则 $L$ 幂零。</li>
<li>若 $L$ 幂零且非0，则 $Z(L) \neq 0$。</li>
</ol>
<p>显然由于 $L^{(i)} \subset L^i$ 因此幂零一定可解，但是反之则不尽然，例如 $\mathbb{gl}(V)$ 中对应的上三角矩阵全体构成的Lie代数。由Lie定理的推论知：<br>$L$ 可解的充要条件是 $[L,L]$ 幂零。</p>
<h3 id="ad-nilpotent"><a href="#ad-nilpotent" class="headerlink" title="ad-nilpotent"></a>ad-nilpotent</h3><p>$L$ 是一个Lie代数，$x \in L$, 称 $x$ ad-nilpotent 是指 $ad_x$ 幂零。<br>易知若 $x$ 幂零，则 $ad_x$ 幂零，但是反之不尽然。然而我们有Engel 定理：<br>$L$幂零当且仅当$ad L$ 幂零。</p>
<h3 id="u4E00_u4E9B_u91CD_u8981_u7ED3_u679C"><a href="#u4E00_u4E9B_u91CD_u8981_u7ED3_u679C" class="headerlink" title="一些重要结果"></a>一些重要结果</h3><p>这里罗列一些定理实际上就是搞清楚 Lie 代数中的一些问题和一些好的性质。</p>
<p><strong>THM1</strong>. 设 $L$ 是 $\mathbb{gl}(V)$ 的子代数($L$ 中的元素可理解为矩阵)，$V$ 是有限维的，若 $L$ 中元素都幂零，则存在 $v \in V$ 使得 $L(v) = 0$.<br>上面结果是讲，$L$中元素都幂零，则 $L$ 有公共的$0$ 特征向量。证明是很有技巧性的。构造一个 codemension 为1的子代数，并证明它是 $L$ 不变子空间。然后数学归纳法完成证明。上面定理还说明我们可以取定一组基使 $L$ 同时严格上三角。</p>
<p><strong>THM2</strong>. 若 $L$ 幂零，$K$ 是 $L$ 的非零理想,则 $K \cap Z(L) \neq 0$</p>
<p><strong>THM3</strong>. 设 $L$ 是 $\mathbb{gl}(V)$ 可解子代数，$V$ 是有限维的，则存在 $L$ 存在公共特征向量。</p>
<p>上面定理还说明我们可以取定一组基使得 $L$ 同时上三角。</p>
<p><strong>THM4</strong>. 若 $x \in EndV$，则存在唯一的分解 $x = x_s+x_n$，其中 $x_s$ 是半单的， $x_n$ 是幂零的，且 $x_s,x_n$ 都能表示成 $x$ 的无常数项的多项式。将其称之为 Jordan-Chevally 分解。</p>
<p><strong>THM5</strong>. 若 $x$ 半单，则 $ad_x$ 半单。若 $x=x_s+x_n$是Jordan-Chevally 分解，则 $ad<em>x = ad</em> {x<em>s} + ad</em> {x_n}$  也是。$Der A$ 包含其元素的 半单部分和幂零部分。</p>
<p><strong>THM6</strong>. $A \subset B \subset End V $，令 $M = \lbrace x \in \mathbb{gl}(V) \;|\; [x,B] \subset A\rbrace$。若 $x \in M$ 满足，$Tr(xy)=0$ 对任意 $y\in M$ 成立，则 $x$ 幂零。</p>
<p><strong>THM7</strong> $L \subset \mathbb{gl}(V)$，$V$ 是有限维的, 则 对任意 $x \in [L,L],\;y \in L$ 有 $Tr(xy)=0$ 当且仅当 $L$ 可解。</p>
<p><strong>THM8</strong> 设 $L$ 是Lie代数，对任意 $x \in [L,L],\;y \in L$ 有 $Tr(ad_x ad_y)=0$ 则 $L$ 可解。</p>
<p><strong>THM9</strong> 若 $L$ 是半单的，则 $L$ 可唯一写成单子理想的直和且$L=[L,L],Z(L)=0$ 且 $L$ 的理想和同态像都是半单的。</p>
<h3 id="To_be_continue"><a href="#To_be_continue" class="headerlink" title="To be continue"></a>To be continue</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>近期在整理 Lie Algebra 课的笔记，还是很喜欢这门课的，主要是本科时候矩阵玩的特别6，然后 Lie Algebra 可以认为是矩阵的推广版本。里面的证明技巧性相当强。我之所以喜欢数学很大程度与数学技巧有关。但是我的导师说，这些虽然很有技巧，但是你花时间都是可以处理的，会技巧没什么了不起，脑袋稍微好一点就能做这种事，长期技巧的训练其实意义并不大，应该更关注数学内部的东西，具体说就是一个代数对象的结构，分类，不变量，对象之间的同构。一个概念有哪些等价形式，与其它概念之间的关系，搞清楚这些更为重要，它们的证明只要大致知道怎么过来的就行。我们并不要把证明的细节放在心中，因为我们已经经过了多年的训练，相信我们通过大致步骤就能给出详细的证明，只是花的时间多少罢了。当然初学一个东西，去抠它的细节是无可厚非的。<br>以上纯属废话 0.0<br>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[矩阵的Jordan分解]]></title>
    <link href="http://dna049.com/2016/04/08/%E7%9F%A9%E9%98%B5%E7%9A%84Jordan%E5%88%86%E8%A7%A3/"/>
    <id>http://dna049.com/2016/04/08/矩阵的Jordan分解/</id>
    <published>2016-04-08T08:20:49.000Z</published>
    <updated>2016-04-08T14:35:10.000Z</updated>
    <content type="html"><![CDATA[<p>最近在整理 Lie Algebra 内容时，里面提到了Jordan分解，这里就详细介绍并证明几个相关结果。</p>
<ol>
<li>若矩阵 $A,B$ 可交换，则它们有公共特征向量。</li>
<li>若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换</li>
<li>每一个矩阵 $A$ 都可以唯一分解成 $A=B+C$, 其中 $B$ 可对角化，$C$ 幂零。且 $B,C$ 都可以写成 $A$ 的无常数项的多项式。</li>
</ol>
<a id="more"></a>
<p>下面证明这三个结果并给出说明其意义。</p>
<h3 id="u82E5_u77E9_u9635__24A_2CB_24__u53EF_u4EA4_u6362_uFF0C_u5219_u5B83_u4EEC_u6709_u516C_u5171_u7279_u5F81_u5411_u91CF_u3002"><a href="#u82E5_u77E9_u9635__24A_2CB_24__u53EF_u4EA4_u6362_uFF0C_u5219_u5B83_u4EEC_u6709_u516C_u5171_u7279_u5F81_u5411_u91CF_u3002" class="headerlink" title="若矩阵 $A,B$ 可交换，则它们有公共特征向量。"></a>若矩阵 $A,B$ 可交换，则它们有公共特征向量。</h3><p><strong>证明</strong>：我们设 $V$ 为 $n$ 阶列向量全体。设 $\lambda$ 为 $B$ 的一个特征值。设<br>$$W = \lbrace x \in V \;|\; Bx = \lambda x \rbrace $$<br>则对任意 $x \in W$,<br>$$B(Ax) = A(Bx)=A(\lambda x)=\lambda(Ax)$$<br>即 $Ax \in W$。即 $W$ 是 $A$ 的不变子空间，因此，$A$ 在 $W$ 中有特征值 $\mu$ 对应的特征向量 $v$ 即为所求。</p>
<h3 id="u82E5_u77E9_u9635__24A_2CB_24__u53EF_u4EE5_u5BF9_u89D2_u5316_uFF0C_u5219_u5B83_u4EEC_u53EF_u4EE5_u540C_u65F6_u5BF9_u89D2_u5316_uFF0C_u5F53_u4E14_u4EC5_u5F53__24A_2CB_24__u4EA4_u6362"><a href="#u82E5_u77E9_u9635__24A_2CB_24__u53EF_u4EE5_u5BF9_u89D2_u5316_uFF0C_u5219_u5B83_u4EEC_u53EF_u4EE5_u540C_u65F6_u5BF9_u89D2_u5316_uFF0C_u5F53_u4E14_u4EC5_u5F53__24A_2CB_24__u4EA4_u6362" class="headerlink" title="若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换."></a>若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换.</h3><p><strong>证明</strong>：$\rightarrow$ 是显然的。现证 $\leftarrow$ 若 $A,B$ 交换。<br>由条件知，存在可逆矩阵 $P$ 使得 $P^{-1}AP = diag(a_1 E_{n_1},\cdots,a_s E_{n_s})$。由 $A,B$ 交换知，$P^{-1}AP P^{-1}BP = P^{-1}BP P^{-1}AP$。因此<br><span>$$P^{-1}BP = \left(\begin{matrix} 
B_1 \\  &amp; B_2 \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; B_s 
\end{matrix}\right)$$</span><!-- Has MathJax --><br>因为 $B$ 可对角化，因此 $B$ 的最小多项式无重根。所以 $B_i$ 的最小多项式也无重根。因此 $B_i$ 可对角化，存在可逆矩阵 $Q_i$ 使得 $Q_i^{-1}B_iQ_i$ 为对角阵。令 $Q = diag(Q_1,\cdots,Q_s)$,$T=PQ$，则 $T^{-1}BT$ 为对角阵。$T^{-1}AT = diag(Q_1^{-1},\cdots,Q_s^{-1})diag(a_1 E_{n_1},\cdots,a_s E_{n_s}) diag(Q_1,\cdots,Q_s) = diag(a_1 E_{n_1},\cdots,a_s E_{n_s})$.<br>即 $T$ 即为所求。</p>
<h3 id="Jodan_u5206_u89E3"><a href="#Jodan_u5206_u89E3" class="headerlink" title="Jodan分解"></a>Jodan分解</h3><p>每一个矩阵 $A$ 都可以唯一分解成 $A=B+C$, 其中 $B$ 可对角化，$C$ 幂零。且 $B,C$ 都可以写成 $A$ 的无常数项的多项式。<br>证明：首先对任意矩阵，我们有Jordan标准型：对任意矩阵 $A$，存在可逆矩阵 $P$ 使得<br><span>$P^{-1} A P = \left(\begin{matrix} J_1(\lambda_1) \\  &amp; J_2(\lambda_2) \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; J_s(\lambda_s) \end{matrix}\right) = \left(\begin{matrix} \lambda_1 E_{n_1} \\  &amp; \lambda_2 E_{n_2} \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; \lambda_s E_{n_s} \end{matrix}\right) + \left(\begin{matrix} J_1(0) \\  &amp; J_2(0) \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; J_s(0) \end{matrix} \right)$</span><!-- Has MathJax --></p>
<p>由于 $ J_i(\lambda_i) $ 的化零多项式为 $f_i(\lambda) = |\lambda -  J_1(\lambda_1)|$。由中国剩余定理知。存在多项式 $f(\lambda)$ 满足 $f(\lambda) = \lambda_i (mod \; f_i),i=1,\cdots,s$ 且 $f(\lambda)= 0 (mod \lambda)$。此时<br><span>$$P^{-1} A P = \left(\begin{matrix} \lambda_1 E_{n_1} \\  &amp; \lambda_2 E_{n_2} \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; \lambda_s E_{n_s} \end{matrix}\right) $$
令 $$B = P \left(\begin{matrix} \lambda_1 E_{n_1} \\  &amp; \lambda_2 E_{n_2} \\ &amp; &amp; \ddots \\ &amp; &amp; &amp; \lambda_s E_{n_s} \end{matrix}\right) P^{-1}$$</span><!-- Has MathJax --><br>则 $B=f(A)，C=A-B$ 即为所求。上面的$B,C$ 是唯一的，因为，若存在$B_1,C_1$ 也满足上述条件，则 $A,B,C,B_1,C_1$彼此交换，$B-B_1 = C_1 - C$ 是幂零的，因此 $B=B_1,C=C_1$。</p>
<p>Jordan 标准型将矩阵化成简单形式使得我们考虑很多问题都只需在标准型的情形分析。很多不明显的结论都能很清楚的给出答案。<br>对于Jordan分解，我们可以将一个矩阵分为所谓的半单部分和幂零部分，而由第二条结论知道，如果 $A_1,A_2$ 可交换，那么$A_1+A_2$ 的半单部分即为 $B_1+B_2$。这是很好的性质。或者说的更明了一点就是，如果 $A,B$ 可交换，且可以对角化，则$A+B$ 也可以对角化。</p>
<blockquote>
<p>想到写这些完全是因为 Lie Algebra 忘掉 Lie 括号本身就是一个线性空间。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在整理 Lie Algebra 内容时，里面提到了Jordan分解，这里就详细介绍并证明几个相关结果。</p>
<ol>
<li>若矩阵 $A,B$ 可交换，则它们有公共特征向量。</li>
<li>若矩阵 $A,B$ 可以对角化，则它们可以同时对角化，当且仅当 $A,B$ 交换</li>
<li>每一个矩阵 $A$ 都可以唯一分解成 $A=B+C$, 其中 $B$ 可对角化，$C$ 幂零。且 $B,C$ 都可以写成 $A$ 的无常数项的多项式。</li>
</ol>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
      <category term="矩阵" scheme="http://dna049.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[格点多边形面积公式 Pick's Theorem]]></title>
    <link href="http://dna049.com/2016/03/29/%E6%A0%BC%E7%82%B9%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F-Pick-s-Theorem/"/>
    <id>http://dna049.com/2016/03/29/格点多边形面积公式-Pick-s-Theorem/</id>
    <published>2016-03-29T13:00:30.000Z</published>
    <updated>2016-03-29T13:52:02.000Z</updated>
    <content type="html"><![CDATA[<p>Pick 定理: 顶点在格点上的简单多边形面积公式为<br>$$ S=i+\frac{j}{2}-1 $$<br>其中 $i,j,S$ 分别表示多边形内部的点数、边界上的点数、面积。下面给出清晰明了的证明方法。<br><a id="more"></a></p>
<h3 id="u4E0E_u5750_u6807_u8F74_u5E73_u884C_u7684_u77E9_u5F62_uFF08_u957F_u65B9_u5F62_uFF09"><a href="#u4E0E_u5750_u6807_u8F74_u5E73_u884C_u7684_u77E9_u5F62_uFF08_u957F_u65B9_u5F62_uFF09" class="headerlink" title="与坐标轴平行的矩形（长方形）"></a>与坐标轴平行的矩形（长方形）</h3><p>不妨设矩形边长为 $a,b$。因此面积: $S = ab$<br>内部格点个数:<br>$$i=(a-1)(b-1)$$<br>边界格点个数为 $j=2(a+b)$, 结论成立。</p>
<h3 id="u76F4_u89D2_u8FB9_u4E0E_u5750_u6807_u8F74_u5E73_u884C_u7684_u76F4_u89D2_u4E09_u89D2_u5F62"><a href="#u76F4_u89D2_u8FB9_u4E0E_u5750_u6807_u8F74_u5E73_u884C_u7684_u76F4_u89D2_u4E09_u89D2_u5F62" class="headerlink" title="直角边与坐标轴平行的直角三角形"></a>直角边与坐标轴平行的直角三角形</h3><p>不妨设直角三角形的直角边分别为 $a,b$，面积 $S=\frac{ab}{2}$。将其补成一个矩形，则两个直角三角形全等，设公共边的格点个数为 $e$,内部格点数 $i=\frac{(a-1)(b-1)-(e-2)}{2}$, 边界总格点数为 $j=e+a-1+b-1$,因此<br>$$ i+ \frac{j}{2} - 1 = (a-1)(b-1)/2 - (e-2) + \frac{e+a-1+b-1}{2} -1 =  \frac{ab}{2}$$</p>
<h3 id="u4E00_u4E2A_u7B80_u5355_u591A_u8FB9_u5F62_u62C6_u9664_u4E24_u4E2A_u7B80_u5355_u591A_u8FB9_u5F62"><a href="#u4E00_u4E2A_u7B80_u5355_u591A_u8FB9_u5F62_u62C6_u9664_u4E24_u4E2A_u7B80_u5355_u591A_u8FB9_u5F62" class="headerlink" title="一个简单多边形拆除两个简单多边形"></a>一个简单多边形拆除两个简单多边形</h3><p>若这两个简单多边形公共边上有 $c$ 个顶点,分别满足 Pick 定理。<br>设 $P$ 的面积为 $P_i + \frac{P_j}{2} - 1$<br>设 $T$ 的面积为 $T_i + \frac{T_j}{2} - 1$<br>则 $PT$ 的面积为:<br>$$ (T_i+P_i+c-2) + \frac{P_j-c+T_j-c+2}{2} - 1$$<br>也满足 Pick 定理。<br>类似地，若 $P,PT$ 满足 Pick 定理，$T$ 也满足。</p>
<h3 id="u4E09_u89D2_u5F62"><a href="#u4E09_u89D2_u5F62" class="headerlink" title="三角形"></a>三角形</h3><p>对于一般三角形ABC，我们可以将其补在一个与坐标轴平行的矩阵(边长设为 $a,b$)中（如下图）<br><img src="pick.png" alt="pick&#39;s Theorem"><br>根据上面的结论，容易知道对于一般三角形，结论也成立。</p>
<h3 id="u7B80_u5355_u591A_u8FB9_u5F62"><a href="#u7B80_u5355_u591A_u8FB9_u5F62" class="headerlink" title="简单多边形"></a>简单多边形</h3><p>需要说明的简单多边形是指，平面上边不相交的多边形。<br>由于每个 $n$ 边形，都可以拆成一个 $n-1$ 边形和一个三角形，因此易用数学归纳法证明结论对简单多边形成立。</p>
<pre><code>传说中这个定理和有关Farey序列。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Pick 定理: 顶点在格点上的简单多边形面积公式为<br>$$ S=i+\frac{j}{2}-1 $$<br>其中 $i,j,S$ 分别表示多边形内部的点数、边界上的点数、面积。下面给出清晰明了的证明方法。<br>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[代数知识点]]></title>
    <link href="http://dna049.com/2016/03/29/%E4%BB%A3%E6%95%B0%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://dna049.com/2016/03/29/代数知识点/</id>
    <published>2016-03-29T10:34:43.000Z</published>
    <updated>2016-03-29T10:34:43.000Z</updated>
    <content type="html"><![CDATA[<p>最近在读 Nathan Jacobson《Basic Algebra I》，理一下知识点。长期更新<br><a id="more"></a></p>
<h3 id="u96C6_u5408_Set"><a href="#u96C6_u5408_Set" class="headerlink" title="集合 Set"></a>集合 Set</h3><ol>
<li>一个集合 $A$ 的幂集 $\mathbb{P}(A)$ 为所有 $A$ 的子集构成的集合，$A$ 有限时，元素个数为 $2^{|A|}$ 。</li>
<li>一个映射自然的诱导了一个等价关系（“根据值是否相同”）。并由此，可以将一个映射自然地写成一个满射和一个单射的复合。</li>
<li>自然数的 Peano 公理。</li>
</ol>
<h3 id="u7FA4_Group"><a href="#u7FA4_Group" class="headerlink" title="群 Group"></a>群 Group</h3><ol>
<li>Monoid 和 Group 的定义，以及对应地考虑 Monoid 和 Group 之间的同态，这是范畴（Category）的思想。另外一切数学中的子、商概念都是一致的，子概念一般是继承原运算，并保持封闭即可。商概念就是除掉子的并且能保证定义合理即可。由于在群和环中作商并不能对任意子群做，把那些可以做的叫做正规子群(normal group)</li>
<li>群有很多等价定义。</li>
<li>一个群不能写成两（有限）个真子群的并。</li>
<li>Cayley 定理：任意有限群，同构于一个对称群（ $S_n$ ）的子群。</li>
<li>任意置换可以写成不相交轮换的复合。</li>
<li>偶置换全体构成了交错群 $A_n$ 是 $S_n$ 的 normal subgroup。</li>
<li>陪集分解和 Lagrange 定理：子群的阶是原有限群的因子。自然推论，元素的阶是群的因子。</li>
<li>Monoid 和 Group 的同态及其同态基本定理，这是范畴的框架。</li>
<li>循环群，Abel 群，自由群，自由 Monoid。</li>
<li>群在集合上的作用，轨道公式和 Burnside 引理，特别的是作用在群的陪集上会产生丰富的结论，例如关于群的中心的一些结论，包含于一个子群的最大 normal subgroup 以及使得该子群称为 normal group 的最大的子群。</li>
<li>Sylow 定理考察的是 Lagrange 的反问题。是群在集合上的作用的完美应用。</li>
</ol>
<h3 id="u73AF_Ring"><a href="#u73AF_Ring" class="headerlink" title="环 Ring"></a>环 Ring</h3><ol>
<li>环的定义，其中加法群中要求的 Abel 群可以由其他公理推出。</li>
<li>环的分类，局部环，交换环，整环，UFP，PID，UD，除环，域等等。</li>
<li>矩阵环，其中矩阵中的元素属于同一环即可。基本运算都有意义。若要求定义行列式，则元素所在的环需要是交换环。在此情况下，矩阵可逆当且仅当其行列式可逆。</li>
<li>一个非交换环的例子就是四元数（Quaternion），很多时候一个环上可以定义范数，会让一些操作更加容易。</li>
<li>理想，商环，素理想，极大理想，生成理想，左理想，右理想，环的单位构成乘法群，素环。</li>
<li>环的同态及其同态基本定理。</li>
<li>反同构，一个重要的例子就是矩阵的转置。</li>
<li>交换整环的分式域，可以推广到交换环的局部化，也能推广到环的 Ore 局部化。</li>
<li>多项式环，代数数，超越数。多项式环的余数定理，域上多项式环是PID，多项式环根的个数，有限域的乘法群是循环群。域中所有非零元之积为－1。</li>
<li>Monoid 和 Ring 的分解，唯一分解中的因子链条件，不可约元是素元的条件，以及 gcd 存在条件。Field 是 ED 是 PID 是 UFD。$D$ 是UFD 则 $D[x]$ 也是。$F[x]$ 是 ED。若 $D[x]$ 是 PID,则 $D$ 是域。</li>
<li>有限整环是除环是域。</li>
<li>Rng 可以嵌入到 Ring 中。</li>
</ol>
<h3 id="u6A21_Module_over_PID"><a href="#u6A21_Module_over_PID" class="headerlink" title="模 Module over PID"></a>模 Module over PID</h3><ol>
<li>类似于对称群 $S_n$，一个 Abel 群 M 上的自同态全体构成了一个环 End M。任何环都同构于一个 End M 的子环。</li>
<li>一个环 $R$ 到 End M 上的环同态，定义了一个 $R$ 上的模。当然还有一种等价的模仿线性空间的定义方法。特别地，一个 Abel 群可以看做是一个 $\mathbb{Z}$模，一个环的理想可以看做该环上的模， $F$上的线性空间外加一个线性变换可以看做 $F[\lambda]$模。</li>
<li>子模，商模，模同态及其同态基本定理。</li>
<li>循环模，零化子，循环模的同构。 </li>
<li>自由模，$R$ 交换时的自由模同构定理。</li>
<li>模的直和，以及线性相关，线性无关。</li>
<li>若 $D$ 是 PID，$D^{(n)}$ 是 $D$ 上秩为 $n$ 的自由模，则 $D^{(n)}$ 的子模都是自由模，且秩不超过 $n$.并且这个子模可以用 $D$ 上矩阵来刻画。</li>
<li>PID 上的矩阵可以相抵等价于对角矩阵,且每一个元素都是后一项的因子。</li>
<li>PID 上有限生成模同构于某个自由模的商模，且可以写成循环模的直和。并且上述分解长度唯一，在同构的意义下唯一。</li>
<li>扭子模以及扭子模可以分解成一些初等循环模的直和。</li>
<li>将上述 PID 上模的结论应用于 Abel 群以及域 $F$ 上线性空间，可以得到一系列结论。</li>
<li>每一个有限生成 Abel 群都是一个有限群和自由群的直和。每个有限 Abel 群都是一些素数幂阶循环群的直和。</li>
<li>域上矩阵环都有有理标准型，并且在代数闭域中有 Jordan 标准型。 </li>
<li>对于 PID 上有限生成模 $M$ 的自同态全体 End $M$ 反同构于一个两个 PID 上矩阵子环的的商。</li>
<li>应用到域上的线性空间可以得到与一个矩阵交换的矩阵全体的维数定理，自然推论是如果一个线性变换是循环的，那么与之交换的变换是它的多项式。</li>
<li>对于 PID 上有限生成模 $M$ 的自同态全体 End $M$，它的中心是 scale transformation。</li>
<li>一个域上的向量空间加上一个线性变换可以看做是 $F[\lambda]$ 模。</li>
</ol>
<h3 id="To_be_Continue"><a href="#To_be_Continue" class="headerlink" title="To be Continue"></a>To be Continue</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>最近在读 Nathan Jacobson《Basic Algebra I》，理一下知识点。长期更新<br>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有限整环是域]]></title>
    <link href="http://dna049.com/2016/03/27/%E6%9C%89%E9%99%90%E6%95%B4%E7%8E%AF%E6%98%AF%E5%9F%9F/"/>
    <id>http://dna049.com/2016/03/27/有限整环是域/</id>
    <published>2016-03-27T14:45:40.000Z</published>
    <updated>2016-03-28T09:55:05.000Z</updated>
    <content type="html"><![CDATA[<p>有限整环是域，这是一个相当深刻的结论，该定理这叫 Wedderburn’s little theorem。介绍如下。<br><a id="more"></a></p>
<h3 id="u6709_u9650_u6574_u73AF_u662F_u4F53"><a href="#u6709_u9650_u6574_u73AF_u662F_u4F53" class="headerlink" title="有限整环是体"></a>有限整环是体</h3><p>设 $D$ 是有限整环（不要求交换），下证 $D$ 是体。<br>证明：对任意 $0 \neq a \in D$，考虑 $a,a^2,a^3,..,a^n,…$ 由于 $D$ 是有限环，因此存在 $n,r &gt; 0$ 使得 $a^{n+r} = a^n$ 即 $a^n(a^r-1)=0$ 由于 $D$ 是整环，$a \neq 0$，因此 $a^r =1$ ，所以 $a$ 可逆，证毕。</p>
<h3 id="u6709_u9650_u4F53_u662F_u57DF"><a href="#u6709_u9650_u4F53_u662F_u57DF" class="headerlink" title="有限体是域"></a>有限体是域</h3><p>设 $K$ 是有限体。$Z$ 是它的中心，即<br>$$ Z = \lbrace z \in K \;|\; \forall x \in K, xz = zx \rbrace $$<br>则，$Z$ 是域。令 $|Z|=q$，则 $K$ 是 $q$ 元域上的有限维向量空间，设维数为 $n$，则 $|K|=q^n$。我们需要证明 $K=Z$, 即证明 $n=1$。<br>对任意 $a \in K$，令 $N(a) = \lbrace x \in K \;|\; ax = xa \rbrace$ ，这显然是 $K$ 的一个子体。并且包含 $Z$。因此 $N(a)$ 也是 $Z$ 上的有限维向量空间。从而 $N(a)=q^{n(a)},n(a) \geq 1$。由于 $K^{*}$ 为 $q^n-1$ 阶乘法群，$N(a)^{*}$ 为 $K^{*}$ 的 $q^{n(a)}-1$ 阶子群，因此 $q^{n(a)}-1 \;|\; q^n-1$，因此 $n(a)|n$。<br>将乘法群 $K^{*}$ 中的元素分成共轭类，从群论的角度，与 $a \in K^{*}$ 共轭的元素有 $[K^{*} :N(a)^{*}] = \frac{q^n-1}{q^{n(a)}-1}$，从而每个共轭类取一次，我们有</p>
<p>$$ q^n - 1 = q-1 + \sum_{n(a)|n ,n(a)\neq n} \frac{q^n-1}{q^{n(a)}-1} $$</p>
<p>我们需要证明的是当 $n&gt;1$ 时上式不成立。为此我们先介绍分圆多项式的知识。<br>$$ P_n(x) = \prod_{1 \leq r \leq n,(r,n)=1} (x-e^{\frac{2 \pi i r}{n}}) $$<br>即 $P_n(x)$ 是以全部 $n$ 次本原单位复根（共 $\phi(n)$ 个）为根的首一多项式。易知<br>$$ x^n -1 = \prod_{d|n} P_d(n) $$<br>由数论函数的<a href="http://dna049.com/2016/01/20/数论函数的Dirichlet积/">Mobius 变换</a>，再取指数即可知<br>$$ P_n(x) = \prod_{d|n} (x^d-1)^{\mu(n/d)} $$ 于是 $P_n(x)=f(x)/g(x)$ 其中 $f(x),g(x)$ 都为 $\mathbb{Z}[x]$ 中的首一多项式。另一方面，按照定义，$P_n(x) \in \mathbb{C}[x]$ ，从而在 $\mathbb{C}[x]$ 中 $g(x) \;|\; f(x)$。比较系数易知，$P_n(x)$ 为 $\mathbb{Z}[x]$ 中首一多项式。</p>
<p>因为对任意 $d\;|\;n,0&lt;d&lt;n,P_n(x)$ 的每个根都是 $x^n-1$ 的根，但不是 $x^d-1$ 的根，从而 </p>
<p>$$ P_n(x)|\frac{x^n-1}{x^d-1} $$</p>
<p>因此 $P_n(q)\;|\;q-1$, 但当 $n&gt;1$ 时，<br>$$|P_n(q))| &gt; (q-1)^{\phi(n)} \geq q-1 $$<br>矛盾，证毕。</p>
<blockquote>
<p>上面定理是极其深刻的，这个定理也可以这么表达，一个有限环，如果它不是域，那么它必然存在零因子。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>有限整环是域，这是一个相当深刻的结论，该定理这叫 Wedderburn’s little theorem。介绍如下。<br>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cartan-Brauer-Hua Theorem]]></title>
    <link href="http://dna049.com/2016/03/23/Cartan-Brauer-Hua-Theorem/"/>
    <id>http://dna049.com/2016/03/23/Cartan-Brauer-Hua-Theorem/</id>
    <published>2016-03-23T15:22:24.000Z</published>
    <updated>2016-03-23T15:32:09.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Cartan-Brauer-Hua</strong> For a proper subset divison ring K of division ring L, if the unit group of K is a normal subgroup of the unit group of L, K is central.<br><a id="more"></a></p>
<p>I will show two similar proof of the Cartan–Brauer–Hua theorem. </p>
<h3 id="First_Proof"><a href="#First_Proof" class="headerlink" title="First Proof"></a>First Proof</h3><p><strong>Definition</strong><br>$ L^*  \equiv L \setminus \lbrace 0 \rbrace $, $[x,y] \equiv xyx^{-1}y^{-1}$ and $c_x(y) \equiv xyx^{-1}$ </p>
<p>Given $g\in K^*$ and $a \in L \setminus K$<br>To prove: $[g,a]=1$</p>
<ol>
<li>It is trival that $[g,a] \;,\; [g,a+1]$ make sense and $$[g,a] = g (ag^{-1}a^{-1}) \in K$$ so is $[g,a+1]$.</li>
<li>we have $$ c_g(a+1) = g(a+1)g^{-1} = c_g(a)+1 $$ hence $$ [g,a+1](a+1) = [g,a]a+1$$ or equivalently $$ [g,a+1]-[g,a])a=(1-[g,a+1])$$</li>
<li>The assumption $[g,a+1] \neq [g,a]$ would lead to a contradiction that $a\in K$.hence<br>$$[g,a+1] \neq [g,a] \Leftrightarrow (a+1)g = aga^{-1}(a+1) \Leftrightarrow ga = ag $$<br>end of our proof of $[g,a]=1$.</li>
</ol>
<p>Let $g,h \in K^*$,take any $a in L \setminus K$.then $h+a \in L \setminus K $. We have $[g,a+h]=[g,a]=1$ hence $gh = hg$,thus every element of $K$ commutes with $L$.</p>
<h3 id="Second_Proof_by_Hua_Luogeng"><a href="#Second_Proof_by_Hua_Luogeng" class="headerlink" title="Second Proof by Hua Luogeng"></a>Second Proof by <a href="https://en.wiki2.org/wiki/Hua_Luogeng" target="_blank" rel="external">Hua Luogeng</a></h3><p><img src="hua.png" alt="Proof"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Cartan-Brauer-Hua</strong> For a proper subset divison ring K of division ring L, if the unit group of K is a normal subgroup of the unit group of L, K is central.<br>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[华罗庚恒等式]]></title>
    <link href="http://dna049.com/2016/03/22/%E5%8D%8E%E7%BD%97%E5%BA%9A%E6%81%92%E7%AD%89%E5%BC%8F/"/>
    <id>http://dna049.com/2016/03/22/华罗庚恒等式/</id>
    <published>2016-03-22T04:06:31.000Z</published>
    <updated>2016-03-23T15:35:12.000Z</updated>
    <content type="html"><![CDATA[<p>华罗庚恒等式有两个，都看似奇怪但都有其深刻的应用(数学内部的)</p>
<ol>
<li>若在一个环中 $a,b,1-ab$ 都可逆，则<br>$$<br>\left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a<br>$$</li>
<li>若在一个环中<br>$$<br>a = \left( b^{-1} - (a-1)^{-1}b^{-1}(a-1) \right) \left (a^{-1} b^{-1}a-(a-1)^{-1}b^{-1}(a-1) \right)^{-1}<br>$$<br>上面两个恒等式直接验算即知，可是 <a href="https://en.wiki2.org/wiki/Hua_Luogeng" target="_blank" rel="external">华老</a> 当初怎么想到这两个很奇怪的恒等式呢，怎么导入的，有什么应用呢？<a id="more"></a>
</li>
</ol>
<p>当然以下也只是我的个人猜测加上 <a href="https://en.wiki2.org/wiki/Hua%27s_identity" target="_blank" rel="external">Wikipedia</a> 的一些参考。</p>
<h3 id="u5728_u73AF_u4E2D_1-ba__u53EF_u9006_uFF0C_u5F53_u4E14_u4EC5_u5F53_1-ab__u53EF_u9006"><a href="#u5728_u73AF_u4E2D_1-ba__u53EF_u9006_uFF0C_u5F53_u4E14_u4EC5_u5F53_1-ab__u53EF_u9006" class="headerlink" title="在环中 1-ba 可逆，当且仅当 1-ab 可逆"></a>在环中 1-ba 可逆，当且仅当 1-ab 可逆</h3><p>$$ (1-ba)^{-1} = 1+ b(1-ab)^{-1}a \label{3}$$</p>
<p>上面恒等式直接证明是显然的，应用却666，6到要吐。<br>问题在于为什么想到这样奇怪的式子呢？思路怎么来的呢？<br>我们知道，当 $0&lt;x&lt;1$ 时，<br>$$ \frac{1}{1-x} = \sum_{n=0}^{\infty} {x^n} $$</p>
<p>因此，形式上我们有<br>$$ (1-ba)^{-1} = \sum_{n=0}^{\infty} {(ba)^n} = 1+ b \sum_{n=0}^{\infty}{(ab)^n} a = 1+ b(1-ab)^{-1}a $$<br>但是这只是给我们的理解提供了思路，证明还是需要按照定义来，即计算<br>$$ (1-ba)(1+ b(1-ab)^{-1}a) = 1 = (1+ b(1-ab)^{-1}a)(1-ba) $$</p>
<p>讲上述不等式应用到矩阵形式即可得到 <a href="https://en.m.wikipedia.org/wiki/Sherman–Morrison_formula" target="_blank" rel="external">Sherman–Morrison恒等式</a></p>
<h3 id="u5728_u73AF_u4E2D_uFF0C_u82E5__24a_2Cb_2Cab-1_24__u53EF_u9006_uFF0C_u5219"><a href="#u5728_u73AF_u4E2D_uFF0C_u82E5__24a_2Cb_2Cab-1_24__u53EF_u9006_uFF0C_u5219" class="headerlink" title="在环中，若 $a,b,ab-1$ 可逆，则"></a>在环中，若 $a,b,ab-1$ 可逆，则</h3><p>由上面恒等式我们知道<br>$$(ab-1)^{-1} = a(ba-1)^{-1}b - 1$$<br>因此<br>$$ \begin{aligned} (a-b^{-1})^{-1} &amp;=<br>\left((ab-1)b^{-1} \right)^{-1} \\<br>&amp;= b\left( a(ba-1)^{-1}b - 1 \right) \\<br>&amp;= ba(ba-1)^{-1}b - b  \\<br>&amp;= (ba-1)^{-1}b<br>\end{aligned}<br>$$<br>注意到<br>$$<br>\begin{align}  (ba-1)^{-1}b - a^{-1} &amp;= (ba-1)^{-1}baa^{-1} - a^{-1} \\<br>&amp;= (ba-1)^{-1}a^{-1} \\<br>&amp;= (aba-a)^{-1}<br>\end{align}<br>$$<br>因此 华罗庚等式 $ \left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a$ 得证。</p>
<h3 id="u4E00_u4E2A_u91CD_u8981_u6052_u7B49_u5F0F"><a href="#u4E00_u4E2A_u91CD_u8981_u6052_u7B49_u5F0F" class="headerlink" title="一个重要恒等式"></a>一个重要恒等式</h3><p>$$ b^{-1} - a^{-1} = ( b+b(a-b)^{-1}b )^{-1} $$</p>
<p>上面恒等式与逆算子连续性有关系。<br>证明：<br>$$<br>\begin{align}  (b^{-1} - a^{-1})^{-1} &amp;= (1-ba^{-1})^{-1}b \\<br>&amp;=(1+b(1-a^{-1}b)^{-1}a^{-1})b \\<br>&amp;= b+b(a-b)^{-1}b<br>\end{align}<br>$$</p>
<h3 id="u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u8BC1_u660E"><a href="#u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u8BC1_u660E" class="headerlink" title="华罗庚恒等式证明"></a>华罗庚恒等式证明</h3><p>$$<br>\begin{align}<br>a \left( a^{-1}b^{-1}a - (a-1)^{-1} b^{-1}(a-1) \right) &amp;=<br>(b^{-1}a- a(a-1)^{-1} b^{-1} (a-1) \\<br>&amp;= ( 1-a(a-1)^{-1} )b^{-1}a + (a-1+1) (a-1)b^{-1} )^{-1} \\<br>&amp;= -(a-1)^{-1}b^{-1}a + b^{-1} + (a-1)b^{-1} \\<br>&amp;= b^{-1} - (a-1)^{-1} b^{-1}(a-1)<br>\end{align}<br>$$</p>
<h3 id="u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u7684_u610F_u4E49"><a href="#u534E_u7F57_u5E9A_u6052_u7B49_u5F0F_u7684_u610F_u4E49" class="headerlink" title="华罗庚恒等式的意义"></a>华罗庚恒等式的意义</h3><ol>
<li>华罗庚第一个恒等式可以用来证明一个 Hua’s Theorem：除环间中保持加法和幺元以及逆元的映射必然是除环间的同态或者反同态。</li>
<li>华罗庚第一个恒等式可以证明 Cartan-Brauer-Hua Theorem 即一个除环的真子除环的单位群如果是原除环的单位群的正规子群，则该子除环一定包含于除环的中心。（会在<a href="http://dna049.com/2016/03/23/Cartan-Brauer-Hua-Theorem/">下一篇博文</a>中介绍）</li>
</ol>
<p>最后用一句广为流传的话结尾</p>
<blockquote>
<p>   龙生龙，凤生凤，华罗庚的学生会打洞（矩阵打洞）</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>华罗庚恒等式有两个，都看似奇怪但都有其深刻的应用(数学内部的)</p>
<ol>
<li>若在一个环中 $a,b,1-ab$ 都可逆，则<br>$$<br>\left( (a-b^{-1})^{-1} - a^{-1} \right)^{-1} = aba - a<br>$$</li>
<li>若在一个环中<br>$$<br>a = \left( b^{-1} - (a-1)^{-1}b^{-1}(a-1) \right) \left (a^{-1} b^{-1}a-(a-1)^{-1}b^{-1}(a-1) \right)^{-1}<br>$$<br>上面两个恒等式直接验算即知，可是 <a href="https://en.wiki2.org/wiki/Hua_Luogeng">华老</a> 当初怎么想到这两个很奇怪的恒等式呢，怎么导入的，有什么应用呢？]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自然数的Peano公理]]></title>
    <link href="http://dna049.com/2016/03/19/%E8%87%AA%E7%84%B6%E6%95%B0%E7%9A%84Peano%E5%85%AC%E7%90%86/"/>
    <id>http://dna049.com/2016/03/19/自然数的Peano公理/</id>
    <published>2016-03-19T10:58:25.000Z</published>
    <updated>2016-03-20T00:16:58.000Z</updated>
    <content type="html"><![CDATA[<p>虽然我们从小学就开始学习自然数，但是自然数的真正严格的定义归功于1889年<a href="https://en.wikipedia.org/wiki/Giuseppe_Peano" target="_blank" rel="external">Giuseppe Peano</a> 的工作。介绍如下:<br><a id="more"></a></p>
<h3 id="u81EA_u7136_u6570_u7684_u5B9A_u4E49"><a href="#u81EA_u7136_u6570_u7684_u5B9A_u4E49" class="headerlink" title="自然数的定义"></a>自然数的定义</h3><p>我们把满足如下公理的集合叫做自然数 $\mathbb{N}$。<br>$\mathbb{N}$ 中包含一个特殊元素记作 $0$, 以及一个 $\mathbb{N}$ 到自身的映射 $a \mapsto a^+$，称为后继映射。<br>满足如下 Peano 公理:</p>
<ol>
<li>$0 \notin a^+$ 对任意 $a \in \mathbb{N}$ ；</li>
<li>$a \mapsto a^+$ 是单射；</li>
<li>若 $\mathbb{N}$ 的一个子集 $A$ 包含 $0$ 以及它的任何后继元素，则 $A=\mathbb{N}$。</li>
</ol>
<p>上面的公理3是我们常用数学归纳法的依据。下面介绍一个特别重要的定理。</p>
<p><strong>归纳定理</strong>: 设 $S$ 是一个集合，$\phi$ 是 $S$ 到自身的映射， $a\in S$。则存在唯一的映射 $f \colon \mathbb{N} \to S$ 使得<br>$$ f(0) = a, \qquad f(n^+) = \phi(f(n)), n \in \mathbb{N} $$ </p>
<p><strong>证明</strong>: 设<br>$$ \Lambda ＝ \lbrace U \subset \mathbb{N} \times S \colon (0,a)\in U\; | \; \mbox{ if } (n,b) \in U, \mbox{ then } (n^+,\phi(b)) \in U \rbrace$$<br>显然 $\mathbb{N} \times S \in \Lambda$ ，因此 $\Lambda \neq 0$ ,设 $f ＝ \cap_{U \in T} U$ ，下面证明 $f$ 即为所求。<br>由归纳 $\forall a \in \mathbb{N}, \exists b \in S$ 使得 $(n,b) \in f$ ，因此我们只需证明，若$(n,b),(n,b’) \in f$ 则 $b = b’$。令 $T=\lbrace n \in \mathbb{N} \;|\; (n,b),(n,b’) \in f \Rightarrow b=b’ \rbrace$,我们只需证明 $T = \mathbb{N}$。<br>首先 $0 \in T$ ，否则 $\exists a \neq a’$ 使得 $(0,a), (0,a’) \in f$ 。设 $f’$ 为 $f \setminus \lbrace (0,b’) \rbrace$ 易知 $f’ \in \Lambda$ 矛盾于 $f$ 的定义。<br>类似的 若$r \in T$，可证 $r^+ \in T$ 否则 $\exists c \neq \phi(r) $ 使得 $(r^+,c) \in T$ 设 $f’ = f \setminus \lbrace (r^+,c) \rbrace$ 则 $f’ \in \Lambda$ 矛盾于 $f$ 的定义。<br>假设 $g$ 也满足上述条件，则 $g \in \Lambda$ 因此 $f \subset g$ 但是对于两个映射 $f \subset g$ 可知 $f = g$ 证毕。<br>注: 以上的函数用”图像“的方式给出。</p>
<p>有了上面的 <strong>归纳定理</strong> 我们就可以定义自然数的加法和乘法了，注意定义永远是数学最重要的东西。</p>
<h3 id="u52A0_u6CD5_u4E58_u6CD5_u7684_u5B9A_u4E49"><a href="#u52A0_u6CD5_u4E58_u6CD5_u7684_u5B9A_u4E49" class="headerlink" title="加法乘法的定义"></a>加法乘法的定义</h3><p>两个自然数 $m,n$ 的加法被定义为 令 $a=m$ 和 $\phi \colon n \mapsto n^+$ ,则存在唯一的 $f_m$ 使得<br>$$ 0 + m = m \qquad  n^+ + m = (n+m)^+  $$<br>对于乘法，令 $a=0$ 和 $\phi \colon n \mapsto n＋m$ ,则存在唯一的 $g_m$ 使得<br>$$ 0m = 0 \qquad  n^+ m = nm + m $$</p>
<p>可以证明(其实蛮繁琐的)这样定义的加法满足我们平常所使用的各种法则，例如结合律，交换律等等性质。</p>
<p>下面看一下加法结合率的证明（书上并没有，自己补的）</p>
<ol>
<li>由加法定义可知 $(0+y)+z = y+z = 0+(y+z)$</li>
<li>若问题对 $x$ 成立则，$(x^+ +y)+z = (x+y+z)^+ = x^+ +(y+z)$<br>因此由公理3知 上式对任意的$x \in \mathbb{N}$ 成立，证毕。</li>
</ol>
<h3 id="u81EA_u7136_u6570_u7684_u5E8F_u5173_u7CFB"><a href="#u81EA_u7136_u6570_u7684_u5E8F_u5173_u7CFB" class="headerlink" title="自然数的序关系"></a>自然数的序关系</h3><p>称 $a \geq b$ 若存在 $x \in \mathbb{N}$ 使得 $a = b+x$。<br>显然有以下简单性质</p>
<ol>
<li>$x \geq  y$ 且 $y \geq x$ 则 $x = y$</li>
<li>$x \geq  y$ 且 $y \geq z$ 则 $x \geq z$</li>
<li>$\forall (x,y) \in \mathbb{N} \times \mathbb{N}$ $x \geq y$ 和 $y \geq x$ 至少有一个成立。<br>因此上述定义，定义了一个自然数集上的良序关系。另外自然数关于这种序关系有一个广为人知的结论。</li>
</ol>
<h3 id="u6700_u5C0F_u5143_u6027_u8D28"><a href="#u6700_u5C0F_u5143_u6027_u8D28" class="headerlink" title="最小元性质"></a>最小元性质</h3><p>$\mathbb{N}$ 的任何非空子集 $S$ 存在最小值。即 $\exists l \in S$ 使得 $\forall s\in S, s \geq l$。<br><strong>证明</strong>：设 $M = \lbrace m in \mathbb{N} \;|\; \forall s \in S, s \geq m \rbrace$ 。则 $0 \in M$ 且若 $s_0 \in S$ 则 $s_0^+ \notin M$。因此 $M \neq \mathbb{N}$. 因此由归纳法，存在 $s \in M, s^+ \notin M$ 上述 $s$ 即为所求。</p>
<p>按照公理化定义的自然数的性质验算其实还是很有意思的，虽然验算了也并没有什么屌用。另外知道了自然数的公理化体系也并没有什么屌用0.0<br>另外也有人将自然数写成<br>$$ 0 \equiv \emptyset, 1 equiv \lbrace \lbrace \emptyset \rbrace \emptyset \rbrace,\cdots n^+ \equiv  \lbrace \lbrace \emptyset \rbrace \emptyset \rbrace $$</p>
<p>以上内容来自 Nathan Jacobson 《Basic Algebra》。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然我们从小学就开始学习自然数，但是自然数的真正严格的定义归功于1889年<a href="https://en.wikipedia.org/wiki/Giuseppe_Peano">Giuseppe Peano</a> 的工作。介绍如下:<br>]]>
    
    </summary>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[A note about equal-distance point set]]></title>
    <link href="http://dna049.com/2016/03/15/A-note-about-equal-distance-point-set/"/>
    <id>http://dna049.com/2016/03/15/A-note-about-equal-distance-point-set/</id>
    <published>2016-03-14T16:00:28.000Z</published>
    <updated>2016-03-15T04:11:03.000Z</updated>
    <content type="html"><![CDATA[<p>It is evident true that there are at most 4 points are equal-distance in three dimention Euclidean Space.<br>What about other metric space? This ideal was first generated by my student Yilin Liu, and some results were obtained by us together.</p>
<a id="more"></a>
<ol>
<li>In a discrete metric, $X$ is any non-empty set.<br> $$ \rho(x,y) = \left \lbrace \begin{array}{ll} 1 &amp; x \neq y \\ 0 &amp; x=y  \end{array} \right. $$<br>In this metric space,any subset of $X$ is equal-distance.</li>
<li>Suppose that $X$ if we define<br> $$ \rho(A,B) = |x_1 - x_2| + |y_1 - y_2| + |z_1 - z_2| $$,<br>where $A(x_1,y_1,z_1),B(x_2,y_2,z_2)$.<br>we can find six points satisfy every two of them have some distance,for instance,$(\pm 1,0,0)\;(0,\pm 1,0)\;(0,0,\pm 1)$.</li>
<li>Suppose that $X$ if we define<br> $$ \rho(A,B) = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2 }+ |z_1 - z_2| $$,<br>where $A(x_1,y_1,z_1),B(x_2,y_2,z_2)$.<br>It is hard to find more that 4 point which could feed our demand. Fortunately with a skill construction,we finally get five equal-distance point set as follow<br>$$ (1,0,1); \;(-1,0,-1); \;(-\sqrt{2},0,4-\sqrt{2}); \;(-\frac{3\sqrt{2}}{2},2,\frac{\sqrt{2}}{2}); \;(-\frac{3\sqrt{2}}{2},-2,\frac{\sqrt{2}}{2}) $$ </li>
</ol>
<pre><code>What more, it remains to be considered in n-dimention space,or any metric and topology space.
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>It is evident true that there are at most 4 points are equal-distance in three dimention Euclidean Space.<br>What about other metric space? This ideal was first generated by my student Yilin Liu, and some results were obtained by us together.</p>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Several trick elementary conclusions]]></title>
    <link href="http://dna049.com/2016/03/14/Several-trick-elementary-conclusions/"/>
    <id>http://dna049.com/2016/03/14/Several-trick-elementary-conclusions/</id>
    <published>2016-03-14T15:12:35.000Z</published>
    <updated>2016-03-23T14:34:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible"><a href="#In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible" class="headerlink" title="In a Monoid, if an element is left and right invertible, then it is invertible."></a>In a Monoid, if an element is left and right invertible, then it is invertible.</h3><p>Proof: By hypothesis we have<br>$$ a b = ca = 1 $$<br>hence we have<br>$$ b = cab = c$$<br>therefore $a$ is invertible.</p>
<a id="more"></a>
<p><em>Definition</em>: In a semi-group $A$, $z$ is called left(right) quasi-regular if there exists an element $z’$ such that $z’o z \equiv z’+z-z’z = 0\;(z o z’=0 )$.</p>
<p>If A is a Monoid, actually, $z$ is called left(right) quasi-regular if and only if $1-z$ is left invertible.</p>
<h3 id="In_a_semi-group_2C_if__24z_u2019oz__3D_0_24_and__24z_u2019_u2019oz_u2019__3D_0_24_then__24z_u2019_u2019_3Dz_24_2C_thus_both__24z_24_and__24z_u2019_24_are_quasi-regular"><a href="#In_a_semi-group_2C_if__24z_u2019oz__3D_0_24_and__24z_u2019_u2019oz_u2019__3D_0_24_then__24z_u2019_u2019_3Dz_24_2C_thus_both__24z_24_and__24z_u2019_24_are_quasi-regular" class="headerlink" title="In a semi-group, if $z’oz = 0$ and $z’’oz’ = 0$ then $z’’=z$, thus both $z$ and $z’$ are quasi-regular."></a>In a semi-group, if $z’oz = 0$ and $z’’oz’ = 0$ then $z’’=z$, thus both $z$ and $z’$ are quasi-regular.</h3><p>Proof: It is obvious right in a Monoid. Some trick occur while proving it.<br>$$ z’’ = z’’z’-z’ = z’’(z’z-z)-z’ = (z’’z’-z’’)z-z’=z’z-z = z $$<br>end the proof.</p>
<h3 id="In_a_Ring_2C_241-az_24_is_invertible_if_and_only_if__241-za_24_is_invertible"><a href="#In_a_Ring_2C_241-az_24_is_invertible_if_and_only_if__241-za_24_is_invertible" class="headerlink" title="In a Ring,$1-az$ is invertible if and only if $1-za$ is invertible."></a>In a Ring,$1-az$ is invertible if and only if $1-za$ is invertible.</h3><p>Proof: In fact, we have<br>$$ (1-az)^{-1} = 1+a(1-za)^{-1}z$$</p>
<h3 id="In_a_Ring__24M_24_2C__24z__5Cin_M_24-_If__24_5Cforall_a__5Cin_M_2C_5C_3B_1-az_24_is_left_invertible_2C_then__241-az_24_is_invertible_2Cso_is__241-za_24_why_foregoing_conclusion"><a href="#In_a_Ring__24M_24_2C__24z__5Cin_M_24-_If__24_5Cforall_a__5Cin_M_2C_5C_3B_1-az_24_is_left_invertible_2C_then__241-az_24_is_invertible_2Cso_is__241-za_24_why_foregoing_conclusion" class="headerlink" title="In a Ring $M$, $z \in M$. If $\forall a \in M,\; 1-az$ is left invertible, then $1-az$ is invertible,so is $1-za$ why foregoing conclusion."></a>In a Ring $M$, $z \in M$. If $\forall a \in M,\; 1-az$ is left invertible, then $1-az$ is invertible,so is $1-za$ why foregoing conclusion.</h3><p>Proof: $\forall a \in M$,$1-az$ is left invertible.thus there exists $1-y$ such that<br>$$ (1-y)(1-az) = 1 $$<br>hence $y = (ya-a)z$ is left invertible.<br>Hence by forgoing conclusion $1-az$ is invertible,and so is $1-za$.</p>
<p>Note that:</p>
<pre><code>A semi-group is a set which is closed under an associative multiplication.
A Monoid is a semi-group contain an identity element.
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible"><a href="#In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible" class="headerlink" title="In a Monoid, if an element is left and right invertible, then it is invertible."></a>In a Monoid, if an element is left and right invertible, then it is invertible.</h3><p>Proof: By hypothesis we have<br>$$ a b = ca = 1 $$<br>hence we have<br>$$ b = cab = c$$<br>therefore $a$ is invertible.</p>]]>
    
    </summary>
    
      <category term="Algebra" scheme="http://dna049.com/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gcd经典推导 hdu 5382]]></title>
    <link href="http://dna049.com/2016/03/13/gcd%E7%BB%8F%E5%85%B8%E6%8E%A8%E5%AF%BChdu-5382/"/>
    <id>http://dna049.com/2016/03/13/gcd经典推导hdu-5382/</id>
    <published>2016-03-12T16:20:40.000Z</published>
    <updated>2016-03-13T04:41:37.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/blog/2015-multi-university-training-contest-8-solutions-by-绍兴一中/" target="_blank" rel="external">多校训练</a> 中有一道数论题，推导十分强大，特此记录。<br><a id="more"></a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5382" target="_blank" rel="external">题目链接</a> 和推导过程:<br><img src="proof.png" alt="proof"><br>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">258280327</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],g[N],t[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">        g[i]=<span class="number">1</span>;t[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[i] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j+=i)&#123;</span><br><span class="line">                g[j]&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j+=i)&#123;</span><br><span class="line">            t[j]=(t[j]+g[i-<span class="number">1</span>])%M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        a[i]=(a[i-<span class="number">1</span>]+<span class="number">2</span>*i-<span class="number">1</span>-t[i-<span class="number">1</span>])%M;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;<span class="number">0</span>)  a[i]+=M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        a[i]=(a[i]+a[i-<span class="number">1</span>])%M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span></span><br><span class="line">    <span class="comment">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/blog/2015-multi-university-training-contest-8-solutions-by-绍兴一中/">多校训练</a> 中有一道数论题，推导十分强大，特此记录。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[矩阵快速幂的应用 hdu5451]]></title>
    <link href="http://dna049.com/2016/03/12/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84%E5%BA%94%E7%94%A8-hdu5451/"/>
    <id>http://dna049.com/2016/03/12/矩阵快速幂的应用-hdu5451/</id>
    <published>2016-03-12T07:41:44.000Z</published>
    <updated>2016-03-13T04:37:48.000Z</updated>
    <content type="html"><![CDATA[<p>上次已经写过了矩阵快速幂，这次再写的原因是因为此题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5451" target="_blank" rel="external">hdu5451</a>用了很多的黑科技，因此还是值得记录的。<br><a id="more"></a></p>
<p>问题简述如下:<br>$$ y = (5+ 2\sqrt{6})^{1+2^x}$$<br>where $0 \leq x &lt; 2^{32} $ and a prime number $p(p&lt;46337)$,calculate $r = floor(y) \;mod\; p$. </p>
<p>实际上我们需要计算的是<br>$$ r = (5+ 2\sqrt{6})^{1+2^x} + (5 - 2\sqrt{6})^{1+2^x} -1 $$<br>设 $a_n = (5+ 2\sqrt{6})^{1+2^x} + (5 - 2\sqrt{6})^{1+2^x} $ 则我们有<br>$$ a_0=2,a_1=10,a_n = a_{n-1} +a_{n-2}$$<br>最终答案即为<br>$$ (a_{1+2^n} - 1) \;mod\; M $$<br>另一方面，由递推关系式子，我们知道<br>$$ \left( \begin{matrix} a_{n} \\ a_{n-1} \end{matrix} \right) = A \left( \begin{matrix} a_{n-1} \\ a_{n-2} \end{matrix} \right) = A^{n-1} \left( \begin{matrix} a_1 \\ a_0 \end{matrix} \right) $$<br>因此<br>$$ \left( \begin{matrix} r \\ * \end{matrix} \right) = A^{2^x} \left( \begin{matrix} 10 \\ 2 \end{matrix} \right) $$<br>由于我们需要的是最终结果模 $p$.<br>而 $GL(n,p)$可看成 $n$ 阶方针到自身的可逆变换全体。推理易知道<br>$$ |GL(n,p)| =  \prod_{i=0}^{n-1} (p^n-p^i) $$<br>对于此题中 $ mp = |GL(2,p)| = (p^2-1)(p^2-p) $，由群的Lagrange定理知 $A^{|GL(2,p)|}=I_2$。因此我们只需计算 $A^{2^x} \;mod\; mp$ 用快速幂解决即可，但是这里有一个问题就是 mp 有可能很大，导致快速幂乘法的时候会溢出，于是乘法用快速加法来实现，具体见代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line">LL mod;</span><br><span class="line"><span class="keyword">class</span> Matrix&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">2</span>; <span class="comment">//col</span></span><br><span class="line">    LL a[N][N];</span><br><span class="line">    Matrix(<span class="keyword">int</span> a00=<span class="number">0</span>,<span class="keyword">int</span> a01=<span class="number">0</span>, <span class="keyword">int</span> a10=<span class="number">0</span>,<span class="keyword">int</span> a11=<span class="number">0</span>)&#123;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>]=a00;a[<span class="number">0</span>][<span class="number">1</span>]=a01;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">0</span>]=a10;a[<span class="number">1</span>][<span class="number">1</span>]=a11;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                R.a[i][j]=a[i][j]+A.a[i][j];</span><br><span class="line">                <span class="keyword">if</span>(R.a[i][j]&gt;=mod)   R.a[i][j]-=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                    R.a[i][j] = (R.a[i][j]+a[i][k]*A.a[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix A,LL n)</span></span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">R</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) R=R*A;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r+=x;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=p)    r-=p;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=p)    x-=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,<span class="keyword">unsigned</span> <span class="keyword">int</span> n,LL p)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=mul(r,x,p);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=mul(x,x,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=T;++t)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;mod;</span><br><span class="line">        LL p = mod;</span><br><span class="line">        p = (p*p-<span class="number">1</span>)*(p*p-p);</span><br><span class="line">        <span class="function">Matrix <span class="title">A</span><span class="params">(<span class="number">10</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        Matrix R = <span class="built_in">pow</span>(A,pow_mod(<span class="number">2</span>,x,p));</span><br><span class="line">        LL r = (R.a[<span class="number">0</span>][<span class="number">0</span>]*<span class="number">10</span>+R.a[<span class="number">0</span>][<span class="number">1</span>]*<span class="number">2</span>-<span class="number">1</span>)%mod;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>) r+=mod;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>上次已经写过了矩阵快速幂，这次再写的原因是因为此题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5451">hdu5451</a>用了很多的黑科技，因此还是值得记录的。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="矩阵" scheme="http://dna049.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Fermat平方和定理]]></title>
    <link href="http://dna049.com/2016/03/08/Fermat%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86/"/>
    <id>http://dna049.com/2016/03/08/Fermat平方和定理/</id>
    <published>2016-03-08T11:04:45.000Z</published>
    <updated>2016-03-14T16:32:13.000Z</updated>
    <content type="html"><![CDATA[<p>Fermat平方和定理的表述为：奇质数能表示为两个平方数之和的充分必要条件是该质数被4除余1。这个结论首次由 Euler 在 1747年给出证明。详细叙述如下：</p>
<a id="more"></a>
<p>为方便起见,记<br>$$ A = \lbrace a^2 + b^2 \;|\; a,b \in \mathbb{Z} \rbrace $$</p>
<p>证明分五步完成</p>
<ol>
<li>$(a^2+b^2)(c^2+d^2)=(ac \pm bd)^2 +(ad \mp bc)^2 $<br>proof: 计算即知。</li>
<li>若 $a^2+b^2 \;|\; c^2+d^2$, $a^2+b^2$ 为素数，则<br> $$ \frac{c^2+d^2}{a^2+b^2} \in A$$<br>proof: 由于$(ac-bd)(ac+bd) = (a^2+b^2)c^2-(c^2+d^2)b^2$<br>因此 $(a^2+b^2) \;|\; (ac-bd)(ac+bd)$ 而$(c^2+d^2)$ 是素数，因此必然整除其中一个。<br>假设$(a^2+b^2)|(ac-bd)$,则由1知 $(a^2+b^2)｜(ad+bc)$ 因此<br>$$ \frac{c^2+d^2}{a^2+b^2}=(\frac{ac - bd}{a^2+b^2})^2 +(\frac{ad + bc}{a^2+b^2})^2 $$<br>类似的，假设$(a^2+b^2) \;|\; (ac＋bd)$ 则有<br>$$ \frac{c^2+d^2}{a^2+b^2}=(\frac{ac + bd}{a^2+b^2})^2 +(\frac{ad - bc}{a^2+b^2})^2 $$</li>
<li>$x \;|\; a^2+b^2,x \notin A$，则$\exists y| \frac{a^2+b^2}{x}$ 使得 $y \notin A$<br>反证：设 $ a^2+b^2 = x p_1 p_2 \cdots p_n$ 则，若 则$ \forall y| \frac{a^2+b^2}{x},y \in A$ 则由2，经过 $n$ 次除法，最终 $x \in A$ 矛盾。</li>
<li>若 $(a,b)=1$ 则 $\forall x| a^2+b^2 ,x \in A$<br>假设 $\exists x| a^2+b^2,x \notin A$ 则，我们设<br>$a = mx + c,b = mx + d$,其中$|c|&lt;x,|d| &lt;x$。则<br>$a^2+b^2=(mx+c)^2+(mx+d)^2=tx+(c^2+d^2)$，因此$x \;|\; c^2+d^2$。又 $(a,b)=1$ ，因此 $((c,d),x)=1$。因此不妨设 $(c,d)=1$ 则 $\exists z, zx = c^2+d^2 \leq \frac{x^2}{2}$。即 $z\leq \frac{x}{2}$。由引理3知道 $z$ 有一个因子 $w \notin A$。即我们由 $ x \;|\; a^2+b^2,x \notin A$ 得到了 $ w \;|\; c^2+d^2, w \notin A ,w \leq  \frac{x}{2} $ 这样一直下去必然会在有限步结束，矛盾。</li>
<li>若素数$p=4n+1$，则 $p\in A$。<br>由Fermat小定理知$1,2^{4n},\cdots,(4n)^{4n}$除以 $p$ 模1.<br>因此$2^{4n}－1,3^{4n}－2^{4n},\cdots,(4n)^{4n}-(4n-1)^{4n}$都是 $p$ 的倍数。这些差都有分解<br>$$a^{4n} - b^{4n} = (a^{2n}+b^{2n})(a^{2n}-b^{2n})$$<br>由于上述 $a,b$ 相差为1，必然互素，因此若 $p|a^{2n}+b^{2n}$ 则由4命题得证。否则$2^{2n}-1,3^{2n}-2^{2n},\cdots,(2n)^{2n}-(2n-1)^{2n}$都是 $p$ 的倍数。<br>因此1.对上面式子做$2n$阶差得到 $(2n)!$ 是p的倍数，显然是不可能的。<br>或者2.由于上面序列的前 $d$ 项和 $d^{2n}-1$是$p$的倍数，因此素数 $p$ 无原根，矛盾与原根存在定理。</li>
</ol>
<p>当然上述定理也可以利用<br>$$ \mathbb{Z}[i] \simeq \mathbb{Z}[x]/(x^2+1) $$ 转化到 $F_p$ 域上的不可约问题解决。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Fermat平方和定理的表述为：奇质数能表示为两个平方数之和的充分必要条件是该质数被4除余1。这个结论首次由 Euler 在 1747年给出证明。详细叙述如下：</p>]]>
    
    </summary>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[矩阵快速幂的应用 hdu 1588]]></title>
    <link href="http://dna049.com/2016/03/05/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84%E5%BA%94%E7%94%A8-hdu-1588/"/>
    <id>http://dna049.com/2016/03/05/矩阵快速幂的应用-hdu-1588/</id>
    <published>2016-03-05T14:12:33.000Z</published>
    <updated>2016-03-10T09:21:36.000Z</updated>
    <content type="html"><![CDATA[<p>在一个半群中，$a^n$ 的运算可以使用快速幂，即在不超过 $2log_2(n)$ 的运算下完成计算。<br><a id="more"></a></p>
<p>直接用一个实例 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1588" target="_blank" rel="external">hdu1588 Gauss Fibonacci</a> 即可体现其思想。</p>
<h3 id="u95EE_u9898"><a href="#u95EE_u9898" class="headerlink" title="问题"></a>问题</h3><p>设 f 是 Fibonacci 数列满足：</p>
<ol>
<li>$f(0)=0$</li>
<li>$f(1)=1$</li>
<li>$f(n)=f(n-1)+f(n-2) ,\; n \geq 2$</li>
</ol>
<p>求 Gauss Fibonacci 问题<br>$$ \sum_{i=0}^{n-1} f(k*i+b) $$</p>
<h3 id="u6C42_u89E3"><a href="#u6C42_u89E3" class="headerlink" title="求解"></a>求解</h3><p>令 $ A = \left[ \begin{matrix} 1 &amp; 1 \\ 1 &amp; 0 \end{matrix} \right] $ 则<br>$$ \left( \begin{matrix} f(n+1) \\ f(n) \end{matrix} \right) = A \left( \begin{matrix} f(n) \\ f(n-1) \end{matrix} \right) = A^n \left( \begin{matrix} 1 \\ 0 \end{matrix} \right) $$<br>于是求解 $f(n)$ 可转化为求解 $A^n$ 另外 Gauss Fibonacci 问题可转化为求解<br>$$ A^b \cdot \sum_{i=0}^{n-1} A^{ki} $$</p>
<h3 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//#pragma comment(linker,"/STACK:10240000,10240000")</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">typedef pair&lt;LL,LL&gt; PLL;</span><br><span class="line">#define clr(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define PB push_back</span><br><span class="line">#define lrt rt&lt;&lt;1</span><br><span class="line">#define rrt rt&lt;&lt;1|1</span><br><span class="line">#define lson l,m,lrt</span><br><span class="line">#define rson m+1,r,rrt</span><br><span class="line">/*------------------------- template ------------------------------*/</span><br><span class="line">LL mod;</span><br><span class="line">class Matrix&#123;</span><br><span class="line">public:</span><br><span class="line">    const static int N = 2; //col</span><br><span class="line">    LL a[N][N];</span><br><span class="line">    Matrix(int a00=0,int a01=0, int a10=0,int a11=0)&#123;</span><br><span class="line">        a[0][0]=a00;a[0][1]=a01;</span><br><span class="line">        a[1][0]=a10;a[1][1]=a11;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix operator+(const Matrix&amp; A)const&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">            for(int j=0;j&lt;N;++j)&#123;</span><br><span class="line">                R.a[i][j]=a[i][j]+A.a[i][j];</span><br><span class="line">                if(R.a[i][j]&gt;=mod)   R.a[i][j]-=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return R;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix operator*(const Matrix&amp; A)const&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">            for(int k=0;k&lt;N;++k)&#123;</span><br><span class="line">                for(int j=0;j&lt;N;++j)&#123;</span><br><span class="line">                    R.a[i][j] = (R.a[i][j]+a[i][k]*A.a[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix pow(Matrix A,int n)&#123;</span><br><span class="line">    Matrix R(1,0,0,1);</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) R=R*A;</span><br><span class="line">        n&gt;&gt;=1;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    return R;</span><br><span class="line">&#125;</span><br><span class="line">Matrix getsum(Matrix A,int n)&#123;</span><br><span class="line">    Matrix R(1,0,0,1),X(1,0,0,1);</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) R=(R+X*pow(A,n));</span><br><span class="line">        n&gt;&gt;=1;  X=X*(Matrix(1,0,0,1)+pow(A,n));</span><br><span class="line">    &#125;</span><br><span class="line">    return R;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span><br><span class="line">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span><br><span class="line">    int k,b,n,m;</span><br><span class="line">    while(~scanf("%d%d%d%d",&amp;k,&amp;b,&amp;n,&amp;m))&#123;</span><br><span class="line">        mod = m;</span><br><span class="line">        Matrix A(1,1,1,0);</span><br><span class="line">        Matrix R = pow(A,b)*getsum(pow(A,k),n-1);</span><br><span class="line">        cout&lt;&lt;R.a[1][0]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在一个半群中，$a^n$ 的运算可以使用快速幂，即在不超过 $2log_2(n)$ 的运算下完成计算。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="矩阵" scheme="http://dna049.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自然底数e的由来]]></title>
    <link href="http://dna049.com/2016/02/24/%E8%87%AA%E7%84%B6%E5%BA%95%E6%95%B0e%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <id>http://dna049.com/2016/02/24/自然底数e的由来/</id>
    <published>2016-02-24T15:26:27.000Z</published>
    <updated>2016-02-24T15:45:47.000Z</updated>
    <content type="html"><![CDATA[<p>自然底数 $e$ 之所以重要，我想很大程度上是因为，指数函数 $f(x)=e^x$ 是“唯一”(在常数倍意义下)满足导数等于本身的函数。因此 $e$ 被叫做自然底数。<br><a id="more"></a></p>
<p>然而，$e$ 的定义可以由一个常见的重要数列极限来定义。即<br>$$ e \equiv \lim _{n \to \infty}(1+\frac{1}{n})^n $$<br>那么为什么右边有极限呢，我们来仔细分析。<br>令<br>$$ a_n = (1+\frac{1}{n})^n ,\; b_n =(1+\frac{1}{n})^{n+1} $$<br>则,由<a href="http://dna049.com/2016/02/24/均值不等式/">均值不等式</a>易知<br>$$ a_n = (1+\frac{1}{n})^n \cdot 1 \leq [\frac{n(1+\frac{1}{n})+1}{n+1}]^{n+1} =a_{n+1} $$<br>且<br>$$ \frac{1}{b_n} = (\frac{n}{n+1})^n \cdot 1 \leq [\frac{(n+1)\frac{n}{n+1}+1}{n+2}]^{n+2} = \frac{1}{b_{n+1}} $$<br>因此 $2 = a_1 \leq a_n \leq b_n \leq b_1 = 4$。由于单调有界序列必有极限，不妨把这个极限记作 $e$ 且由上面推理知 $2 &lt; e &lt; 4$。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自然底数 $e$ 之所以重要，我想很大程度上是因为，指数函数 $f(x)=e^x$ 是“唯一”(在常数倍意义下)满足导数等于本身的函数。因此 $e$ 被叫做自然底数。<br>]]>
    
    </summary>
    
      <category term="数学分析" scheme="http://dna049.com/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[均值不等式]]></title>
    <link href="http://dna049.com/2016/02/24/%E5%9D%87%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    <id>http://dna049.com/2016/02/24/均值不等式/</id>
    <published>2016-02-24T15:06:23.000Z</published>
    <updated>2016-02-24T15:25:58.000Z</updated>
    <content type="html"><![CDATA[<p>初中就学过最简单的均值不等式 $\frac{a+b}{2} \geq \sqrt{ab},a ,b \geq 0$。它的证明只需配方就知道了，这里介绍一下一般的均值不等式:<br>$$ \frac{ \sum_{i=1} ^n a_i}{n} \geq \sqrt[n]{\Pi_{i=1}^n a_i }$$<br><a id="more"></a><br>当 $n=1$ 时结论是平凡的，$n=2$ 时配方即知。$n=2^k$时不难用数学归纳法知，结论成立，下面主要看 $2^{k-1} &lt;n&lt; 2^k$的情况<br>令 $A = \frac{ \sum_{i=1} ^n a_i}{n} $ 则，应用 $2^k$ 时的结论<br>$$ \frac{ \sum_{i=1} ^n a_i + (2^k-n)A }{2^k} \geq\sqrt[2^k]{\Pi_{i=1}^n a_i A^{2^k -n}} $$<br>化简可得到结论。</p>
<pre><code>上述证明简单优美，第一次在陈纪修《数学分析》(上)看到这个优美的方法。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>初中就学过最简单的均值不等式 $\frac{a+b}{2} \geq \sqrt{ab},a ,b \geq 0$。它的证明只需配方就知道了，这里介绍一下一般的均值不等式:<br>$$ \frac{ \sum_{i=1} ^n a_i}{n} \geq \sqrt[n]{\Pi_{i=1}^n a_i }$$<br>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最强装逼题目0.0]]></title>
    <link href="http://dna049.com/2016/02/24/%E6%9C%80%E5%BC%BA%E8%A3%85%E9%80%BC%E9%A2%98%E7%9B%AE0-0/"/>
    <id>http://dna049.com/2016/02/24/最强装逼题目0-0/</id>
    <published>2016-02-24T13:50:13.000Z</published>
    <updated>2016-02-24T15:05:51.000Z</updated>
    <content type="html"><![CDATA[<p>数学老师想好了两个自然数 $m,n$ 满足 $2 \leq m \leq n \leq 100$ ,他把 $m,n$ 的和 $s$ 告诉了 $S$ 同学，把 $m,n$ 的积 $p$ 告诉了 $P$ 同学，他们都是聪明诚实的学生。进行了下面对话<br>$S$: 我不知道 $m,n$ 的值，但我知道你也不知道。<br>$P$: 现在我知道了。<br>$S$: 现在我也知道了。<br>请问 $m,n$ 的值。<br><a id="more"></a></p>
<ol>
<li>由第一句话，我们知道 $s \geq 6$,且 $p$ 中无大于或者等于 53 的质因数。但是 $S$ 是如何知道的呢，可见 $s \leq 54$。对 数 $6 ~ 54$ 逐一检查发现，除了$A = \lbrace 11,17,23,27,29,35,37,41,47,51,53 \rbrace$的其他元素外，其余每个数都可以表示成两个素数的和，因此从第一句话知道，$ s \in A$。</li>
<li>刚刚推理 $P$ 同学当然也能完成。由于 $A$ 中的元素全是奇数，因此，若 $p = 2^k \cdot (2v+1), k \geq 0, v \geq 0$ 或者 $p = 2^k \cdot (2v+1)(2j+1), k \geq 0, v \geq 0, j \geq 0$ 则 $P$ 同学就能确定的知道答案。</li>
<li><p>$S$ 同学最后也知道了 $m,n$ 的值，说明在 $s$ 所有分解 $s = m+ n, 2 \leq m \leq n \leq 100$ 中，且有一种满足 $xy = 2^k v$。<br>检查 $11 = 4+7 = 3+8$, $23 = 4 + 19 = 7+16$, $27 = 4+23 = 8+19$, $35=4+31=16+19$, $37 = 8+29 = 5+32$, $47= 4 + 43 = 16+31$, $51 = 4+47 = 8+43$。<br>又因为<br>$$ 29 = 4 + 25 = 13 +16,\; 41 = 4+37 = 16 + 25,\; 53 = 16 +37 = 21 + 32 $$<br>其中 $4 \times 25 = 100 = 20 \times 5$, $20+5 =25 \notin A$, $16 \times 25 = 400 = 80 \times 5$, $80+5 =85 \notin A$, $21 \times 32 = 672 = 7 \times 96$ ,$ 7+96 =103 \notin A$。<br>因此，只可能 $s=17$<br>$$ 17 = 2+15 = 3+14 = 4+13 = 5+12 = 6+11 = 7 +10 = 8+9 $$<br>其中只有 $17 =4 + 13$ 满足 $P$ 的断言，因此 $m = 4,n=13$。</p>
<p> 此题是我高三（2011年）在《奥赛金牌之路》中所见，实在很吊，一直铭记于心,特此记录。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>数学老师想好了两个自然数 $m,n$ 满足 $2 \leq m \leq n \leq 100$ ,他把 $m,n$ 的和 $s$ 告诉了 $S$ 同学，把 $m,n$ 的积 $p$ 告诉了 $P$ 同学，他们都是聪明诚实的学生。进行了下面对话<br>$S$: 我不知道 $m,n$ 的值，但我知道你也不知道。<br>$P$: 现在我知道了。<br>$S$: 现在我也知道了。<br>请问 $m,n$ 的值。<br>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
