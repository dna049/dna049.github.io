<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[0.肆玖]]></title>
  <subtitle><![CDATA[原谅我一生放荡不羁是傻逼]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://dna049.com/"/>
  <updated>2016-03-19T16:01:19.000Z</updated>
  <id>http://dna049.com/</id>
  
  <author>
    <name><![CDATA[dna049]]></name>
    <email><![CDATA[dna049@foxmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[自然数的Peano公理]]></title>
    <link href="http://dna049.com/2016/03/19/%E8%87%AA%E7%84%B6%E6%95%B0%E7%9A%84Peano%E5%85%AC%E7%90%86/"/>
    <id>http://dna049.com/2016/03/19/自然数的Peano公理/</id>
    <published>2016-03-19T10:58:25.000Z</published>
    <updated>2016-03-19T16:01:19.000Z</updated>
    <content type="html"><![CDATA[<p>虽然我们从小学就开始学习自然数，但是自然数的真正严格1889年<a href="https://en.wikipedia.org/wiki/Giuseppe_Peano" target="_blank" rel="external">Giuseppe Peano</a> 的工作。介绍如下:<br><a id="more"></a></p>
<h3 id="u81EA_u7136_u6570_u7684_u5B9A_u4E49"><a href="#u81EA_u7136_u6570_u7684_u5B9A_u4E49" class="headerlink" title="自然数的定义"></a>自然数的定义</h3><p>我们把满足如下公理的集合叫做自然数 $\mathbb{N}$。<br>$\mathbb{N}$ 中包含一个特殊元素记作 $0$, 以及一个 $\mathbb{N}$ 到自身的映射 $a \mapsto a^+$，称为后继映射。<br>满足如下 Peano 公理:</p>
<ol>
<li>$0 \notin a^+$ 对任意 $a \in \mathbb{N}$ ；</li>
<li>$a \mapsto a^+$ 是单射；</li>
<li>若 $\mathbb{N}$ 的一个子集 $A$ 包含 $0$ 以及它的任何后继元素，则 $A=\mathbb{N}$。</li>
</ol>
<p>上面的公理3是我们常用数学归纳法的依据。下面介绍一个特别重要的定理。</p>
<p><strong>归纳定理</strong>: 设 $S$ 是一个集合，$\phi$ 是 $S$ 到自身的映射， $a\in S$。则存在唯一的映射 $f \colon \mathbb{N} \to S$ 使得<br>$$ f(0) = a, \qquad f(n^+) = \phi(f(n)), n \in \mathbb{N} $$ </p>
<p><strong>证明</strong>: 设<br>$$ \Lambda ＝ \lbrace U \subset \mathbb{N} \times S \colon (0,a)\in U\; | \; \mbox{ if } (n,b) \in U, \mbox{ then } (n^+,\phi(b)) \in U \rbrace$$<br>显然 $\mathbb{N} \times S \in \Lambda$ ，因此 $\Lambda \neq 0$ ,设 $f ＝ \cap_{U \in T} U$ ，下面证明 $f$ 即为所求。<br>由归纳 $\forall a \in \mathbb{N}, \exists b \in S$ 使得 $(n,b) \in f$ ，因此我们只需证明，若$(n,b),(n,b’) \in f$ 则 $b = b’$。令 $T=\lbrace n \in \mathbb{N} \;|\; (n,b),(n,b’) \in f \Rightarrow b=b’ \rbrace$,我们只需证明 $T = \mathbb{N}$。<br>首先 $0 \in T$ ，否则 $\exists a \neq a’$ 使得 $(0,a), (0,a’) \in f$ 。设 $f’$ 为 $f \setminus \lbrace (0,b’) \rbrace$ 易知 $f’ \in \Lambda$ 矛盾于 $f$ 的定义。<br>类似的 若$r \in T$，可证 $r^+ \in T$ 否则 $\exists c \neq \phi(r) $ 使得 $(r^+,c) \in T$ 设 $f’ = f \setminus \lbrace (r^+,c) \rbrace$ 则 $f’ \in \Lambda$ 矛盾于 $f$ 的定义。<br>假设 $g$ 也满足上述条件，则 $g \in \Lambda$ 因此 $f \subset g$ 但是对于两个映射 $f \subset g$ 可知 $f = g$ 证毕。<br>注: 以上的函数用”图像“的方式给出。</p>
<p>有了上面的 <strong>归纳定理</strong> 我们就可以定义自然数的加法和乘法了，注意定义永远是数学最重要的东西。</p>
<h3 id="u52A0_u6CD5_u4E58_u6CD5_u7684_u5B9A_u4E49"><a href="#u52A0_u6CD5_u4E58_u6CD5_u7684_u5B9A_u4E49" class="headerlink" title="加法乘法的定义"></a>加法乘法的定义</h3><p>两个自然数 $m,n$ 的加法被定义为 令 $a=m$ 和 $\phi \colon n \mapsto n^+$ ,则存在唯一的 $f_m$ 使得<br>$$ 0 + m = m \qquad  n^+ + m = (n+m)^+  $$<br>对于乘法，令 $a=0$ 和 $\phi \colon n \mapsto n＋m$ ,则存在唯一的 $g_m$ 使得<br>$$ 0m = 0 \qquad  n^+ m = nm + m $$</p>
<p>可以证明(其实蛮繁琐的)这样定义的加法满足我们平常所使用的各种法则，例如结合律，交换律等等性质。</p>
<p>下面看一下加法结合率的证明（书上并没有，自己补的）</p>
<ol>
<li>由加法定义可知 $(0+y)+z = y+z = 0+(y+z)$</li>
<li>若问题对 $x$ 成立则，$(x^+ +y)+z = (x+y+z)^+ = x^+ +(y+z)$<br>因此由公理3知 上式对任意的$x \in \mathbb{N}$ 成立，证毕。</li>
</ol>
<h3 id="u81EA_u7136_u6570_u7684_u5E8F_u5173_u7CFB"><a href="#u81EA_u7136_u6570_u7684_u5E8F_u5173_u7CFB" class="headerlink" title="自然数的序关系"></a>自然数的序关系</h3><p>称 $a \geq b$ 若存在 $x \in \mathbb{N}$ 使得 $a = b+x$。<br>显然有以下简单性质</p>
<ol>
<li>$x \geq  y$ 且 $y \geq x$ 则 $x = y$</li>
<li>$x \geq  y$ 且 $y \geq z$ 则 $x \geq z$</li>
<li>$\forall (x,y) \in \mathbb{N} \times \mathbb{N}$ $x \geq y$ 和 $y \geq x$ 至少有一个成立。<br>因此上述定义，定义了一个自然数集上的良序关系。另外自然数关于这种序关系有一个广为人知的结论。</li>
</ol>
<h3 id="u6700_u5C0F_u5143_u6027_u8D28"><a href="#u6700_u5C0F_u5143_u6027_u8D28" class="headerlink" title="最小元性质"></a>最小元性质</h3><p>$\mathbb{N}$ 的任何非空子集 $S$ 存在最小值。即 $\exists l \in S$ 使得 $\forall s\in S, s \geq l$。<br><strong>证明</strong>：设 $M = \lbrace m in \mathbb{N} \;|\; \forall s \in S, s \geq m \rbrace$ 。则 $0 \in M$ 且若 $s_0 \in S$ 则 $s_0^+ \notin M$。因此 $M \neq \mathbb{N}$. 因此由归纳法，存在 $s \in M, s^+ \notin M$ 上述 $s$ 即为所求。</p>
<p>按照公理化定义的自然数的性质验算其实还是很有意思的，虽然验算了也并没有什么屌用。另外知道了自然数的公理化体系也并没有什么屌用0.0 </p>
<p>以上内容来自 Nathan Jacobson 《Basic Algebra》。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然我们从小学就开始学习自然数，但是自然数的真正严格1889年<a href="https://en.wikipedia.org/wiki/Giuseppe_Peano">Giuseppe Peano</a> 的工作。介绍如下:<br>]]>
    
    </summary>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[A note about equal-distance point set]]></title>
    <link href="http://dna049.com/2016/03/15/A-note-about-equal-distance-point-set/"/>
    <id>http://dna049.com/2016/03/15/A-note-about-equal-distance-point-set/</id>
    <published>2016-03-14T16:00:28.000Z</published>
    <updated>2016-03-15T04:11:03.000Z</updated>
    <content type="html"><![CDATA[<p>It is evident true that there are at most 4 points are equal-distance in three dimention Euclidean Space.<br>What about other metric space? This ideal was first generated by my student Yilin Liu, and some results were obtained by us together.</p>
<a id="more"></a>
<ol>
<li>In a discrete metric, $X$ is any non-empty set.<br> $$ \rho(x,y) = \left \lbrace \begin{array}{ll} 1 &amp; x \neq y \\ 0 &amp; x=y  \end{array} \right. $$<br>In this metric space,any subset of $X$ is equal-distance.</li>
<li>Suppose that $X$ if we define<br> $$ \rho(A,B) = |x_1 - x_2| + |y_1 - y_2| + |z_1 - z_2| $$,<br>where $A(x_1,y_1,z_1),B(x_2,y_2,z_2)$.<br>we can find six points satisfy every two of them have some distance,for instance,$(\pm 1,0,0)\;(0,\pm 1,0)\;(0,0,\pm 1)$.</li>
<li>Suppose that $X$ if we define<br> $$ \rho(A,B) = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2 }+ |z_1 - z_2| $$,<br>where $A(x_1,y_1,z_1),B(x_2,y_2,z_2)$.<br>It is hard to find more that 4 point which could feed our demand. Fortunately with a skill construction,we finally get five equal-distance point set as follow<br>$$ (1,0,1); \;(-1,0,-1); \;(-\sqrt{2},0,4-\sqrt{2}); \;(-\frac{3\sqrt{2}}{2},2,\frac{\sqrt{2}}{2}); \;(-\frac{3\sqrt{2}}{2},-2,\frac{\sqrt{2}}{2}) $$ </li>
</ol>
<pre><code>What more, it remains to be considered in n-dimention space,or any metric and topology space.
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>It is evident true that there are at most 4 points are equal-distance in three dimention Euclidean Space.<br>What about other metric space? This ideal was first generated by my student Yilin Liu, and some results were obtained by us together.</p>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Several trick elementary conclusion]]></title>
    <link href="http://dna049.com/2016/03/14/Several-trick-elementary-conclusion/"/>
    <id>http://dna049.com/2016/03/14/Several-trick-elementary-conclusion/</id>
    <published>2016-03-14T15:12:35.000Z</published>
    <updated>2016-03-18T03:37:13.000Z</updated>
    <content type="html"><![CDATA[<h3 id="In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible"><a href="#In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible" class="headerlink" title="In a Monoid, if an element is left and right invertible, then it is invertible."></a>In a Monoid, if an element is left and right invertible, then it is invertible.</h3><p>Proof: By hypothesis we have<br>$$ a b = ca = 1 $$<br>hence we have<br>$$ b = cab = c$$<br>therefore $a$ is invertible.</p>
<a id="more"></a>
<p><em>Definition</em>: In a semi-group $A$, $z$ is called left(right) quasi-regular if there exists an element $z’$ such that $z’o z \equiv z’+z-z’z = 0\;(z o z’=0 )$.</p>
<p>If A is a Monoid, actually, $z$ is called left(right) quasi-regular if and only if $1-z$ is left invertible.</p>
<h3 id="In_a_semi-group_2C_if__24z_u2019oz__3D_0_24_and__24z_u2019_u2019oz_u2019__3D_0_24_then__24z_u2019_u2019_3Dz_24_2C_thus_both__24z_24_and__24z_u2019_24_are_quasi-regular"><a href="#In_a_semi-group_2C_if__24z_u2019oz__3D_0_24_and__24z_u2019_u2019oz_u2019__3D_0_24_then__24z_u2019_u2019_3Dz_24_2C_thus_both__24z_24_and__24z_u2019_24_are_quasi-regular" class="headerlink" title="In a semi-group, if $z’oz = 0$ and $z’’oz’ = 0$ then $z’’=z$, thus both $z$ and $z’$ are quasi-regular."></a>In a semi-group, if $z’oz = 0$ and $z’’oz’ = 0$ then $z’’=z$, thus both $z$ and $z’$ are quasi-regular.</h3><p>Proof: It is obvious right in a Monoid. Some trick occur while proving it.<br>$$ z’’ = z’’z’-z’ = z’’(z’z-z)-z’ = (z’’z’-z’’)z-z’=z’z-z = z $$<br>end the proof.</p>
<h3 id="In_a_Monoid_2C_241-az_24_is_invertible_if_and_only_if__241-za_24_is_invertible"><a href="#In_a_Monoid_2C_241-az_24_is_invertible_if_and_only_if__241-za_24_is_invertible" class="headerlink" title="In a Monoid,$1-az$ is invertible if and only if $1-za$ is invertible."></a>In a Monoid,$1-az$ is invertible if and only if $1-za$ is invertible.</h3><p>Proof: In fact, we have<br>$$ (1-az)^{-1} = 1+a(1-za)^{-1}z$$</p>
<h3 id="In_a_Monoid__24M_24_2C__24z__5Cin_M_24-_If__24_5Cforall_a__5Cin_M_2C_5C_3B_1-az_24_is_left_invertible_2C_then__241-az_24_is_invertible_2Cso_is__241-za_24_why_foregoing_conclusion"><a href="#In_a_Monoid__24M_24_2C__24z__5Cin_M_24-_If__24_5Cforall_a__5Cin_M_2C_5C_3B_1-az_24_is_left_invertible_2C_then__241-az_24_is_invertible_2Cso_is__241-za_24_why_foregoing_conclusion" class="headerlink" title="In a Monoid $M$, $z \in M$. If $\forall a \in M,\; 1-az$ is left invertible, then $1-az$ is invertible,so is $1-za$ why foregoing conclusion."></a>In a Monoid $M$, $z \in M$. If $\forall a \in M,\; 1-az$ is left invertible, then $1-az$ is invertible,so is $1-za$ why foregoing conclusion.</h3><p>Proof: $\forall a \in M$,$1-az$ is left invertible.thus there exists $1-y$ such that<br>$$ (1-y)(1-az) = 1 $$<br>hence $y = (ya-a)z$ is left invertible.<br>Hence by forgoing conclusion $1-az$ is invertible,and so is $1-za$.</p>
<p>Note that:</p>
<pre><code>A semi-group is a set which is closed under an associative multiplication.
A Monoid is a semi-group contain an identity element.
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible"><a href="#In_a_Monoid_2C_if_an_element_is_left_and_right_invertible_2C_then_it_is_invertible" class="headerlink" title="In a Monoid, if an element is left and right invertible, then it is invertible."></a>In a Monoid, if an element is left and right invertible, then it is invertible.</h3><p>Proof: By hypothesis we have<br>$$ a b = ca = 1 $$<br>hence we have<br>$$ b = cab = c$$<br>therefore $a$ is invertible.</p>]]>
    
    </summary>
    
      <category term="代数" scheme="http://dna049.com/tags/%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gcd经典推导 hdu 5382]]></title>
    <link href="http://dna049.com/2016/03/13/gcd%E7%BB%8F%E5%85%B8%E6%8E%A8%E5%AF%BChdu-5382/"/>
    <id>http://dna049.com/2016/03/13/gcd经典推导hdu-5382/</id>
    <published>2016-03-12T16:20:40.000Z</published>
    <updated>2016-03-13T04:41:37.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/blog/2015-multi-university-training-contest-8-solutions-by-绍兴一中/" target="_blank" rel="external">多校训练</a> 中有一道数论题，推导十分强大，特此记录。<br><a id="more"></a></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5382" target="_blank" rel="external">题目链接</a> 和推导过程:<br><img src="proof.png" alt="proof"><br>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">258280327</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],g[N],t[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">        g[i]=<span class="number">1</span>;t[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[i] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j+=i)&#123;</span><br><span class="line">                g[j]&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j+=i)&#123;</span><br><span class="line">            t[j]=(t[j]+g[i-<span class="number">1</span>])%M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        a[i]=(a[i-<span class="number">1</span>]+<span class="number">2</span>*i-<span class="number">1</span>-t[i-<span class="number">1</span>])%M;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;<span class="number">0</span>)  a[i]+=M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)&#123;</span><br><span class="line">        a[i]=(a[i]+a[i-<span class="number">1</span>])%M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span></span><br><span class="line">    <span class="comment">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/blog/2015-multi-university-training-contest-8-solutions-by-绍兴一中/">多校训练</a> 中有一道数论题，推导十分强大，特此记录。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[矩阵快速幂的应用 hdu5451]]></title>
    <link href="http://dna049.com/2016/03/12/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84%E5%BA%94%E7%94%A8-hdu5451/"/>
    <id>http://dna049.com/2016/03/12/矩阵快速幂的应用-hdu5451/</id>
    <published>2016-03-12T07:41:44.000Z</published>
    <updated>2016-03-13T04:37:48.000Z</updated>
    <content type="html"><![CDATA[<p>上次已经写过了矩阵快速幂，这次再写的原因是因为此题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5451" target="_blank" rel="external">hdu5451</a>用了很多的黑科技，因此还是值得记录的。<br><a id="more"></a></p>
<p>问题简述如下:<br>$$ y = (5+ 2\sqrt{6})^{1+2^x}$$<br>where $0 \leq x &lt; 2^{32} $ and a prime number $p(p&lt;46337)$,calculate $r = floor(y) \;mod\; p$. </p>
<p>实际上我们需要计算的是<br>$$ r = (5+ 2\sqrt{6})^{1+2^x} + (5 - 2\sqrt{6})^{1+2^x} -1 $$<br>设 $a_n = (5+ 2\sqrt{6})^{1+2^x} + (5 - 2\sqrt{6})^{1+2^x} $ 则我们有<br>$$ a_0=2,a_1=10,a_n = a_{n-1} +a_{n-2}$$<br>最终答案即为<br>$$ (a_{1+2^n} - 1) \;mod\; M $$<br>另一方面，由递推关系式子，我们知道<br>$$ \left( \begin{matrix} a_{n} \\ a_{n-1} \end{matrix} \right) = A \left( \begin{matrix} a_{n-1} \\ a_{n-2} \end{matrix} \right) = A^{n-1} \left( \begin{matrix} a_1 \\ a_0 \end{matrix} \right) $$<br>因此<br>$$ \left( \begin{matrix} r \\ * \end{matrix} \right) = A^{2^x} \left( \begin{matrix} 10 \\ 2 \end{matrix} \right) $$<br>由于我们需要的是最终结果模 $p$.<br>而 $GL(n,p)$可看成 $n$ 阶方针到自身的可逆变换全体。推理易知道<br>$$ |GL(n,p)| =  \prod_{i=0}^{n-1} (p^n-p^i) $$<br>对于此题中 $ mp = |GL(2,p)| = (p^2-1)(p^2-p) $，由群的Lagrange定理知 $A^{|GL(2,p)|}=I_2$。因此我们只需计算 $A^{2^x} \;mod\; mp$ 用快速幂解决即可，但是这里有一个问题就是 mp 有可能很大，导致快速幂乘法的时候会溢出，于是乘法用快速加法来实现，具体见代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line">LL mod;</span><br><span class="line"><span class="keyword">class</span> Matrix&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">2</span>; <span class="comment">//col</span></span><br><span class="line">    LL a[N][N];</span><br><span class="line">    Matrix(<span class="keyword">int</span> a00=<span class="number">0</span>,<span class="keyword">int</span> a01=<span class="number">0</span>, <span class="keyword">int</span> a10=<span class="number">0</span>,<span class="keyword">int</span> a11=<span class="number">0</span>)&#123;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>]=a00;a[<span class="number">0</span>][<span class="number">1</span>]=a01;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">0</span>]=a10;a[<span class="number">1</span>][<span class="number">1</span>]=a11;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>+(<span class="keyword">const</span> Matrix&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                R.a[i][j]=a[i][j]+A.a[i][j];</span><br><span class="line">                <span class="keyword">if</span>(R.a[i][j]&gt;=mod)   R.a[i][j]-=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&amp; A)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;++j)&#123;</span><br><span class="line">                    R.a[i][j] = (R.a[i][j]+a[i][k]*A.a[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">pow</span><span class="params">(Matrix A,LL n)</span></span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">R</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) R=R*A;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x,LL n,LL p)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r+=x;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=p)    r-=p;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=p)    x-=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL x,<span class="keyword">unsigned</span> <span class="keyword">int</span> n,LL p)</span></span>&#123;</span><br><span class="line">    LL r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) r=mul(r,x,p);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;  x=mul(x,x,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=T;++t)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;mod;</span><br><span class="line">        LL p = mod;</span><br><span class="line">        p = (p*p-<span class="number">1</span>)*(p*p-p);</span><br><span class="line">        <span class="function">Matrix <span class="title">A</span><span class="params">(<span class="number">10</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        Matrix R = <span class="built_in">pow</span>(A,pow_mod(<span class="number">2</span>,x,p));</span><br><span class="line">        LL r = (R.a[<span class="number">0</span>][<span class="number">0</span>]*<span class="number">10</span>+R.a[<span class="number">0</span>][<span class="number">1</span>]*<span class="number">2</span>-<span class="number">1</span>)%mod;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>) r+=mod;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>上次已经写过了矩阵快速幂，这次再写的原因是因为此题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5451">hdu5451</a>用了很多的黑科技，因此还是值得记录的。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="矩阵" scheme="http://dna049.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Fermat平方和定理]]></title>
    <link href="http://dna049.com/2016/03/08/Fermat%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86/"/>
    <id>http://dna049.com/2016/03/08/Fermat平方和定理/</id>
    <published>2016-03-08T11:04:45.000Z</published>
    <updated>2016-03-14T16:32:13.000Z</updated>
    <content type="html"><![CDATA[<p>Fermat平方和定理的表述为：奇质数能表示为两个平方数之和的充分必要条件是该质数被4除余1。这个结论首次由 Euler 在 1747年给出证明。详细叙述如下：</p>
<a id="more"></a>
<p>为方便起见,记<br>$$ A = \lbrace a^2 + b^2 \;|\; a,b \in \mathbb{Z} \rbrace $$</p>
<p>证明分五步完成</p>
<ol>
<li>$(a^2+b^2)(c^2+d^2)=(ac \pm bd)^2 +(ad \mp bc)^2 $<br>proof: 计算即知。</li>
<li>若 $a^2+b^2 \;|\; c^2+d^2$, $a^2+b^2$ 为素数，则<br> $$ \frac{c^2+d^2}{a^2+b^2} \in A$$<br>proof: 由于$(ac-bd)(ac+bd) = (a^2+b^2)c^2-(c^2+d^2)b^2$<br>因此 $(a^2+b^2) \;|\; (ac-bd)(ac+bd)$ 而$(c^2+d^2)$ 是素数，因此必然整除其中一个。<br>假设$(a^2+b^2)|(ac-bd)$,则由1知 $(a^2+b^2)｜(ad+bc)$ 因此<br>$$ \frac{c^2+d^2}{a^2+b^2}=(\frac{ac - bd}{a^2+b^2})^2 +(\frac{ad + bc}{a^2+b^2})^2 $$<br>类似的，假设$(a^2+b^2) \;|\; (ac＋bd)$ 则有<br>$$ \frac{c^2+d^2}{a^2+b^2}=(\frac{ac + bd}{a^2+b^2})^2 +(\frac{ad - bc}{a^2+b^2})^2 $$</li>
<li>$x \;|\; a^2+b^2,x \notin A$，则$\exists y| \frac{a^2+b^2}{x}$ 使得 $y \notin A$<br>反证：设 $ a^2+b^2 = x p_1 p_2 \cdots p_n$ 则，若 则$ \forall y| \frac{a^2+b^2}{x},y \in A$ 则由2，经过 $n$ 次除法，最终 $x \in A$ 矛盾。</li>
<li>若 $(a,b)=1$ 则 $\forall x| a^2+b^2 ,x \in A$<br>假设 $\exists x| a^2+b^2,x \notin A$ 则，我们设<br>$a = mx + c,b = mx + d$,其中$|c|&lt;x,|d| &lt;x$。则<br>$a^2+b^2=(mx+c)^2+(mx+d)^2=tx+(c^2+d^2)$，因此$x \;|\; c^2+d^2$。又 $(a,b)=1$ ，因此 $((c,d),x)=1$。因此不妨设 $(c,d)=1$ 则 $\exists z, zx = c^2+d^2 \leq \frac{x^2}{2}$。即 $z\leq \frac{x}{2}$。由引理3知道 $z$ 有一个因子 $w \notin A$。即我们由 $ x \;|\; a^2+b^2,x \notin A$ 得到了 $ w \;|\; c^2+d^2, w \notin A ,w \leq  \frac{x}{2} $ 这样一直下去必然会在有限步结束，矛盾。</li>
<li>若素数$p=4n+1$，则 $p\in A$。<br>由Fermat小定理知$1,2^{4n},\cdots,(4n)^{4n}$除以 $p$ 模1.<br>因此$2^{4n}－1,3^{4n}－2^{4n},\cdots,(4n)^{4n}-(4n-1)^{4n}$都是 $p$ 的倍数。这些差都有分解<br>$$a^{4n} - b^{4n} = (a^{2n}+b^{2n})(a^{2n}-b^{2n})$$<br>由于上述 $a,b$ 相差为1，必然互素，因此若 $p|a^{2n}+b^{2n}$ 则由4命题得证。否则$2^{2n}-1,3^{2n}-2^{2n},\cdots,(2n)^{2n}-(2n-1)^{2n}$都是 $p$ 的倍数。<br>因此1.对上面式子做$2n$阶差得到 $(2n)!$ 是p的倍数，显然是不可能的。<br>或者2.由于上面序列的前 $d$ 项和 $d^{2n}-1$是$p$的倍数，因此素数 $p$ 无原根，矛盾与原根存在定理。</li>
</ol>
<p>当然上述定理也可以利用<br>$$ \mathbb{Z}[i] \simeq \mathbb{Z}[x]/(x^2+1) $$ 转化到 $F_p$ 域上的不可约问题解决。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Fermat平方和定理的表述为：奇质数能表示为两个平方数之和的充分必要条件是该质数被4除余1。这个结论首次由 Euler 在 1747年给出证明。详细叙述如下：</p>]]>
    
    </summary>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[矩阵快速幂的应用 hdu 1588]]></title>
    <link href="http://dna049.com/2016/03/05/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84%E5%BA%94%E7%94%A8-hdu-1588/"/>
    <id>http://dna049.com/2016/03/05/矩阵快速幂的应用-hdu-1588/</id>
    <published>2016-03-05T14:12:33.000Z</published>
    <updated>2016-03-10T09:21:36.000Z</updated>
    <content type="html"><![CDATA[<p>在一个半群中，$a^n$ 的运算可以使用快速幂，即在不超过 $2log_2(n)$ 的运算下完成计算。<br><a id="more"></a></p>
<p>直接用一个实例 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1588" target="_blank" rel="external">hdu1588 Gauss Fibonacci</a> 即可体现其思想。</p>
<h3 id="u95EE_u9898"><a href="#u95EE_u9898" class="headerlink" title="问题"></a>问题</h3><p>设 f 是 Fibonacci 数列满足：</p>
<ol>
<li>$f(0)=0$</li>
<li>$f(1)=1$</li>
<li>$f(n)=f(n-1)+f(n-2) ,\; n \geq 2$</li>
</ol>
<p>求 Gauss Fibonacci 问题<br>$$ \sum_{i=0}^{n-1} f(k*i+b) $$</p>
<h3 id="u6C42_u89E3"><a href="#u6C42_u89E3" class="headerlink" title="求解"></a>求解</h3><p>令 $ A = \left[ \begin{matrix} 1 &amp; 1 \\ 1 &amp; 0 \end{matrix} \right] $ 则<br>$$ \left( \begin{matrix} f(n+1) \\ f(n) \end{matrix} \right) = A \left( \begin{matrix} f(n) \\ f(n-1) \end{matrix} \right) = A^n \left( \begin{matrix} 1 \\ 0 \end{matrix} \right) $$<br>于是求解 $f(n)$ 可转化为求解 $A^n$ 另外 Gauss Fibonacci 问题可转化为求解<br>$$ A^b \cdot \sum_{i=0}^{n-1} A^{ki} $$</p>
<h3 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//#pragma comment(linker,"/STACK:10240000,10240000")</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">typedef pair&lt;LL,LL&gt; PLL;</span><br><span class="line">#define clr(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define MP make_pair</span><br><span class="line">#define PB push_back</span><br><span class="line">#define lrt rt&lt;&lt;1</span><br><span class="line">#define rrt rt&lt;&lt;1|1</span><br><span class="line">#define lson l,m,lrt</span><br><span class="line">#define rson m+1,r,rrt</span><br><span class="line">/*------------------------- template ------------------------------*/</span><br><span class="line">LL mod;</span><br><span class="line">class Matrix&#123;</span><br><span class="line">public:</span><br><span class="line">    const static int N = 2; //col</span><br><span class="line">    LL a[N][N];</span><br><span class="line">    Matrix(int a00=0,int a01=0, int a10=0,int a11=0)&#123;</span><br><span class="line">        a[0][0]=a00;a[0][1]=a01;</span><br><span class="line">        a[1][0]=a10;a[1][1]=a11;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix operator+(const Matrix&amp; A)const&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">            for(int j=0;j&lt;N;++j)&#123;</span><br><span class="line">                R.a[i][j]=a[i][j]+A.a[i][j];</span><br><span class="line">                if(R.a[i][j]&gt;=mod)   R.a[i][j]-=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return R;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix operator*(const Matrix&amp; A)const&#123;</span><br><span class="line">        Matrix R;</span><br><span class="line">        for(int i=0;i&lt;N;++i)&#123;</span><br><span class="line">            for(int k=0;k&lt;N;++k)&#123;</span><br><span class="line">                for(int j=0;j&lt;N;++j)&#123;</span><br><span class="line">                    R.a[i][j] = (R.a[i][j]+a[i][k]*A.a[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix pow(Matrix A,int n)&#123;</span><br><span class="line">    Matrix R(1,0,0,1);</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) R=R*A;</span><br><span class="line">        n&gt;&gt;=1;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    return R;</span><br><span class="line">&#125;</span><br><span class="line">Matrix getsum(Matrix A,int n)&#123;</span><br><span class="line">    Matrix R(1,0,0,1),X(1,0,0,1);</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) R=(R+X*pow(A,n));</span><br><span class="line">        n&gt;&gt;=1;  X=X*(Matrix(1,0,0,1)+pow(A,n));</span><br><span class="line">    &#125;</span><br><span class="line">    return R;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//    freopen("/Users/dna049/Desktop/AC/in","r",stdin);</span><br><span class="line">//    freopen("/Users/dna049/Desktop/AC/out","w",stdout);</span><br><span class="line">    int k,b,n,m;</span><br><span class="line">    while(~scanf("%d%d%d%d",&amp;k,&amp;b,&amp;n,&amp;m))&#123;</span><br><span class="line">        mod = m;</span><br><span class="line">        Matrix A(1,1,1,0);</span><br><span class="line">        Matrix R = pow(A,b)*getsum(pow(A,k),n-1);</span><br><span class="line">        cout&lt;&lt;R.a[1][0]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在一个半群中，$a^n$ 的运算可以使用快速幂，即在不超过 $2log_2(n)$ 的运算下完成计算。<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="矩阵" scheme="http://dna049.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自然底数e的由来]]></title>
    <link href="http://dna049.com/2016/02/24/%E8%87%AA%E7%84%B6%E5%BA%95%E6%95%B0e%E7%9A%84%E7%94%B1%E6%9D%A5/"/>
    <id>http://dna049.com/2016/02/24/自然底数e的由来/</id>
    <published>2016-02-24T15:26:27.000Z</published>
    <updated>2016-02-24T15:45:47.000Z</updated>
    <content type="html"><![CDATA[<p>自然底数 $e$ 之所以重要，我想很大程度上是因为，指数函数 $f(x)=e^x$ 是“唯一”(在常数倍意义下)满足导数等于本身的函数。因此 $e$ 被叫做自然底数。<br><a id="more"></a></p>
<p>然而，$e$ 的定义可以由一个常见的重要数列极限来定义。即<br>$$ e \equiv \lim _{n \to \infty}(1+\frac{1}{n})^n $$<br>那么为什么右边有极限呢，我们来仔细分析。<br>令<br>$$ a_n = (1+\frac{1}{n})^n ,\; b_n =(1+\frac{1}{n})^{n+1} $$<br>则,由<a href="http://dna049.com/2016/02/24/均值不等式/">均值不等式</a>易知<br>$$ a_n = (1+\frac{1}{n})^n \cdot 1 \leq [\frac{n(1+\frac{1}{n})+1}{n+1}]^{n+1} =a_{n+1} $$<br>且<br>$$ \frac{1}{b_n} = (\frac{n}{n+1})^n \cdot 1 \leq [\frac{(n+1)\frac{n}{n+1}+1}{n+2}]^{n+2} = \frac{1}{b_{n+1}} $$<br>因此 $2 = a_1 \leq a_n \leq b_n \leq b_1 = 4$。由于单调有界序列必有极限，不妨把这个极限记作 $e$ 且由上面推理知 $2 &lt; e &lt; 4$。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自然底数 $e$ 之所以重要，我想很大程度上是因为，指数函数 $f(x)=e^x$ 是“唯一”(在常数倍意义下)满足导数等于本身的函数。因此 $e$ 被叫做自然底数。<br>]]>
    
    </summary>
    
      <category term="数学分析" scheme="http://dna049.com/tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[均值不等式]]></title>
    <link href="http://dna049.com/2016/02/24/%E5%9D%87%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    <id>http://dna049.com/2016/02/24/均值不等式/</id>
    <published>2016-02-24T15:06:23.000Z</published>
    <updated>2016-02-24T15:25:58.000Z</updated>
    <content type="html"><![CDATA[<p>初中就学过最简单的均值不等式 $\frac{a+b}{2} \geq \sqrt{ab},a ,b \geq 0$。它的证明只需配方就知道了，这里介绍一下一般的均值不等式:<br>$$ \frac{ \sum_{i=1} ^n a_i}{n} \geq \sqrt[n]{\Pi_{i=1}^n a_i }$$<br><a id="more"></a><br>当 $n=1$ 时结论是平凡的，$n=2$ 时配方即知。$n=2^k$时不难用数学归纳法知，结论成立，下面主要看 $2^{k-1} &lt;n&lt; 2^k$的情况<br>令 $A = \frac{ \sum_{i=1} ^n a_i}{n} $ 则，应用 $2^k$ 时的结论<br>$$ \frac{ \sum_{i=1} ^n a_i + (2^k-n)A }{2^k} \geq\sqrt[2^k]{\Pi_{i=1}^n a_i A^{2^k -n}} $$<br>化简可得到结论。</p>
<pre><code>上述证明简单优美，第一次在陈纪修《数学分析》(上)看到这个优美的方法。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>初中就学过最简单的均值不等式 $\frac{a+b}{2} \geq \sqrt{ab},a ,b \geq 0$。它的证明只需配方就知道了，这里介绍一下一般的均值不等式:<br>$$ \frac{ \sum_{i=1} ^n a_i}{n} \geq \sqrt[n]{\Pi_{i=1}^n a_i }$$<br>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最强装逼题目0.0]]></title>
    <link href="http://dna049.com/2016/02/24/%E6%9C%80%E5%BC%BA%E8%A3%85%E9%80%BC%E9%A2%98%E7%9B%AE0-0/"/>
    <id>http://dna049.com/2016/02/24/最强装逼题目0-0/</id>
    <published>2016-02-24T13:50:13.000Z</published>
    <updated>2016-02-24T15:05:51.000Z</updated>
    <content type="html"><![CDATA[<p>数学老师想好了两个自然数 $m,n$ 满足 $2 \leq m \leq n \leq 100$ ,他把 $m,n$ 的和 $s$ 告诉了 $S$ 同学，把 $m,n$ 的积 $p$ 告诉了 $P$ 同学，他们都是聪明诚实的学生。进行了下面对话<br>$S$: 我不知道 $m,n$ 的值，但我知道你也不知道。<br>$P$: 现在我知道了。<br>$S$: 现在我也知道了。<br>请问 $m,n$ 的值。<br><a id="more"></a></p>
<ol>
<li>由第一句话，我们知道 $s \geq 6$,且 $p$ 中无大于或者等于 53 的质因数。但是 $S$ 是如何知道的呢，可见 $s \leq 54$。对 数 $6 ~ 54$ 逐一检查发现，除了$A = \lbrace 11,17,23,27,29,35,37,41,47,51,53 \rbrace$的其他元素外，其余每个数都可以表示成两个素数的和，因此从第一句话知道，$ s \in A$。</li>
<li>刚刚推理 $P$ 同学当然也能完成。由于 $A$ 中的元素全是奇数，因此，若 $p = 2^k \cdot (2v+1), k \geq 0, v \geq 0$ 或者 $p = 2^k \cdot (2v+1)(2j+1), k \geq 0, v \geq 0, j \geq 0$ 则 $P$ 同学就能确定的知道答案。</li>
<li><p>$S$ 同学最后也知道了 $m,n$ 的值，说明在 $s$ 所有分解 $s = m+ n, 2 \leq m \leq n \leq 100$ 中，且有一种满足 $xy = 2^k v$。<br>检查 $11 = 4+7 = 3+8$, $23 = 4 + 19 = 7+16$, $27 = 4+23 = 8+19$, $35=4+31=16+19$, $37 = 8+29 = 5+32$, $47= 4 + 43 = 16+31$, $51 = 4+47 = 8+43$。<br>又因为<br>$$ 29 = 4 + 25 = 13 +16,\; 41 = 4+37 = 16 + 25,\; 53 = 16 +37 = 21 + 32 $$<br>其中 $4 \times 25 = 100 = 20 \times 5$, $20+5 =25 \notin A$, $16 \times 25 = 400 = 80 \times 5$, $80+5 =85 \notin A$, $21 \times 32 = 672 = 7 \times 96$ ,$ 7+96 =103 \notin A$。<br>因此，只可能 $s=17$<br>$$ 17 = 2+15 = 3+14 = 4+13 = 5+12 = 6+11 = 7 +10 = 8+9 $$<br>其中只有 $17 =4 + 13$ 满足 $P$ 的断言，因此 $m = 4,n=13$。</p>
<p> 此题是我高三（2011年）在《奥赛金牌之路》中所见，实在很吊，一直铭记于心,特此记录。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>数学老师想好了两个自然数 $m,n$ 满足 $2 \leq m \leq n \leq 100$ ,他把 $m,n$ 的和 $s$ 告诉了 $S$ 同学，把 $m,n$ 的积 $p$ 告诉了 $P$ 同学，他们都是聪明诚实的学生。进行了下面对话<br>$S$: 我不知道 $m,n$ 的值，但我知道你也不知道。<br>$P$: 现在我知道了。<br>$S$: 现在我也知道了。<br>请问 $m,n$ 的值。<br>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[My Math work edited by LaTex]]></title>
    <link href="http://dna049.com/2016/02/23/My-Math-work-edited-by-LaTex/"/>
    <id>http://dna049.com/2016/02/23/My-Math-work-edited-by-LaTex/</id>
    <published>2016-02-23T11:17:02.000Z</published>
    <updated>2016-02-23T11:17:02.000Z</updated>
    <content type="html"><![CDATA[<p>This blog makes a record of my math work and will be update frequently.Click to view or download it.</p>
<a id="more"></a>
<h4 id="Here_are_PDF_version_of_my_math_work"><a href="#Here_are_PDF_version_of_my_math_work" class="headerlink" title="Here are PDF version of my math work"></a>Here are PDF version of my math work</h4><p><a href="1.pdf">Config of ACM-ICPC</a></p>
<p><a href="2.pdf">Some results about matrix</a></p>
<p><a href="3.pdf">Decomposition of 1 by 1/n </a></p>
<p><a href="4.pdf">Nowhere dense set and frist category set</a></p>
<p><a href="5.pdf">Relationship between Spectral Radius ,Numerical Radius and Spectral norm</a></p>
<p><a href="6.pdf">Some results about group</a></p>
<p><a href="7.pdf">The inverse of I-ba and I-ab</a></p>
<p><a href="8.pdf">example of function that only derivable on one point</a></p>
<p><a href="0.pdf">undergraduate graduation paper</a></p>
<h4 id="Here_are_Tex_version_of_my_math_work"><a href="#Here_are_Tex_version_of_my_math_work" class="headerlink" title="Here are Tex version of my math work"></a>Here are Tex version of my math work</h4><p><a href="1.tex">Config of ACM-ICPC.tex</a></p>
<p><a href="2.tex">Some results about matrix.tex</a></p>
<p><a href="3.tex">Decomposition of 1 by 1/n.tex</a></p>
<p><a href="4.tex">Nowhere dense set and frist category set.tex</a></p>
<p><a href="5.tex">Relationship between Spectral Radius ,Numerical Radius and Spectral norm.tex</a></p>
<p><a href="6.tex">Some results about group.tex</a></p>
<p><a href="7.tex">The inverse of I-ba and I-ab.tex</a></p>
<p><a href="8.tex">example of function that only derivable on one point.tex</a></p>
<h3 id="LaTex_is_a_wonderful_tool_for_Mathematics"><a href="#LaTex_is_a_wonderful_tool_for_Mathematics" class="headerlink" title="LaTex is a wonderful tool for Mathematics"></a>LaTex is a wonderful tool for Mathematics</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>This blog makes a record of my math work and will be update frequently.Click to view or download it.</p>]]>
    
    </summary>
    
      <category term="Tex" scheme="http://dna049.com/tags/Tex/"/>
    
      <category term="数学" scheme="http://dna049.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[整数集上的一种奇特拓扑]]></title>
    <link href="http://dna049.com/2016/02/22/%E6%95%B4%E6%95%B0%E9%9B%86%E4%B8%8A%E7%9A%84%E4%B8%80%E7%A7%8D%E5%A5%87%E7%89%B9%E6%8B%93%E6%89%91/"/>
    <id>http://dna049.com/2016/02/22/整数集上的一种奇特拓扑/</id>
    <published>2016-02-22T13:41:23.000Z</published>
    <updated>2016-02-23T11:34:31.000Z</updated>
    <content type="html"><![CDATA[<p>在《Proofs from THE BOOK》里素数无限的六种证明的第五种讲到了一种用点集拓扑学知识证明的方法，其中引入了整数集上的一种奇特拓扑。<br><a id="more"></a></p>
<p>对 $a,b \in \mathbb{Z},b&gt;0$，令<br>$$ N_{a,b} = \lbrace a + nb \colon n \in \mathbb{Z} \rbrace $$<br>我们称集合 $O \subset \mathbb{Z}$ 是开集，若$O = \emptyset$，或者 $ \forall a \in O,\exists b&gt;0,st. N_{a,b} \subset O$,容易验证这样定义的开集族全体构成了 $\mathbb{Z}$ 上的拓扑。<br>并且每个$N_{a,b}$ 都是既开又闭的。这是由于<br>$$ N_{a,b} = \mathbb{Z} \setminus \cup_{i-1}^{b-1} N_{a+i,b}$$</p>
<p>又由<br>$$ \mathbb{Z} \setminus \lbrace -1,1 \rbrace = \cup_{p \in P} N_{0,p} $$<br>若素数只有有限个，则$P$是有限集，从而$\lbrace -1,1 \rbrace$是开集，矛盾。</p>
<p>上述方法脑洞大，形式简洁，不愧是 <a href="0.pdf">《Proofs from THE BOOK》</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在《Proofs from THE BOOK》里素数无限的六种证明的第五种讲到了一种用点集拓扑学知识证明的方法，其中引入了整数集上的一种奇特拓扑。<br>]]>
    
    </summary>
    
      <category term="拓扑" scheme="http://dna049.com/tags/%E6%8B%93%E6%89%91/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hahn-Banach 延拓定理]]></title>
    <link href="http://dna049.com/2016/02/19/Hahn-Banach-%E5%BB%B6%E6%8B%93%E5%AE%9A%E7%90%86/"/>
    <id>http://dna049.com/2016/02/19/Hahn-Banach-延拓定理/</id>
    <published>2016-02-19T00:26:38.000Z</published>
    <updated>2016-02-23T11:34:40.000Z</updated>
    <content type="html"><![CDATA[<p>Hahn-Banach 延拓定理通常分为分析和几何的形式，其中几何形式通常称为凸集分离性定理。<br><a id="more"></a></p>
<h3 id="Hahn-Banach__u5EF6_u62D3_u5B9A_u7406_u7684_u5206_u6790_u5F62_u5F0F"><a href="#Hahn-Banach__u5EF6_u62D3_u5B9A_u7406_u7684_u5206_u6790_u5F62_u5F0F" class="headerlink" title="Hahn-Banach 延拓定理的分析形式"></a>Hahn-Banach 延拓定理的分析形式</h3><p><strong>定义1</strong> 设 $X$ 是线性空间，$p \colon X \to \mathbb{R}$ 是一个泛函，若 $p$ 满足</p>
<ol>
<li>$p(x+y) \leq p(x)+p(y)$ 则称 $p$ 在 $X$ 上是次可加的，若</li>
<li>$p(tx)=tp(x),\; \forall x \in X,t \geq 0$ 则称 $p$ 在 $X$ 上是正齐次的，若 $p$ 满足1和</li>
<li>$p(ax)=|a|p(x),\; \forall x \in X, a \in \Phi $ 则称 $p$ 是 $X$ 上的半范数。</li>
</ol>
<p><strong>定理1</strong> (实情形) 设 $X$ 是实线性空间， $p \colon X \to \mathbb{R}$是正齐性次可加泛函，$Y$ 是 $X$ 的线性子空间。若 $f_0 \colon Y \to \mathbb{R}$ 是 $Y$ 上的线性泛函，满足<br>$$ f_0(x) \leq p(x),\; \forall x \in Y $$<br>则 $X$ 上存在线性泛函 $f \colon X \to \mathbb{R}$使得<br>$$ f|_Y = f_0 ,f(x) \leq p(x),\; \forall x \in X $$</p>
<p>证明: 设 $x_0 \in X \setminus Y$ 记 $ \widetilde{Y} = span\lbrace  x_0,Y\rbrace$,首先将 $Y$ 延拓到 $\widetilde{Y}$ 再利用Zorn引理延拓完成整个证明。<br>$$ f(x) + f(y) =f(x+y) \leq p(x+y) \leq p(x-x_0) + p(x_0+y),\; \forall x,y \in Y $$<br>因此<br>$$ f(x) - p(x-x_0) \leq p(x_0+y) - f(y) $$<br>我们记 $ \alpha \equiv \inf_{y \in Y} p(x_0+y) - f(y)$，则<br>$$ f(x) - \alpha \leq p(x - x_0) ,\; f(y) + \alpha \leq f(y+x_0) ,\; \forall x,y \in Y$$<br>在 $\widetilde{Y}$ 上定义 $ f(tx_0 +y) = t \alpha + f_0(y) $ 显然 $f$ 是 $\widetilde{Y}$ 上的线性泛函且是 $f_0$ 的延拓且满足 $f(x) \leq p(x)$。<br>根据延拓关系建立偏序关系，用Zorn引理即知定理1成立</p>
<p><strong>定理2</strong> (复情形) 设 $X$ 是复线性空间， $p \colon X \to \mathbb{R}$是 $X$ 上的半范数，$Y$ 是 $X$ 的线性子空间。若 $f_0 \colon Y \to \mathbb{C}$ 是 $Y$ 上的线性泛函，满足<br>$$ |f_0(x)| \leq p(x),\; \forall x \in Y $$<br>则 $X$ 上存在线性泛函 $f \colon X \to \mathbb{C}$使得<br>$$ f|_Y = f_0 ,|f(x)| \leq p(x),\; \forall x \in X $$</p>
<p>证明: 考虑实部应用定理1，可以证明定理2. 取 $u = \Re{f_0}$ 则，由定理1，$u$ 可以延拓到 $X$ 上得到实线性泛函 $U$ 使得 $U(x) \leq p(x) ,\; \forall x \in X$ 。定义 $f(x) = U(x) - iU(ix),\; \forall x \in X$ 任意验证 $f$ 即为所求。  </p>
<p><strong>推论1</strong> 设 $X$ 是赋范空间，$x_0 \in X$,则存在连续线性泛函 $f$ 满足 $f(x_0) = ||x_0|| ,||f|| = 1$.<br><strong>推论2</strong> 设 $Y$ 是赋范空间 $X$ 的真闭子空间， 则存在连续线性泛函 $f$ 满足</p>
<ol>
<li>$f(y) = 0,y \in Y$,</li>
<li>$f(x) = dist(x,Y)$</li>
<li>$||f|| = 1$</li>
</ol>
<p><strong>推论3</strong> 设 $X$ 是赋范空间，$x_0,y_0 \in X, x_0 \neq y_0$ ，则存在连续线性泛函 $f$，使得 $f(x_0) \neq f(y_0)$</p>
<h3 id="Hahn-Banach__u5EF6_u62D3_u5B9A_u7406_u7684_u51E0_u4F55_u5F62_u5F0F"><a href="#Hahn-Banach__u5EF6_u62D3_u5B9A_u7406_u7684_u51E0_u4F55_u5F62_u5F0F" class="headerlink" title="Hahn-Banach 延拓定理的几何形式"></a>Hahn-Banach 延拓定理的几何形式</h3><p><strong>定理3</strong> 设 $X$ 是拓扑线性空间， $X^{* }$ 表示其上连续线性泛函全体，$A,B \subset X$ 是非空凸集。</p>
<ol>
<li>若 $A^{o} \neq \emptyset, A^{o} \cap B = \emptyset$ 则 $\exists f \in X^{* },f \neq 0$ 使得<br>$$ \Re f(x) \leq \Re f(y),\; \forall x \in A,y \in B. $$</li>
<li>若 $A$ 是开集，$A \cap B = \emptyset$, 则 $\exists f \in X^{* },r \in \mathbb{R}$ 使得<br>$$ \Re f(x) &lt; r \leq \Re f(y),\; \forall x \in A,y \in B. $$<br>若B也是开集，则可使右端不等式严格成立。</li>
<li>若空间 $X$ 是局部凸的，$A$ 是紧集，$B$ 是闭集，$A \cap B = \emptyset$ 则 $\exists f \in X^{* },r_1,r_2 \in \mathbb{R}$ 使得<br>$$ \Re f(x) \leq r_1 &lt; r_2 \leq \Re f(y),\; \forall x \in A,y \in B. $$</li>
<li>若空间 $X$ 是局部凸的，$A$ 是平衡开集，$A \cap B = \emptyset$ 则 $\exists f \in X^{* },r \in \mathbb{R}$ 使得<br>$$ |f(x)| &lt; r \leq |f(y)|, \; \forall x \in A,y \in B $$</li>
</ol>
<p>证明: 由于复线性泛函 $f$ 可以写成 $f(x) = \Re f(x) - i \Re f(ix)$ ,我们不妨假设 $X$ 是实空间，否则先将复空间视作是空间，得出实线性泛函，然后根据上式构造$X$上的复线性泛函，并不为影响上面的结论。</p>
<ol>
<li>不妨假定(线性泛函平移一下) $0 \in A^{o}$，取 $x_0 \in B$,令 $C = A^{o} - B + x_0$ 则 $C$ 是开凸集，$x_0 \notin C$。若$\mu_C$是$C$的 Minkovski 泛函(是正齐次次可加泛函)，则$\mu_C(x_0) \geq 1$ 定义<br>$$ M = \lbrace t x_0 \colon t \in \mathbb{R} \rbrace , f_0(t x_0) = t$$<br>在 $M$ 上 $f_0(t x_0) = t \leq t\mu_C(x_0) \leq \mu_0(t x_0)$ 由定理1知，存在线性泛函 $f \colon X \to \mathbb{R}$ 使得<br>$$ f|_M = f_0 ,f(x) \leq \mu_C(x),\; \forall x \in X $$<br>注意到在$C \cap (-C)$ 上<br>$$ \pm f(x) = f(\pm x) \leq \mu_C (\pm x) \leq 1$$<br>易知 $f$ 连续。<br>当 $x \in A^{o},y \in B$ 时 $x-y+x_0 \in C$,因此<br>$$f(x-y+x_0) \leq \mu_C(x-y+x_0) \leq 1$$<br>因此 $f(x) &lt; f(y)$,又对于凸集$A$ 有$ \overline{A^{o}} = \overline{A}$，所以 $f(x) \leq f(y),\; \forall x \in A ,y \in B$.</li>
<li>对上述 $f$ 记 $r = \inf_{y \in B} f(y)$,若 $A$ 是开集，则有 $f(x) \leq r, \forall x \in A$，否则设 $x_0 \in A,f(x_0) = r$.因为 $A$ 是开集，因此存在 $z \in X$ 使得$x_0 \pm z \in A,f(z) \neq 0$.于是 $f(x_0 \pm z) = r \pm  f(z)$矛盾，同理 $B$ 为开集时，右端也是严格的。</li>
<li>当 $A$ 紧，$B$ 闭时，取凸邻域 $V \in N(0)$，使得$ (A+V) \cap B = 0 $ ，由1，存在 $f \in X^{* },r \in \mathbb{R}$ 使得<br>$$ \Re f(x) &lt; r \leq \Re f(y),\; \forall x \in A+V,y \in B. $$<br>记 $r_1 = \sup_{x \in A} f(x),r_2 =\inf_{y \in B} f(y)$.因为 $A$ 是紧集，因此 r_1 必然可达到，此时必有 $r_1 \leq  r_2$，否则又会出现类似于2的矛盾。</li>
<li>根据2，存在$f \in X^{* },r&gt;0$ 使得<br>$$ \Re f(x) &lt; r \leq \Re f(y),\; \forall x \in A,y \in B. $$<br>由于 $A$ 是平衡集，故 $x \in A$ 当且仅当 $e^{-i \theta}x \in A, \theta \in \mathbb{R}$,特别的取 $\theta = \arg f(x)$ 则<br>$$ |f(x)| = e^{-i \theta}f(x) = f(e^{i \theta}x) = \Re f(e^{i \theta}x) &lt; r $$<br>这是我们要的不等式左边，右边直接由 $\Re f(y) \leq |f(y)|$ 得到,证毕。</li>
</ol>
<p>欢迎访问和评论 <a href="http://dna049.com">http://dna049.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Hahn-Banach 延拓定理通常分为分析和几何的形式，其中几何形式通常称为凸集分离性定理。<br>]]>
    
    </summary>
    
      <category term="泛函分析" scheme="http://dna049.com/tags/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拓扑线性空间的若干基本定理]]></title>
    <link href="http://dna049.com/2016/02/18/%E6%8B%93%E6%89%91%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/"/>
    <id>http://dna049.com/2016/02/18/拓扑线性空间的若干基本定理/</id>
    <published>2016-02-18T08:02:15.000Z</published>
    <updated>2016-02-23T11:16:57.000Z</updated>
    <content type="html"><![CDATA[<p>在泛函分析中几个基本重要的定理：一致有界原理，开映射定理，闭图像定理等都可以相应的推广到拓扑线性空间中。以下内容来自刘培德《拓扑线性空间与算子谱理论》第二章。<br><a id="more"></a></p>
<p>设 $X,Y$ 是拓扑线性空间，记$L(X,Y)$ 是 $X$ 到 $Y$ 的线性算子全体，而$\mathscr{L}(X,Y)$ 是 $X$ 到 $Y$ 的连续线性算子全体。$N_X(x)$ 表示 $x \in X$ 的邻域全体。除非特别声明，以下$X,Y$都是拓扑线性空间</p>
<h3 id="u7B49_u5EA6_u8FDE_u7EED_u548C_u4E00_u81F4_u6709_u754C"><a href="#u7B49_u5EA6_u8FDE_u7EED_u548C_u4E00_u81F4_u6709_u754C" class="headerlink" title="等度连续和一致有界"></a>等度连续和一致有界</h3><p>等度连续: 称算子族 $\mathscr{H} \subset L(X,Y)$ 是等度连续的，若 $\forall U \in N_Y(0), V \in N_X(0)$ 使得<br><span>$$T(V) \subset U, \; \forall T \in \mathscr{H}
 \; \Leftrightarrow \;
\cup_{T \in \mathscr{H} } T(V) \subset U$$</span><!-- Has MathJax --></p>
<p>一致有界: 称算子族 $\mathscr{H} \subset L(X,Y)$ 是一致有界的，若对 $X$ 中任一有界集 $E$ , $\cup_{T \in \mathscr{H}} T(E)$ 是有界.</p>
<p><strong>定理1</strong> 设 $\mathscr{H}$ 是 $L(X,Y)$ 中的一族算子。</p>
<ol>
<li>若 $\mathscr{H}$ 是等度连续的，则 $\mathscr{H}$ 是一致有界的。</li>
<li>若 $X$ 是可度量化的，$\mathscr{H}$ 是一致有界的，则 $\mathscr{H}$ 是等度连续的</li>
</ol>
<p>证明：</p>
<ol>
<li>若 $\mathscr{H}$ 是等度连续的，则$\forall U \in N_Y(0), \exists V \in N_X(0)$ 使得 $T(V) \subset U, \; \forall T \in \mathscr{H}$ .对 $X$ 中任一有界集 $E$，则 $\exists t &gt; 0$ 使得 $s&gt;t$ 时，$E \subset sV$,于是<span>$$T(E) \subset T(sV) = sT(V) \subset sU , \;
\forall T \in \mathscr{H}$$</span><!-- Has MathJax -->
从而 $\cup _ {T \in \mathscr{H} } T(V) \subset U$ , $\mathscr{H}$ 是一致有界的。</li>
<li>反证，设 $U \in N_Y(0)$ ,若不存在 $V$ 使得 $\cup_{T \in \mathscr{H} } T(V) \subset U$ ,则可取 $T_n \in \mathscr{H},x_n \in X, x_n \to 0$ 但 $Tx_n \notin U$.由于 $d(x_n,0) \to 0$ ,存在 $r_n \to \infty$ 使得 $r_n x_n \to 0$ . $r_n x_n$ 是有界的，从而 $\cup_{T \in \mathscr{H}} T(r_n x_n)$ 有界。但是<br>$$ r_n ^{-1} T(r_n x_n) = T(x_n) \notin U $$<br>矛盾与有界性的等价条件。</li>
</ol>
<h3 id="u4E00_u81F4_u6709_u754C_u6027_u539F_u7406"><a href="#u4E00_u81F4_u6709_u754C_u6027_u539F_u7406" class="headerlink" title="一致有界性原理"></a>一致有界性原理</h3><p><strong>定理2</strong> 设 $\mathscr{H} \subset \mathscr{L}(X,Y)$ , 记$E$为使 $\lbrace Tx:T \in \mathscr{H} \rbrace$ 的点 $x$ 全体。若 $E$ 是第二纲集，则 $\mathscr{H}$ 等度连续，此时必有 $E=X$.</p>
<p>证明：设 $W \in N_Y(0)$ ，取0点的平衡邻域 $U$ 使得 $ \overline{U} + \overline{U} \subset W$ 。记 $B = \cap_{T \in \mathscr{H} } T^{-1} (\overline{U})$，有 $T$ 的连续性知 $B$ 是闭集。$\forall x \in E, \lbrace Tx, T \in mathscr{H} \rbrace$ 有界。因此，$\exists n$ 使得 $Tx \in nU \forall T \in \mathscr{H} $，即 $\frac{x}{n} \in T^{-1} (U) \in T^{-1} (\overline{U})$ 。于是 $x \in nB,E \subset \cup_{n=1}^{\infty} nB$。$E$ 是第二纲集，因此有某个 $(nB)^{o} \neq \emptyset $,从而 $(B)^{o} \neq \emptyset $.<br>设 $x \in B^{o}$,记 $V = x-B^{o}$ ,则 $V \in N_X(0)$.注意到 $T(B) \in \overline{U} ,\forall T \in \mathscr{H} $。因此<br>$$ T(V) \subset Tx - T(B) \subset \overline{U} - \overline{U} \in W ,\forall T \in \mathscr{H} $$<br>这说明 $\mathscr{H}$ 是等度连续的。<br>由定理1知，此时 $\mathscr{H}$ 是一致有界的，又单点集 ${x}$ 有界，因此 $\lbrace Tx:T \in \mathscr{H} \rbrace$ 有界，所以 $E=X$。</p>
<p>定理3 (Banach-Steinhaus) 设 $ T_n\in \mathscr{L}(X,Y)$ , 记$E$为使 $\lim_{n \to \infty} T_n x $ 存在的 $x$ 全体。若 $E$ 是第二纲集，则$E=X$.<br>证明：由于收敛序列是有界的，因此根据定理2，上述结论显然。</p>
<h3 id="u5F00_u6620_u5C04_u5B9A_u7406"><a href="#u5F00_u6620_u5C04_u5B9A_u7406" class="headerlink" title="开映射定理"></a>开映射定理</h3><p>从 $X$ 到 $Y$ 的线性算子称为开算子，如果它把 $X$ 中的每一个开集映成 $Y$ 中的开集。</p>
<p><strong>定理4</strong> (开映射定理) 若 $X,Y$ 是 $F$ 空间(完备的赋准范空间)，$T \in \mathscr{L}(X,Y),T(X)$ 是 $Y$ 中的第二纲集，则 $T$ 是开算子，且此时$Y=T(X)$。</p>
<p>为证明开映射定理，先证明三个引理。</p>
<p><strong>引理1</strong> 设 $T:X \to Y$ 是线性算子，则 $T$ 是开映射，当且仅当 $\forall V \in N_X(0)$,$0 \in Y$ 是 $T(V)$ 的内点。</p>
<p>证明：若$T$ 是开算子，$V \in N_X(0)$,则 $T(V)$开，又 $T0=0$ ,故 $0 \in Y$ 是 $T(V)$ 的内点。<br>反之，若 $T$ 将0点的邻域映成以0为内点的集合。则对每个开集 $B \subset X$ ,$B$ 可以写成 $B = \cup_{x \in B } (x+V_x) $ 于是<br>$$ T(B) = \cup_{x \in B} T(x+V_x) = \cup_{x \in B}(Tx - T(V_x)) $$<br>由于 $T(V_x)$ 是以0为内点，上式表明 $Tx$ 是 $T(B)$ 的内点,从而 $T(B)$ 是 $Y$ 中的开集。</p>
<p><strong>引理2</strong> 设 $T:X \to Y$ 是线性算子，则 $T$ 是开映射，则 $T$ 是到上(满)的。</p>
<p>证明: 若 $T$ 是开映射，则 $\forall V \in X$, $T(V)$ 是 $Y$ 中的开集，$V,T(V)$都是吸收的，所以<br>$$ Y = \cup_{n=1}^{\infty} nT(V) = T(\cup_{n=1}^{\infty} nV) = T(X) $$</p>
<p><strong>引理3</strong> 设 $T:X \to Y$ 是线性算子，若 $T(X)$ 是 $Y$ 中的第二纲集，则 $\forall U \in N_X(0),\exists B \in N_Y(0)$ 使得 $B \in \overline{T(U)}$</p>
<p>证明: $\forall U \in N_X(0)$ ,取 $\forall V \in N_X(0)$ 使得 $V$ 是平衡的且 $V-V \subset U$.<br>$$ T(X) = T(\cup_{n=1}^{\infty} nV) = \cup_{n=1}^{\infty} nT(V)$$ 是第二纲的，所以 $\exists n$ 使得 $\overline{nT(V)}^{o} \neq \emptyset$，因此 $\overline{T(V)}^{o} \neq \emptyset$. 于是存在开集 $B \in N_X(0)$ 使得<br>$$B \subset \overline{T(V)} - \overline{T(V)} \subset \overline{T(V-V)} \subset \overline{T(U)} $$ </p>
<p>开映射定理证明: 设 $p,q$ 分别是 $X,Y$ 上的准范数，取<br>$$ U=\lbrace x \colon p(x)&lt;r \rbrace ,\quad U_n = \lbrace x \colon q(x) &lt; \frac{r}{2^n} \rbrace $$<br>由引理3知，存在$B_n \in N_Y(0)$ 使得 $B_n \subset \overline{T(U_n)}$.由引理1知，我们只需证明 $B_1 \subset U$.记<br>$$ O_n = \lbrace y \in Y \colon q(y) &lt; \frac{1}{n} \rbrace $$<br>任取 $y_1 \in B_1 \subset \overline{T(U_1)}$, 于是 $\exists x_1 \in U_1$ 使得 $y_2 = y_1 - Tx_1 \in B_2 \cap O_2$,类似地做，$\exists x_n \in U_n$ 使得 $y_{n+1} = y_n - Tx_n \in B_{n+1} \cap O_{n+1}$<br>此时<br>$$ y_{n+1} = y_1 -T(\sum_{i=1}^n x_i)$$<br>由于<br>$$ p(\sum_{i=1}^n x_i) \leq \sum_{i=1}^n p(x_i) &lt; \sum_{i=1}^n \frac{r}{2^n} &lt; r $$<br>并且由于 $\lbrace \sum_{i=1}^n x_i \rbrace$ 是Cauchy列，$\exists x_0 \in X, \sum_{i=1}^n x_i \to x_0$ 并且 $p(x_0) &lt; r$,从而 $x_0 \in U$。<br>注意到 $y_n \in O_n$, $y_n \to 0$。由 $T$ 的连续性<br>$$ 0 = \lim_{n \to \infty} y_{n+1} = y_1 - \lim_{n \to \infty} T(\sum_{i=1}^n x_i) = y_1 - Tx_0 $$<br>即 $y_1 = Tx_0 \in T(U)$,故$B \in T(U)$,证毕。</p>
<p><strong>推论1</strong> (Banach逆算子定理的推广) 从 $F$ 空间到　$F$ 空间上的每一个连续线性满算子 $T$ 的开算子，若 $T$ 还是一一的，则 $T$ 是同胚映射。<br><strong>推论2</strong> (范数等价定理的推广) 设 $X$ 上有两种拓扑 $\tau_1,\tau_2$,并且$\tau_1,\tau_2$ 都使 $X$ 成为 $F$ 空间，若$\tau_1,\tau_2$ 是可比较的，则$\tau_1 ＝ \tau_2$ 。</p>
<h3 id="u95ED_u56FE_u50CF_u5B9A_u7406"><a href="#u95ED_u56FE_u50CF_u5B9A_u7406" class="headerlink" title="闭图像定理"></a>闭图像定理</h3><p>设 $X,Y$ 是拓扑线性空间，$X \times Y$ 是乘积空间，$T \colon X \to Y$ 是线性算子，称 $T$ 是闭算子，若 $T$ 的图像 $\mathscr{G}(T) = \lbrace (x,Tx) \colon \forall x \in X \rbrace$ 是 $X \times Y$ 中的闭集。</p>
<p><strong>定理5</strong> 设 $X,Y$ 是拓扑线性空间，$T \colon X \to Y$ 是线性算子</p>
<ol>
<li>若 $T$ 是连续的，则 $T$ 是闭算子</li>
<li>(闭图像定理)若 $T$ 是闭算子，并且 $X,Y$ 都是 $F$ 空间，则 $T$ 是连续的。</li>
</ol>
<p>证明:</p>
<ol>
<li>设$T \colon X \to Y$ 连续，$(x_{\lambda},\lambda \in \Lambda)$ 是 $X$ 中的网，$x_{\lambda} \to x ,Tx_{\lambda} \to y$,则<br>$$ y = \lim_{\lambda \in \Lambda} Tx_{\lambda} =  T(\lim_{\lambda \in \Lambda} x_{\lambda}) = Tx$$<br>因此 $(x,y) \in \mathscr{G}(T)$,因此 $T$ 是闭算子。</li>
<li>注意到此时 $X \times Y$ 也是 $F$ 空间，由于 $\mathscr{G}(T)$ 是 $X \times Y$ 的线性子空间，若 $\mathscr{G}(T)$ 在 $X \times Y$ 中闭，$\mathscr{G}(T)$ 也是 $F$ 空间。由乘积拓扑的定义，两投影<br>$$ \pi_1 \colon \mathscr{G}(T) \to X, (x,Tx) \mapsto x, $$<br>$$ \pi_2 \colon \mathscr{G}(T) \to X, (x,Tx) \mapsto Tx $$<br>都是连续的。特别的 $\pi_1$ 是一一到上的，由推论1知，$\pi_1^{-1} \colon X \to \mathscr{G}(T)$ 连续，此时<br>$$ Tx = \pi_2(x,Tx) = \pi_2 \circ \pi_1^{-1} x,\forall x \in X $$<br>从而$T=\pi_2 \circ \pi_1^{-1}$</li>
</ol>
<pre><code>我发现我喜欢在此记录我学习的东西，反正这里也很少会有人来看，写出来很大的目的是让我自己走一遍过程，写总比看来的深刻。
</code></pre><p>欢迎访问0.0 <a href="http://dna049.com">http://dna049.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在泛函分析中几个基本重要的定理：一致有界原理，开映射定理，闭图像定理等都可以相应的推广到拓扑线性空间中。以下内容来自刘培德《拓扑线性空间与算子谱理论》第二章。<br>]]>
    
    </summary>
    
      <category term="泛函分析" scheme="http://dna049.com/tags/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[“公平”的席位分配]]></title>
    <link href="http://dna049.com/2016/02/17/%E5%85%AC%E5%B9%B3%E7%9A%84%E5%B8%AD%E4%BD%8D%E5%88%86%E9%85%8D/"/>
    <id>http://dna049.com/2016/02/17/公平的席位分配/</id>
    <published>2016-02-17T04:23:42.000Z</published>
    <updated>2016-02-23T11:16:53.000Z</updated>
    <content type="html"><![CDATA[<p>如果说数学有点用，估计大都表现在运筹学中吧。“公平”的席位分配首先本来就是不可能的，公平一般是无法达到的，我们只是尽量降低不公平度，那么我们怎么衡量不公平度呢。就像评价一个人，有不同的指标，不公平度也是一样，这里介绍一种相对合理易于接受，且好判断的方法。<br><a id="more"></a></p>
<h3 id="u95EE_u9898_u8868_u8FF0"><a href="#u95EE_u9898_u8868_u8FF0" class="headerlink" title="问题表述"></a>问题表述</h3><p>某学校三个系部学生共200名,(甲系100,乙系60,丙系40)代表会议共20席,按比例分配三个系分别为10、6、4席。老情况变为下列情况怎样分配才是最公平的,现因学生转系三系人数为103、63、34。 </p>
<ol>
<li>问20席该如何分配 ? </li>
<li>若增加21席又如何分配 ?</li>
</ol>
<p>显然，因为无法整除无论如何分配都不公平。下面说一下几种策略。</p>
<ol>
<li>按班级人数比例乘以总人数，小数点大的分得多余的一个位子。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">某校</th>
<th style="text-align:right">甲系</th>
<th style="text-align:right">乙系</th>
<th style="text-align:right">丙系</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">共200人</td>
<td style="text-align:right">103</td>
<td style="text-align:right">63</td>
<td style="text-align:right">34</td>
</tr>
<tr>
<td style="text-align:center">人数比例</td>
<td style="text-align:right">51.3</td>
<td style="text-align:right">31.5</td>
<td style="text-align:right">17</td>
</tr>
<tr>
<td style="text-align:center">20席位</td>
<td style="text-align:right">10.3</td>
<td style="text-align:right">6.3</td>
<td style="text-align:right">3.4</td>
</tr>
<tr>
<td style="text-align:center">实际分配</td>
<td style="text-align:right">10</td>
<td style="text-align:right">6</td>
<td style="text-align:right">4</td>
</tr>
<tr>
<td style="text-align:center">21席位</td>
<td style="text-align:right">10.82</td>
<td style="text-align:right">6.62</td>
<td style="text-align:right">3.57</td>
</tr>
<tr>
<td style="text-align:center">实际分配</td>
<td style="text-align:right">11</td>
<td style="text-align:right">7</td>
<td style="text-align:right">3</td>
</tr>
</tbody>
</table>
<p>按照上述方法，会出现席位增多而丙系的席位却减少了一个的不合理现象，说明此方法并不合理。</p>
<h3 id="u6A21_u578B_u5EFA_u7ACB"><a href="#u6A21_u578B_u5EFA_u7ACB" class="headerlink" title="模型建立"></a>模型建立</h3><p>假设由A、B两个单位公平分配席位的情况，设两方人数$p_1,p_2$ ,分配到的席位为 $n_1,n_2$。</p>
<ol>
<li>$\frac{p_1}{n_1} = \frac{p_2}{n_2}$ 公平，但是一般是不满足的。</li>
<li>$\frac{p_1}{n_1} &gt; \frac{p_2}{n_2}$ 对A不公平。</li>
<li>$\frac{p_1}{n_1} &lt; \frac{p_2}{n_2}$ 对B不公平。</li>
</ol>
<p>绝对不公平度为<br>$$ d = \left| \frac{p_1}{n_1} - \frac{p_2}{n_2} \right| $$<br>但这样做还是有不足，例如<br>某两个单位的人数和席位为 $n_1=n_2=10,p_1=120,p_2=100$ 算得  $d=2$.<br>另两个单位的人数和席位为 $n_1=n_2=10,p_1=1020,p_2=1000$ 算得 $d=2$。<br>但是显然，后一种方案，更公平。</p>
<p>因此，我们引入相对不公平度</p>
<ol>
<li>若 $\frac{p_1}{n_1} &gt; \frac{p_2}{n_2}$ 则<br>$$ r_A(n_1,n_2) = \frac{ \frac{p_1}{n_1} - \frac{p_2}{n_2} }{ \frac{p_2}{n_2} }$$</li>
<li>若 $\frac{p_1}{n_1} &lt; \frac{p_2}{n_2}$<br>$$ r_B(n_1,n_2) =  \frac{\frac{p_2}{n_2} - \frac{p_1}{n_1} }{\frac{p_1}{n_1}}$$<br>我们的目标是让$r_A,r_B$(每种分配只会有一个)最小。</li>
</ol>
<h5 id="u786E_u5B9A_u5206_u914D_u65B9_u6848"><a href="#u786E_u5B9A_u5206_u914D_u65B9_u6848" class="headerlink" title="确定分配方案"></a>确定分配方案</h5><p>假设当前 $\frac{p_1}{n_1} &gt; \frac{p_2}{n_2}$ 对A不公平。新增了一个席位。</p>
<ol>
<li>若 $\frac{p_1}{n_1+1} &gt; \frac{p_2}{n_2}$ 则A加1席</li>
<li>若 $\frac{p_1}{n_1+1} &lt; \frac{p_2}{n_2}$<br>若分配给A，则对B的不公平值(相对):<br>$$ r_B(n_1+1,n_2) = \frac{p_2(n_1+1)}{p_1 n_2} -1 $$<br>若分配给B，则对A的不公平值(相对):<br>$$ r_A(n_1,n_2+1) = \frac{p_1(n_2+1)}{p_2 n_1} -1 $$</li>
</ol>
<p>若$r_A(n_1,n_2+1)&lt;r_B(n_1+1,n_2)$则席位分配给B，反之给A。<br>即令<br>$$ Q_i = \frac{p_i ^2}{n_i(n_i+1)}$$<br>将席位分配给 $Q$ 值较大者。</p>
<h3 id="u6A21_u578B_u6C42_u89E3"><a href="#u6A21_u578B_u6C42_u89E3" class="headerlink" title="模型求解"></a>模型求解</h3><p>先按照平均原则取整之后。分出了19席：$n_1=10,n_2=6,n_3=3$<br>第20席:<br>$$ Q_1 = \frac{103^2}{10 \times 11 } = 96.4 \; , \;Q_2 = \frac{63^2}{6 \times 7} = 94.5 \; , \;Q_3 = \frac{34^2}{3 \times 4} = 96.3 $$<br>则分配：$n_1=11,n_2=6,n_3=3$<br>第21席：$Q_1=80.4, Q_2 = 94.5, Q_3 = 96.3$<br>则分配：$n_1=11,n_2=6,n_3=4$.</p>
<p>本文参考<a href="http://wenku.baidu.com/view/396d4f6aaf1ffc4ffe47ac52.html?re=view" target="_blank" rel="external">文库1</a>和<a href="http://wenku.baidu.com/view/312ef3274b35eefdc9d33304.html?re=view" target="_blank" rel="external">文库2</a>。修改了其中的错误，由于席位分配问题确实是一个经典问题，故在此记录。</p>
<p>欢迎访问<a href="http://dna049.com">http://dna049.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果说数学有点用，估计大都表现在运筹学中吧。“公平”的席位分配首先本来就是不可能的，公平一般是无法达到的，我们只是尽量降低不公平度，那么我们怎么衡量不公平度呢。就像评价一个人，有不同的指标，不公平度也是一样，这里介绍一种相对合理易于接受，且好判断的方法。<br>]]>
    
    </summary>
    
      <category term="运筹学" scheme="http://dna049.com/tags/%E8%BF%90%E7%AD%B9%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hdu 5628 (Dirichlet积与快速幂的应用)]]></title>
    <link href="http://dna049.com/2016/02/16/hdu-5628-Dirichlet%E7%A7%AF%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://dna049.com/2016/02/16/hdu-5628-Dirichlet积与快速幂的应用/</id>
    <published>2016-02-16T15:56:10.000Z</published>
    <updated>2016-03-06T02:37:56.000Z</updated>
    <content type="html"><![CDATA[<p>突然有点想打一场BestCoder，然后就看了看BC发现有道应用Dirichlet积的题。于是就去试了试。当然老套路还是很好过的，后来我想写的优美一点写成类的形式，不过一直出现Crash，于是跟周学长讨论了一下，外加一点看书，终于也是搞定了，就此存一下模版吧 0.0<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#pragma comment(linker,"/STACK:10240000,10240000")</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> clr(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PB push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lrt rt&lt;&lt;<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rrt rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lson l,m,lrt</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> rson m+<span class="number">1</span>,r,rrt</span></span><br><span class="line"><span class="comment">/*------------------------- template ------------------------------*/</span></span><br><span class="line"><span class="keyword">class</span> NumFun&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    NumFun(<span class="keyword">int</span> _n = <span class="number">0</span>)&#123;</span><br><span class="line">        n = _n;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    NumFun(<span class="keyword">const</span> NumFun &amp;A)&#123;</span><br><span class="line">        n = A.n;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            a[i]=A.a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NumFun &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NumFun &amp;A)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;A) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] a;</span><br><span class="line">            n = A.n;</span><br><span class="line">            a = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">                a[i]=A.a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~NumFun()&#123;</span><br><span class="line">        <span class="keyword">delete</span> [] a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> d=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            a[i]=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            a[i]=p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NumFun <span class="keyword">operator</span>*(<span class="keyword">const</span> NumFun &amp;A)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="function">NumFun <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">        R.init(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i*j&lt;=n;++j)&#123;</span><br><span class="line">                R.a[i*j] = (R.a[i*j] + LL(a[i])*A.a[j])%M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">NumFun <span class="title">pow</span><span class="params">(NumFun A,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="function">NumFun <span class="title">R</span><span class="params">(A.n)</span></span>;</span><br><span class="line">    R.init();</span><br><span class="line">    R.a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) R=R*A;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;  A=A*A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("/Users/c10110057/Desktop/AC/in","r",stdin);</span></span><br><span class="line"><span class="comment">//    freopen("/Users/c10110057/Desktop/AC/out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T,n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">NumFun <span class="title">R</span><span class="params">(n)</span></span>;</span><br><span class="line">        R.<span class="built_in">set</span>(a);</span><br><span class="line">        <span class="function">NumFun <span class="title">ONE</span><span class="params">(n)</span></span>;</span><br><span class="line">        ONE.init(<span class="number">1</span>);</span><br><span class="line">        R = <span class="function">R*<span class="title">pow</span><span class="params">(ONE,k)</span></span>;</span><br><span class="line">        R.print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>突然有点想打一场BestCoder，然后就看了看BC发现有道应用Dirichlet积的题。于是就去试了试。当然老套路还是很好过的，后来我想写的优美一点写成类的形式，不过一直出现Crash，于是跟周学长讨论了一下，外加一点看书，终于也是搞定了，就此存一下模版吧 0.0<br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://dna049.com/tags/C/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二次剩余和Guass互反律]]></title>
    <link href="http://dna049.com/2016/02/16/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E5%92%8CGuass%E4%BA%92%E5%8F%8D%E5%BE%8B/"/>
    <id>http://dna049.com/2016/02/16/二次剩余和Guass互反律/</id>
    <published>2016-02-16T13:05:36.000Z</published>
    <updated>2016-02-23T11:16:43.000Z</updated>
    <content type="html"><![CDATA[<p>从二次剩余问题，引入Legendre符号，由此一步步导出Guass互反律，最后延伸到Jacobi符号，整个步骤确实连贯优美，脍炙人口。<br><a id="more"></a></p>
<p>寒假回家好好调整了一下状态，回学校后感觉还不错，效率也蛮高。发现理图虽然比较破，但是还是很不错的，哈哈哈。每次读潘承洞先生的《数论基础》都觉得受益匪浅，我把自己很喜欢的部分写入到该文中。</p>
<h3 id="u4E8C_u6B21_u5269_u4F59"><a href="#u4E8C_u6B21_u5269_u4F59" class="headerlink" title="二次剩余"></a>二次剩余</h3><p>考虑如下形式二次同余式<br>$$ x^2 = a \; (mod \; p) $$<br>其中 $p$ 是奇素数。</p>
<p>经过简单推理很容易发现，在模 $p$ 的简化系中，二次剩余与二次非剩余各占一半。且容易知道，$1^2,2^2,\cdots,(\frac{p-1}{2})^2$ 都是二次剩余。</p>
<h3 id="Legendre__u7B26_u53F7"><a href="#Legendre__u7B26_u53F7" class="headerlink" title="Legendre 符号"></a>Legendre 符号</h3><span>$$\left( \frac{a}{p} \right) = \left\{ \begin{array}{cc} 1, &amp; a\; R\; p \\
0, &amp; p\;|\;a \\
-1, &amp; a\; \overline{R}\; p. \end{array} \right.$$</span><!-- Has MathJax -->
<h5 id="u5B9A_u74061__3C_21-_uFFFC4-_3E"><a href="#u5B9A_u74061__3C_21-_uFFFC4-_3E" class="headerlink" title="定理1   <span>$\quad -(\frac{a}{p}) (p-1)! \equiv a^{\frac{p-1}{2}} \;(mod \; p)$</span><!-- Has MathJax -->"></a>定理1   <span>$\quad -(\frac{a}{p}) (p-1)! \equiv a^{\frac{p-1}{2}} \;(mod \; p)$</span><!-- Has MathJax --></h5><p>Proof: 对于 $p\;|\;a$ 的情形，结论显然。下面考虑 $(p,a)=1$ 的情形，令<br>$$ S = \lbrace 1,2,\cdots,p-1 \rbrace $$<br>对任意的 $ x \in S $ 必存在唯一的 $ y \in S $ 为下面同余式的解<br>$$ yx \equiv a \; (mod \; p) $$</p>
<p>(i) 当 $ (\frac{a}{p}) = -1 $ 时，同余式<br>$$ x^2 = a \; (mod \; p) $$<br>无解，所以 $y \neq x $ .因此集合 $S$ 中的元素可以分成 $\frac{p-1}{2} $ 对，我们就有<br>$$ (p-1)! \equiv a^{\frac{p-1}{2}} \;(mod \; p) $$<br>(ii) 当 $ (\frac{a}{p}) = 1 $ 时，同余式<br>$$ x^2 = a \; (mod \; p) $$<br>有两个解 $x_0$ 和 $p - x_0$.在$S$中去掉这两个数外剩下$p-3$个数分出 $\frac{p-3}{2}$对，则有<br>$$ (p-1)! \equiv a^{\frac{p-3}{2}}x_0(p-x_0) \;(mod \; p) \equiv - a^{\frac{p-1}{2}} \;(mod \; p) $$ 证毕。</p>
<h5 id="u63A8_u8BBA2__28Wilson__u5B9A_u7406_29"><a href="#u63A8_u8BBA2__28Wilson__u5B9A_u7406_29" class="headerlink" title="推论2 (Wilson 定理)"></a>推论2 (Wilson 定理)</h5><p>$$ (p-1)! \equiv -1 \;(mod \; p) $$<br>Proof: 定理一 中取 $a=1$即可。</p>
<h5 id="u63A8_u8BBA3__28Euler__u5224_u522B_u6CD5_29"><a href="#u63A8_u8BBA3__28Euler__u5224_u522B_u6CD5_29" class="headerlink" title="推论3 (Euler 判别法)"></a>推论3 (Euler 判别法)</h5><p>$$ \left( \frac{a}{p} \right ) \equiv a^{\frac{p-1}{2}} \;(mod \;p ) $$<br>Proof: 由定理1和推论2显然。Euler判别法不仅有理论价值(下面都是推论3的直接推论)，由于快速幂的存在，使得Euler判别法在计算时有相当好的效果。</p>
<h5 id="u63A8_u8BBA4__28Format__u5C0F_u5B9A_u7406_29__u8BBE__24_28a_2Cp_29_3D1_24__2C_u5219"><a href="#u63A8_u8BBA4__28Format__u5C0F_u5B9A_u7406_29__u8BBE__24_28a_2Cp_29_3D1_24__2C_u5219" class="headerlink" title="推论4 (Format 小定理) 设 $(a,p)=1$ ,则"></a>推论4 (Format 小定理) 设 $(a,p)=1$ ,则</h5><p>$$ a^{p-1} \equiv 1 \;(mod \; p) $$</p>
<h5 id="u63A8_u8BBA5__24_5C_3B__28_5Cfrac_7B-1_7D_7Bp_7D_29__3D__28-1_29_5E_7B_5Cfrac_7Bp-1_7D_7B2_7D_7D_24"><a href="#u63A8_u8BBA5__24_5C_3B__28_5Cfrac_7B-1_7D_7Bp_7D_29__3D__28-1_29_5E_7B_5Cfrac_7Bp-1_7D_7B2_7D_7D_24" class="headerlink" title="推论5 $\; (\frac{-1}{p}) = (-1)^{\frac{p-1}{2}}$"></a>推论5 $\; (\frac{-1}{p}) = (-1)^{\frac{p-1}{2}}$</h5><h5 id="u63A8_u8BBA6__24_5C_3B__28_5Cfrac_7Bab_7D_7Bp_7D_29__3D_28_5Cfrac_7Ba_7D_7Bp_7D_29_28_5Cfrac_7Bb_7D_7Bp_7D_29__24"><a href="#u63A8_u8BBA6__24_5C_3B__28_5Cfrac_7Bab_7D_7Bp_7D_29__3D_28_5Cfrac_7Ba_7D_7Bp_7D_29_28_5Cfrac_7Bb_7D_7Bp_7D_29__24" class="headerlink" title="推论6 $\; (\frac{ab}{p}) =(\frac{a}{p})(\frac{b}{p}) $"></a>推论6 $\; (\frac{ab}{p}) =(\frac{a}{p})(\frac{b}{p}) $</h5><p>推论3说明，我们求 Legendre 符号，可以转化成求 $ (\frac{2}{p}),(\frac{q}{p}) $.</p>
<h5 id="u5B9A_u74067__24_5C_3B__28_5Cfrac_7B2_7D_7Bp_7D_29__3D__28-1_29_5E_7B_5Cfrac_7Bp_5E2-1_7D_7B8_7D_7D_24"><a href="#u5B9A_u74067__24_5C_3B__28_5Cfrac_7B2_7D_7Bp_7D_29__3D__28-1_29_5E_7B_5Cfrac_7Bp_5E2-1_7D_7B8_7D_7D_24" class="headerlink" title="定理7 $\; (\frac{2}{p}) = (-1)^{\frac{p^2-1}{8}}$"></a>定理7 $\; (\frac{2}{p}) = (-1)^{\frac{p^2-1}{8}}$</h5><p>Proof:<br>$$ 2^{\frac{p-1}{2}}(\frac{p-1}{2})! = 2 \cdot 4 \cdots (p-1) \equiv (\frac{p-1}{2})!(-1)^{1+2+\cdots+\frac{p-1}{2}}\;(mod \; p) $$<br>所以<br>$$ (\frac{2}{p}) \equiv 2^{\frac{p-1}{2}} \equiv (-1)^{\frac{p^2-1}{8}} \;(mod \; p) $$ 证毕。</p>
<h5 id="u5B9A_u74068__28Guass__u4E8C_u6B21_u4E92_u53CD_u5F8B_29__u8BBE__24p_2Cq_24__u4E3A_u4E0D_u540C_u7684_u5947_u7D20_u6570_uFF0C_u5219_u6709"><a href="#u5B9A_u74068__28Guass__u4E8C_u6B21_u4E92_u53CD_u5F8B_29__u8BBE__24p_2Cq_24__u4E3A_u4E0D_u540C_u7684_u5947_u7D20_u6570_uFF0C_u5219_u6709" class="headerlink" title="定理8 (Guass 二次互反律) 设 $p,q$ 为不同的奇素数，则有"></a>定理8 (Guass 二次互反律) 设 $p,q$ 为不同的奇素数，则有</h5><p>$$ (\frac{p}{q}) (\frac{q}{p}) = (-1)^{\frac{(p-1)(q-1)}{4}}$$</p>
<p>Proof: 略。</p>
<p>这里只是简介的纪录一下比较简洁精彩的部分。更多数论的内容还是很推荐潘承洞先生的书的。另外指数原根等一些知识也讲的特别简洁明了。下面给出我写的求原根的MATLAB代码。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span> = <span class="title">zhi_shu</span><span class="params">(g,n)</span></span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line"><span class="comment">% 输入：底数g和模n</span></span><br><span class="line"><span class="comment">% 输出：其指数</span></span><br><span class="line"><span class="comment">% 2016-2-16 in FDU by dna049</span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line">r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> d = <span class="number">1</span>:n</span><br><span class="line">    r = <span class="built_in">mod</span>(r*g,n);</span><br><span class="line">    <span class="keyword">if</span> r == <span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span> = <span class="title">phi_euler</span><span class="params">(n)</span></span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line"><span class="comment">% Euler function in number theory</span></span><br><span class="line"><span class="comment">% 2016-2-16 in FDU by dna049</span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isprime</span>(n)</span><br><span class="line">        x = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pn = <span class="built_in">primes</span>(n);</span><br><span class="line">        x = n;</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = pn</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">mod</span>(n,<span class="built_in">i</span>) == <span class="number">0</span></span><br><span class="line">                n = n/<span class="built_in">i</span>;</span><br><span class="line">                <span class="keyword">while</span> <span class="built_in">mod</span>(n,<span class="built_in">i</span>) == <span class="number">0</span></span><br><span class="line">                    n = n/<span class="built_in">i</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                x = x/<span class="built_in">i</span>*(<span class="built_in">i</span>-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">i</span>&gt;n</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span> = <span class="title">yuan_gen_s</span><span class="params">(p)</span></span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line"><span class="comment">% 输入：素数p</span></span><br><span class="line"><span class="comment">% 输出：所有原根</span></span><br><span class="line"><span class="comment">% 2016-2-16 in FDU by dna049</span></span><br><span class="line"><span class="comment">%---------------------------------------</span></span><br><span class="line">d_now = p-<span class="number">1</span>;</span><br><span class="line">v = <span class="built_in">ones</span>(<span class="number">1</span>,p);</span><br><span class="line">v(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">v(p) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:p-<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> v(<span class="built_in">i</span>) == <span class="number">1</span></span><br><span class="line">        td = zhi_shu(<span class="built_in">i</span>,p);</span><br><span class="line">        <span class="keyword">if</span> td ~= p-<span class="number">1</span></span><br><span class="line">            tp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:td</span><br><span class="line">                tp = <span class="built_in">mod</span>(tp*<span class="built_in">i</span>-<span class="number">1</span>,p)+<span class="number">1</span>;</span><br><span class="line">                v(tp) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">d = <span class="number">1</span>:p;</span><br><span class="line">d = d(v==<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>从二次剩余问题，引入Legendre符号，由此一步步导出Guass互反律，最后延伸到Jacobi符号，整个步骤确实连贯优美，脍炙人口。<br>]]>
    
    </summary>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自然数方幂和公式]]></title>
    <link href="http://dna049.com/2016/01/21/%E8%87%AA%E7%84%B6%E6%95%B0%E6%96%B9%E5%B9%82%E5%92%8C%E5%85%AC%E5%BC%8F/"/>
    <id>http://dna049.com/2016/01/21/自然数方幂和公式/</id>
    <published>2016-01-21T11:16:51.000Z</published>
    <updated>2016-02-24T13:57:25.000Z</updated>
    <content type="html"><![CDATA[<p>关于自然数方幂和公式，网上的求解版本有很多种。这里介绍一种不为人知，十分简洁明了的求解方法，该公式并非原创，但是整个证明过程和方法完全原创。它的思想来源于我高中时在一本数学竞赛书中的数列例题(书名忘了…)，正因为一本本这样的书，让我大学选择了数学系，现在依然在学习数学。<br><a id="more"></a></p>
<h3 id="u82E5__24a_n__3D_n_28n-1_29_24__u6C42_u5176_u524D__24n_24__u9879_u548C_24S_n_24"><a href="#u82E5__24a_n__3D_n_28n-1_29_24__u6C42_u5176_u524D__24n_24__u9879_u548C_24S_n_24" class="headerlink" title="若 $a_n = n(n-1)$ 求其前 $n$ 项和$S_n$"></a>若 $a_n = n(n-1)$ 求其前 $n$ 项和$S_n$</h3><span>$$a_n = n(n-1) ＝
\frac{(n+1)n(n-1) -n(n-1)(n-2)}{3}$$</span><!-- Has MathJax -->
<p>所以<br><span>$$S_n =
\frac{(n+1)n(n-1)}{3}$$</span><!-- Has MathJax --></p>
<h3 id="u82E5_3C_21-_uFFFC2-_3E_uFF0C_u5219_u5176_u524D__24n_24__u9879_u548C_3C_21-_uFFFC3-_3E"><a href="#u82E5_3C_21-_uFFFC2-_3E_uFF0C_u5219_u5176_u524D__24n_24__u9879_u548C_3C_21-_uFFFC3-_3E" class="headerlink" title="若<span>$a_n = A_n ^p$</span><!-- Has MathJax -->，则其前 $n$ 项和<span>$S_n ＝ \frac{ A_{n+1} ^{p+1}}{p+1}$</span><!-- Has MathJax -->"></a>若<span>$a_n = A_n ^p$</span><!-- Has MathJax -->，则其前 $n$ 项和<span>$S_n ＝ \frac{ A_{n+1} ^{p+1}}{p+1}$</span><!-- Has MathJax --></h3><span>$$a_n = A_n ^p ＝
\frac{A_{n+1} ^{p+1} -A_n ^{p+1}}{p+1}$$</span><!-- Has MathJax -->
<p>所以<br><span>$$S_n =
\frac{A_{n+1} ^{p+1}}{p+1}$$</span><!-- Has MathJax --></p>
<p>由上面的结论下面我们来直对主题。</p>
<h3 id="u6C42__241_5E2+2_5E2+__5Cdots_+_n_5E2_24"><a href="#u6C42__241_5E2+2_5E2+__5Cdots_+_n_5E2_24" class="headerlink" title="求 $1^2+2^2+ \dots + n^2$"></a>求 $1^2+2^2+ \dots + n^2$</h3><p>由<br>$$ n^2 = n(n-1) + n $$<br>知<br>$$1^2+2^2+ \dots + n^2 = \frac{(n+1)n(n-1)}{3} + \frac{(n+1)n}{2} = \frac{n(n+1)(2n+1)}{6}$$</p>
<h3 id="u6C42_241_5Ep+2_5Ep+__5Cdots_+_n_5Ep_24"><a href="#u6C42_241_5Ep+2_5Ep+__5Cdots_+_n_5Ep_24" class="headerlink" title="求$1^p+2^p+ \dots + n^p$"></a>求$1^p+2^p+ \dots + n^p$</h3><p>设<br><span>$$n^p =
a_p A_n ^p + a_{p-1} A_n ^{p-1} + a_{p-2} A_n ^{p-2} + \cdots + a_1 A_n ^1$$</span><!-- Has MathJax --><br>则<br><span>$$1^p+2^p+ \dots + n^p =
\frac{a_p A_{n+1} ^{p+1}}{p+1} + \frac{a_{p-1} A_{n+1} ^{p}}{p} + \cdots + \frac{a_1 A_{n+1} ^2}{2}$$</span><!-- Has MathJax --><br>因此问题的关键就转化成如何求解数组 $a_k ,k=1,2,\cdots,p$<br>我们发现当 $n＝k$ 时成立<br><span>$$k^p =
a_k A_k ^k + a_{k-1} A_k ^{k-1} + \cdots a_1 A_{k} ^1$$</span><!-- Has MathJax --><br>令 $b_k = k! \cdot a_k$ 则<br><span>$$k^p = 
b_k + b_{k-1} C_k ^{k-1} + \cdots b_1 C_{k} ^1$$</span><!-- Has MathJax --><br>即<br><span>$$k^p = 
\sum _{j=1} ^k b_j C _{k} ^j$$</span><!-- Has MathJax --><br>应用二项式反演知(可参考<a href="http://dna049.com/2016/01/21/两类反演公式及其矩阵形式/">我的博文</a>)<br><span>$$b_k = 
\sum _{j=1} ^k (-1)^{k-j} C _{k} ^j k^p$$</span><!-- Has MathJax --><br>因此最终,我们有公式</p>
<span>$$1^p+2^p+ \dots + n^p =
\sum _{k=1} ^p \; (\; \sum_{j=1} ^ {k} (-1)^{k-j} C_k^j j^p \;) \; C _{n+1} ^{k+1}$$</span><!-- Has MathJax --> 
<p>本博文完全由作者(dna0.49)原创于2016年1月21号，转载或引用请注明<a href="http://dna049.com">http://dna049.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于自然数方幂和公式，网上的求解版本有很多种。这里介绍一种不为人知，十分简洁明了的求解方法，该公式并非原创，但是整个证明过程和方法完全原创。它的思想来源于我高中时在一本数学竞赛书中的数列例题(书名忘了…)，正因为一本本这样的书，让我大学选择了数学系，现在依然在学习数学。<br>]]>
    
    </summary>
    
      <category term="初等数学" scheme="http://dna049.com/tags/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[两类反演公式及其矩阵形式]]></title>
    <link href="http://dna049.com/2016/01/21/%E4%B8%A4%E7%B1%BB%E5%8F%8D%E6%BC%94%E5%85%AC%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F/"/>
    <id>http://dna049.com/2016/01/21/两类反演公式及其矩阵形式/</id>
    <published>2016-01-21T09:31:20.000Z</published>
    <updated>2016-02-23T11:17:17.000Z</updated>
    <content type="html"><![CDATA[<p>在上一篇<a href="http://dna049.com/2016/01/20/数论函数的Dirichlet积/">博文</a>中，介绍过数论中的 Mobius 反演公式，让我想起了另一个经典的反演公式－－－二项式反演公式。然而本质上反演公式就是矩阵求逆的过程。只是他们的逆有很简单的形式，因此就有了这样两个反演公式而已。<br><a id="more"></a></p>
<p>Mobius 反演在上一篇博客中已经提及，现在着重提一下二项式反演公式，这个公式让我在2014年ACM－ICPC亚洲区域赛西安站拿银，当时<a href="2014acmicpc-asia-xian-regional-contest.pdf">F题</a>答案直接算需要$n^3$复杂度，而利用二项式反演公式后，可以在$n^2$复杂度内完美解决。1A过题，感觉超爽。</p>
<h3 id="u53CD_u6F14_u516C_u5F0F_u4E0E_u5176_u77E9_u9635_u5F62_u5F0F"><a href="#u53CD_u6F14_u516C_u5F0F_u4E0E_u5176_u77E9_u9635_u5F62_u5F0F" class="headerlink" title="反演公式与其矩阵形式"></a>反演公式与其矩阵形式</h3><p>由<br><span>$$\sum _{r = 1} ^n a _{n,r} f(r) 
= g(n)$$</span><!-- Has MathJax --><br>其中$g(n)$已知，解出$f(n)$<br><span>$$f(n) = 
\sum _{r = 1} ^n b _{n,r} g(r)$$</span><!-- Has MathJax --><br>为其反演公式，也称上面两式互为反演公式。</p>
<p>令<br><span>$$A = \left( \begin{matrix} a _{11} &amp; &amp;  \\
a _{21} &amp; a _{22} &amp; \\
\cdots &amp; \cdots &amp; \ddots &amp; \\
a _{n1} &amp; a _{n2} &amp; \cdots &amp; a _{nn} \\
\end{matrix} \right) 
\qquad
B = \left( \begin{matrix} b _{11} &amp; &amp;  \\
b _{21} &amp; b _{22} &amp; \\
\cdots &amp; \cdots &amp; \ddots &amp; \\
b _{n1} &amp; b _{n2} &amp; \cdots &amp; b _{nn} \\
\end{matrix} \right)$$</span><!-- Has MathJax --></p>
<p>则上述反演公式本质上就是求矩阵$A$的逆$B$.</p>
<h3 id="u4E8C_u9879_u5F0F_u53CD_u6F14_u516C_u5F0F"><a href="#u4E8C_u9879_u5F0F_u53CD_u6F14_u516C_u5F0F" class="headerlink" title="二项式反演公式"></a>二项式反演公式</h3><p>若<br><span>$$g(n) = 
\sum _{r = s} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) f(r)$$</span><!-- Has MathJax --><br>其中 $s \geq 0$ 则<br><span>$$f(n) 
= \sum _{r = s} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) g(r)$$</span><!-- Has MathJax --></p>
<p>Proof: 要证明反演公式，只需证明，对应的矩阵 $A$ 和 $B$ 互为逆即可. 令 $C = A*B$ 则<br><span>$$\begin{align}
c _{ij} = \sum _{k=1} ^n a _{ik} b _{kj} &amp; = \sum _{k =j} ^ i \left(\begin{matrix} i \\ k\end{matrix}\right) (-1)^{k-j} \left(\begin{matrix} k \\ j\end{matrix}\right) = 
\sum _{k=0} ^ {i-j} \left(\begin{matrix} i \\ k+j\end{matrix}\right) (-1)^k \left(\begin{matrix} k+j \\ j\end{matrix}\right) \\
&amp; = \left(\begin{matrix} i \\ j\end{matrix}\right) \sum _{k=0} ^ {i-j} (-1)^k \left(\begin{matrix} i-j \\ k\end{matrix}\right) = \left\{ \begin{array}{ll} 1,&amp; i=j \\  0,&amp; i&gt;j\end{array} \right.
\end{align}$$</span><!-- Has MathJax --><br>证毕。</p>
<h3 id="u4E24_u7C7B_u53CD_u6F14_u516C_u5F0F_u7684_u5E94_u7528"><a href="#u4E24_u7C7B_u53CD_u6F14_u516C_u5F0F_u7684_u5E94_u7528" class="headerlink" title="两类反演公式的应用"></a>两类反演公式的应用</h3><p>这两类反演公式在组合数学和数论中都有诸多应用，这里简单的提几个。</p>
<h5 id="28_u9519_u6392_u95EE_u9898_29__u5728__24n_24__u4E2A_u6570_u5B57__241_2C2_2C_5Cdots_2Cn_24__u5F62_u6210__24n_21_24__u4E2A_u6392_u5217__24a_1a_2__5Cdots_a_n_24__u4E2D_u6EE1_u8DB3__24a_i__5Cneq_i_24__u7684_u6392_u5217_u6709_u591A_u5C11_u4E2A_uFF1F"><a href="#28_u9519_u6392_u95EE_u9898_29__u5728__24n_24__u4E2A_u6570_u5B57__241_2C2_2C_5Cdots_2Cn_24__u5F62_u6210__24n_21_24__u4E2A_u6392_u5217__24a_1a_2__5Cdots_a_n_24__u4E2D_u6EE1_u8DB3__24a_i__5Cneq_i_24__u7684_u6392_u5217_u6709_u591A_u5C11_u4E2A_uFF1F" class="headerlink" title="(错排问题) 在 $n$ 个数字 $1,2,\dots,n$ 形成 $n!$ 个排列 $a_1a_2 \dots a_n$ 中满足 $a_i \neq i$ 的排列有多少个？"></a>(错排问题) 在 $n$ 个数字 $1,2,\dots,n$ 形成 $n!$ 个排列 $a_1a_2 \dots a_n$ 中满足 $a_i \neq i$ 的排列有多少个？</h5><p>不妨设答案为 <span>$D_n$</span><!-- Has MathJax --> ,则可以看出恰好有 $r$ 个 <span>$a_i =i$</span><!-- Has MathJax -->的排列数为<span>$\left(\begin{matrix} n \\ r\end{matrix}\right) D_{n-r}$</span><!-- Has MathJax -->,因此<br><span>$$n! =
\sum _{r = 0} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) D_{n-r}$$</span><!-- Has MathJax --><br>因此<br><span>$$D_n ＝ 
\sum _{r = 0} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) r! = n! \sum _{r=0} ^n \frac{(-1)^r}{r!}$$</span><!-- Has MathJax --></p>
<h5 id="28_u6EE1_u5C04_u4E2A_u6570_29__u6C42m_u5143_u96C6A_u5230n_u5143_u96C6B_u7684_u6EE1_u8EAB_u7684_u4E2A_u6570g_28m_2Cn_29"><a href="#28_u6EE1_u5C04_u4E2A_u6570_29__u6C42m_u5143_u96C6A_u5230n_u5143_u96C6B_u7684_u6EE1_u8EAB_u7684_u4E2A_u6570g_28m_2Cn_29" class="headerlink" title="(满射个数) 求m元集A到n元集B的满身的个数g(m,n)"></a>(满射个数) 求m元集A到n元集B的满身的个数g(m,n)</h5><p>类似于错排的思路，我们有<br><span>$$n^m =
\sum _{r = 1} ^n \left(\begin{matrix} n \\ r\end{matrix}\right) g(m,r)$$</span><!-- Has MathJax --><br>于是<br><span>$$g(m,n) = 
\sum _{r = 1} ^n (-1)^{n-r} \left(\begin{matrix} n \\ r\end{matrix}\right) r^m$$</span><!-- Has MathJax --></p>
<h5 id="Mobius_u53CD_u6F14_u5728_u53EF_u91CD_u590D_u5706_u6392_u5217_u4E2D_u6709_u91CD_u8981_u5E94_u7528_uFF0C_u8FD9_u91CC_u5C31_u4E0D_u8BF4_u4E86_u3002"><a href="#Mobius_u53CD_u6F14_u5728_u53EF_u91CD_u590D_u5706_u6392_u5217_u4E2D_u6709_u91CD_u8981_u5E94_u7528_uFF0C_u8FD9_u91CC_u5C31_u4E0D_u8BF4_u4E86_u3002" class="headerlink" title="Mobius反演在可重复圆排列中有重要应用，这里就不说了。"></a>Mobius反演在可重复圆排列中有重要应用，这里就不说了。</h5><h3 id="Mobius__u77E9_u9635"><a href="#Mobius__u77E9_u9635" class="headerlink" title="Mobius 矩阵"></a>Mobius 矩阵</h3><p>由 Mobius 反演公式对应的矩阵我们有,若<br><span>$$a _{ij} = \left\{ \begin{array}{cc} 1, &amp; j|i \\
0, &amp; else. \end{array} \right.$$</span><!-- Has MathJax --><br>则，其逆矩阵为<br><span>$$b _{ij} = \left\{ \begin{array}{cc} \mu (\frac{i}{j}), &amp; j|i \\
0, &amp; else. \end{array} \right.$$</span><!-- Has MathJax --></p>
<p>本文参考了<a href="http://www.douban.com/note/480023639/?type=like" target="_blank" rel="external">豆瓣</a>和<a href="http://wenku.baidu.com/link?url=0m3D-588KfEUvocmKGoW5X4z5SHrEKVOaqfLoTeRtJaJcG6oDEUh2QEbJmNa1p2OTkqFLCqhfhM-RsoOI2fkutlqL9q3xgJhIAic4HumI5W" target="_blank" rel="external">百度文库</a>以及 许胤龙，孙淑玲《组合数学引论》。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇<a href="http://dna049.com/2016/01/20/数论函数的Dirichlet积/">博文</a>中，介绍过数论中的 Mobius 反演公式，让我想起了另一个经典的反演公式－－－二项式反演公式。然而本质上反演公式就是矩阵求逆的过程。只是他们的逆有很简单的形式，因此就有了这样两个反演公式而已。<br>]]>
    
    </summary>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="矩阵" scheme="http://dna049.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数论函数的 Dirichlet 积]]></title>
    <link href="http://dna049.com/2016/01/20/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0%E7%9A%84Dirichlet%E7%A7%AF/"/>
    <id>http://dna049.com/2016/01/20/数论函数的Dirichlet积/</id>
    <published>2016-01-20T12:09:26.000Z</published>
    <updated>2016-02-23T11:09:03.000Z</updated>
    <content type="html"><![CDATA[<p>最近重温潘承洞老先生的《数论基础》(现代数学基础丛书34)，确实是经典中的经典。以现代的眼光看数论函数，使得分析问题更加简洁本质，而这些都要归功于 Dirichlet 积的引入。<br><a id="more"></a></p>
<h3 id="u5E38_u89C1_u6570_u8BBA_u51FD_u6570"><a href="#u5E38_u89C1_u6570_u8BBA_u51FD_u6570" class="headerlink" title="常见数论函数"></a>常见数论函数</h3><p>为了更好的介绍 Dirichlet 积，先引入一些记号，数论函数是指定义于全体正整数集上的函数。</p>
<ol>
<li>$u(n) \equiv 1$ </li>
<li>$e(n) = n$</li>
<li><span>$I(n) = \left\{\begin{array}{ll} 1, &amp; n=1, \\ 0, &amp; n&gt;1. \end{array} \right.$</span><!-- Has MathJax --></li>
<li>n的所有正除数的个数 $d(n)$.<br>$$ d(n)= \sum_{d|n} 1 = (a_1+1)(a_2+1) \cdots (a_n+1), \; n=p_1^{a_1} \cdots p_s^{a_s} $$</li>
<li>n的全部素因子的个数（按重数计）$ \Omega(n) $<span>$$\begin{array}{ll} \Omega(1)=0 &amp; \\
\Omega(n) = a_1 + a_2+ \cdots a_n, &amp; n=p_1^{a_1} \cdots p_s^{a_s} \end{array}$$</span><!-- Has MathJax --></li>
<li>n的不同素因子的个数 $\omega(n)$  <span>$$\begin{array}{ll} \omega(1)=0 &amp; \\
\omega(n) = s, &amp; n=p_1^{a_1} \cdots p_s^{a_s} \end{array}$$</span><!-- Has MathJax --></li>
<li>n的正除数的幂和函数 $\sigma_{\lambda}(n)$,<span>$$\sigma_{\lambda}(n) = \sum_{d|n}
d^{\lambda}$$</span><!-- Has MathJax --></li>
<li>所有不超过n且和n互素的正整数的个数 $\phi(n)$<span>$$\phi(n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\
(d,n)=1 \end{array} } 1$$</span><!-- Has MathJax -->
$\phi(n)$ 称之为Euler函数。</li>
<li>Mobius 函数 $\mu(n)$<span>$$\mu(n) = \left\{\begin{array}{ll} 1, &amp; n=1, \\ (-1)^s, &amp; n=p_1p_2 \cdots p_s, \; p_1 &lt; p_2&lt; \cdots &lt; p_s. \\
0, &amp; else. \end{array} \right.$$</span><!-- Has MathJax --></li>
<li>Mangoldt函数 $\Lambda(n)$<span>$$\Lambda(n) = \left\{\begin{array}{ll} \log p, &amp; n= p^k, k \geq 1\\
0, &amp; else. \end{array} \right.$$</span><!-- Has MathJax --></li>
<li>Liouville 函数 $\lambda(n)$<br>$$ \lambda(n) = (-1)^{\Omega(n)} $$</li>
<li>Euler函数的推广(自创 dna0.49 ) $ \phi _{\lambda}(n)$<span>$$\phi _{\lambda} (n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\
(d,n)=1 \end{array} } d^{\lambda}$$</span><!-- Has MathJax -->
当 $\lambda = 0$ 时即为Euler函数。</li>
</ol>
<p>用下面的 Dirichlet 积的概念，大家就会对上面常见的数论函数有更深刻的认识。</p>
<h3 id="Dirichlet__u79EF"><a href="#Dirichlet__u79EF" class="headerlink" title="Dirichlet 积"></a>Dirichlet 积</h3><p>设$f(n)$,$g(n)$是两个数论函数，则<br>$$ h(n) = \sum_{d|n} f(d)g(\frac{n}{d}) $$<br>称为$f(n)$和$g(n)$的 Dirichlet 积,记作$h=f*g$.</p>
<h5 id="u5B9A_u7406_u4E00_Dirichlet__u79EF_u6EE1_u8DB3_u4EA4_u6362_u5F8B_u548C_u7ED3_u5408_u5F8B_u5373"><a href="#u5B9A_u7406_u4E00_Dirichlet__u79EF_u6EE1_u8DB3_u4EA4_u6362_u5F8B_u548C_u7ED3_u5408_u5F8B_u5373" class="headerlink" title="定理一 Dirichlet 积满足交换律和结合律即"></a>定理一 Dirichlet 积满足交换律和结合律即</h5><span>$$f * g = 
g * f$$</span><!-- Has MathJax -->
<span>$$(f*g)*h = 
f*(g*h)$$</span><!-- Has MathJax -->
<p>由定义上式显然。</p>
<h5 id="u5B9A_u7406_u4E8C_Dirichlet__u79EF_u7684_u5E7A_u5143_u5B58_u5728_u4E3A__24I_28n_29_24"><a href="#u5B9A_u7406_u4E8C_Dirichlet__u79EF_u7684_u5E7A_u5143_u5B58_u5728_u4E3A__24I_28n_29_24" class="headerlink" title="定理二 Dirichlet 积的幺元存在为 $I(n)$"></a>定理二 Dirichlet 积的幺元存在为 $I(n)$</h5><p>直接计算验算即知。</p>
<ul>
<li>由定理一和二知。数论函数全体关于 Dirichlet 积构成了一个含幺交换半群(Commutative Monoid) </li>
<li>由抽象代数的基本知识知道 Monoid 中的元如果存在逆元必然唯一，证明也是显然的 </li>
<li>现在的问题就是这个 Monoid 那些元有逆元( Dirichlet 逆，以下简称逆)。或者说一个数论函数可逆的充要条件是什么。</li>
</ul>
<p>实际上，我们有如下结论</p>
<h5 id="u5B9A_u7406_u4E09__u6570_u8BBA_u51FD_u6570__24f_24__u53EF_u9006_u7684_u5145_u8981_u6761_u4EF6_u662F__24f_281_29__5Cneq_0_24-_u6B64_u65F6_u5B83_u7684_u9006_u5143_u4E3A"><a href="#u5B9A_u7406_u4E09__u6570_u8BBA_u51FD_u6570__24f_24__u53EF_u9006_u7684_u5145_u8981_u6761_u4EF6_u662F__24f_281_29__5Cneq_0_24-_u6B64_u65F6_u5B83_u7684_u9006_u5143_u4E3A" class="headerlink" title="定理三 数论函数 $f$ 可逆的充要条件是 $f(1) \neq 0$.此时它的逆元为"></a>定理三 数论函数 $f$ 可逆的充要条件是 $f(1) \neq 0$.此时它的逆元为</h5><span>$$f^{-1} (1) = \frac{1}{f(1)},\quad
f^{-1} (n) = \frac{-1}{f(1)} \sum _{d|n,\, d&lt;n} f(\frac{n}{d})f^{-1}(d),\; n&gt;1$$</span><!-- Has MathJax -->
<p>证明是显然的，验算即知。</p>
<ul>
<li>至此从抽象的层次已经对数论函数的 Dirichlet 积有了一个清晰的认识，下面用这套语言考虑我们的常见函数 </li>
</ul>
<h5 id="u5B9A_u7406_u56DB_Mobius__u51FD_u6570__24_5Cmu_28n_29_24__u662F__24u_28n_29_24__u7684_u9006_u3002"><a href="#u5B9A_u7406_u56DB_Mobius__u51FD_u6570__24_5Cmu_28n_29_24__u662F__24u_28n_29_24__u7684_u9006_u3002" class="headerlink" title="定理四 Mobius 函数 $\mu(n)$ 是 $u(n)$ 的逆。"></a>定理四 Mobius 函数 $\mu(n)$ 是 $u(n)$ 的逆。</h5><p>即<br><span>$$\sum_{ d|n } \mu(n) = \left\{ \begin{array}{ll}  1, &amp; n=1, \\
0, &amp; n&gt;1. \end{array} \right.$$</span><!-- Has MathJax --></p>
<p>$n=1$ 时显然，不妨设 $n = p_1^{a_1} p_2^{a_2} \cdots p_s^{a_s}$ 则由 $\mu(n)$ 的定义<br><span>$$\begin{align}
\sum_{ d|n } \mu(n) &amp; = \mu(1) + \mu(p_1) + \mu(p_2) + \cdots +\mu(p_s) + \cdots + \mu(p_1 p_2) + \cdots \\
&amp; \quad + \mu(p_{s-1}p_s) + \cdots \mu(p_1 p_2 \cdots p_s) \\
&amp; =  1 + \begin{matrix} s \\ 1\end{matrix} (-1) + \begin{matrix} s \\ 2\end{matrix} (-1)^2 + \cdots + \begin{matrix} s \\ s\end{matrix} (-1)^s = (1-1)^s = 0 \end{align}$$</span><!-- Has MathJax --></p>
<ul>
<li>由此可见，原来看上去复杂的不知所以然的 Mobius 函数本质上是恒为1的函数的 Dirichlet 逆元。</li>
</ul>
<h5 id="u5B9A_u4E49_u4E94__u82E5__24F_3Df*u_24__u5219_u79F0_24F_24__u662F_24f_24__u7684_Mobius__u53D8_u6362_uFF0C_u5373"><a href="#u5B9A_u4E49_u4E94__u82E5__24F_3Df*u_24__u5219_u79F0_24F_24__u662F_24f_24__u7684_Mobius__u53D8_u6362_uFF0C_u5373" class="headerlink" title="定义五 若 $F=f*u$ 则称$F$ 是$f$ 的 Mobius 变换，即"></a>定义五 若 $F=f*u$ 则称$F$ 是$f$ 的 Mobius 变换，即</h5><p>$$ F(n) = \sum_{d|n} f(d) $$</p>
<p>显然此时我们有 $ f=F * \mu $,称$f$ 是$F$ 的 Mobius 反变换。<br>实际上，这就是我们常说的 Mobius 反演公式。<br><span>$$F(n) = \sum_{d|n} f(d) \Longleftrightarrow f(n) =
\sum_{d|n} F(d) \mu(\frac{n}{d})$$</span><!-- Has MathJax --></p>
<p>Mobius 变换的例子</p>
<ol>
<li>$I(n)$ 是 $\mu(n)$ 的 Mobius 变换</li>
<li>$d(n)$ 是 $u(n)$ 的 Mobius 变换</li>
<li>$e(n)$ 是 $\phi(n)$ 的 Mobius 变换</li>
<li>$\log n$ 是 $\Lambda(n)$ 的 Mobius 变换</li>
</ol>
<p>前两个是显然的，后面两个证明如下。</p>
<span>$$n = \sum _{i=1} ^n 1 = 
\sum _{d|n} \sum_{(n,i) = d} 1 =
\sum _{d|n} \sum_{(\frac{n}{d},k)=1} 1 =
\sum _{d|n} \phi(\frac{n}{d}) = \sum _{d|n} \phi(d)$$</span><!-- Has MathJax -->
<p>因此<br><span>$$\phi(n) = \sum _{d|n} \mu(d) \frac{n}{d} =
n \sum _{d|n} \frac{\mu(d)}{d}$$</span><!-- Has MathJax --><br>另外我们还有一个证明方式</p>
<span>$$\phi(n) = \sum_{ \begin{array}{c} 1 \leq d \leq n \\
(d,n)=1 \end{array} } 1 ＝ \sum_{1 \leq d \leq n} \sum_ {l|(d,n)} \mu(l) = \sum _{l|n} \mu(l) \sum _{1 \leq d \leq n , l|d} 1 = \sum _{l|n} \mu(l) \frac{n}{l}$$</span><!-- Has MathJax -->
<ul>
<li>上述两种证明都是两种常用处理数论函数的技术手段。</li>
</ul>
<p>至于 $\log n$ 是 $\Lambda(n)$ 的 Mobius 变换的证明只需验算即知。</p>
<p>用上面所说的技术，我们来考虑一下推广的Euler函数 $\phi _{\lambda}$</p>
<span>$$\sum _{i=1} ^n i^{\lambda} = 
\sum _{d|n} \sum_{(n,i) = d} i^{\lambda}  =
\sum _{d|n} d^{\lambda} \sum_{(\frac{n}{d},k)=1} k^{\lambda}  = 
\sum _{d|n} d^{\lambda} \phi _{\lambda} (\frac{n}{d}) = 
n^{\lambda} * \phi _{\lambda}$$</span><!-- Has MathJax -->
<h5 id="u53EF_u4E58_u51FD_u6570"><a href="#u53EF_u4E58_u51FD_u6570" class="headerlink" title="可乘函数"></a>可乘函数</h5><p>寻找不变量一直是数学关心的问题，变化中的不变量，可以大大简化运算，并且反过来刻画了变化。具体说，寻找 Dirichlet 积不变量一方面对于那些不变量，可以简化它们操作，另一方面，由于 Dirichlet 积保持这些性质也就刻画了 Dirichlet 本身。其中这样的一个不变量就是可乘函数。</p>
<p>设 $f(n)$ 是定义在全体自然数上不恒为0的数论函数，若它满足条件<br>$$ f(mn) = f(m) f(n), \quad (m,n)=1 $$<br>则称之为可乘函数。若对任意正整数 $m,n$ 恒有<br>$$ f(mn) = f(m) f(n) $$<br>则称之为完全可乘函数。</p>
<p>可乘函数例子：    $\mu(n)$, $d(n)$.<br>完全可乘函数例子：    $n^{\lambda}$, $I(n)$.</p>
<ul>
<li>显然(完全)可乘函数的的积，倒数(如果有意义的话)都是(完全)可乘函数。</li>
</ul>
<h5 id="u5B9A_u7406_u516D__u53EF_u4E58_u51FD_u6570__24f_28n_29_24__u6709_u5982_u4E0B_u6027_u8D28_uFF1A"><a href="#u5B9A_u7406_u516D__u53EF_u4E58_u51FD_u6570__24f_28n_29_24__u6709_u5982_u4E0B_u6027_u8D28_uFF1A" class="headerlink" title="定理六 可乘函数 $f(n)$ 有如下性质："></a>定理六 可乘函数 $f(n)$ 有如下性质：</h5><ol>
<li>$f(1)=1$</li>
<li>$f(n)=f(p_1^{a_1}) f(p_2)^{a_2} \cdots f(p_s)^{a_s}, \quad n = p_1^{a_1} p_2^{a_2} \cdots p_s^{a_s}$</li>
<li>$f(n)$ 为完全可乘的充要条件是对任意的 $p$ 和 $k \geq 1$ 恒有<br> $$ f(p^k) = f ^k (p) $$</li>
<li>$f((m,n)[m,n])=f(m)f(n)$</li>
<li>$f$的逆元必然存在(形式上更加简单)</li>
</ol>
<p>上述定理的证明是显然的，结论是重要的。</p>
<h5 id="u5B9A_u7406_u4E03_Dirchlet__u79EF__u4FDD_u6301_u53EF_u4E58_u6027"><a href="#u5B9A_u7406_u4E03_Dirchlet__u79EF__u4FDD_u6301_u53EF_u4E58_u6027" class="headerlink" title="定理七 Dirchlet 积 保持可乘性"></a>定理七 Dirchlet 积 保持可乘性</h5><ol>
<li>若 $f$ 可乘, $g$ 可乘, 则 <span>$h=f*g$</span><!-- Has MathJax --> 可乘;</li>
<li>若 $g$ 可乘, <span>$h=f*g$</span><!-- Has MathJax --> 可乘，则 $f$ 可乘.</li>
</ol>
<p>Proof: </p>
<ol>
<li><p>若 $f$ 可乘, $g$ 可乘, 则对任意满足 $(m,n)=1$ 的正整数 $m,n$,对于 $mn$ 的每一个正因子 $d$ 可以分解为 $d=d_1 d_2$ 的形式, 其中$(d_1,d_2)=1,d_1|m,d_2|n$ </p>
<span>$$h(mn) = \sum _{d|mn} f(d)g(\frac{mn}{d}) =
\sum _{d_1|m} f(d_1)g(\frac{m}{d_1}) \sum _{d_2|n} f(d_2)g(\frac{n}{d_2}) = h(m)h(n)$$</span><!-- Has MathJax -->
</li>
<li><p>反证，若$f$不可乘，则可以推出$h$不可乘即可。若$f$不可乘,则必存在$m,n$,$(m,n)=1$ 但是<br>$$ f(mn) \neq f(m)f(n) $$<br>若 $mn=1$ , 则 $f(1) \neq f(1) f(1)$ 知 $f(1) \neq 1$. 因此 $h(1)=f(1)g(1)=f(1) \neq 1$ 矛盾于$h$可乘。<br>我们选取满足上述性质的最小正整数$mn$,即当$d_1d_2&lt;mn$是恒有<br>$$ f(d_1d_2) = f(d_1)f(d_2),\quad (d_1,d_2)=1 $$<br>由$h$的定义</p>
<span>$$\begin{align}
h(mn) = \sum _{d|mn} f(d) g(\frac{mn}{d}) &amp; = 
\sum _{d_1|m} f(d_1) g(\frac{m}{d_1}) \sum _{d_2|m} f(d_2)g(\frac{n}{d_2})-f(m)f(n) +f(mn) \\
&amp; = h(m)h(n) -f(m)f(n) + f(mn) \neq h(m)h(n)
\end{align}$$</span><!-- Has MathJax -->
<p>证毕。</p>
</li>
</ol>
<ul>
<li>Dirichlet 积一般不保持完全可乘性。</li>
</ul>
<p>由定理六和七，我们有如下推论: 若 $F$ 是 $f$ 的 Mobius 变换，则</p>
<ol>
<li>$f$ 可乘 $\Longleftrightarrow$ $F$ 可乘</li>
<li>$f$ 可乘，则<span>$$F(n) = \sum_{d|n} f(d) = 
\prod _{p^a || n} (1+ f(p)+\cdots f(p^a))$$</span><!-- Has MathJax --></li>
<li>$f$ 可乘，则 <span>$$\sum _{d|n} \mu(d) f(d) = 
\prod _{p | n} (1 - f(p))$$</span><!-- Has MathJax -->
</li>
</ol>
<ul>
<li>上面1是定理7.1的直接推论，2可由定理6.2的直接推论，3是2的直接推论。由3我们可以得到著名的欧拉公式：<span>$$\phi(n) = n \sum _{d|n} \frac{\mu(d)}{d} ＝ 
n \prod _{p|n} (1-\frac{1}{p})$$</span><!-- Has MathJax -->
</li>
</ul>
<h4 id="u5B8C_u5168_u53EF_u4E58_u7684_u9006"><a href="#u5B8C_u5168_u53EF_u4E58_u7684_u9006" class="headerlink" title="完全可乘的逆"></a>完全可乘的逆</h4><p>由于可乘函数满足 $f(1)=1$ 因此可乘函数的逆相对而言更加简单，并且它的逆也是可乘函数。但是计算逆的过程仍然很复杂，但是完全可乘函数的逆却特别简单。</p>
<h5 id="u5B9A_u7406_u516B__u8BBE__24f_24__u53EF_u4E58_uFF0C_u5219_24f_24__u5B8C_u5168_u53EF_u4E58_u7684_u5145_u8981_u6761_u4EF6_u662F"><a href="#u5B9A_u7406_u516B__u8BBE__24f_24__u53EF_u4E58_uFF0C_u5219_24f_24__u5B8C_u5168_u53EF_u4E58_u7684_u5145_u8981_u6761_u4EF6_u662F" class="headerlink" title="定理八 设 $f$ 可乘，则$f$ 完全可乘的充要条件是"></a>定理八 设 $f$ 可乘，则$f$ 完全可乘的充要条件是</h5><p>$$ f^{-1}(n) = \mu(n)f(n) $$<br>应用定理6.3验证即知。</p>
<h5 id="u63A8_u5E7F_u7684Mobius_u53CD_u6F14_u516C_u5F0F"><a href="#u63A8_u5E7F_u7684Mobius_u53CD_u6F14_u516C_u5F0F" class="headerlink" title="推广的Mobius反演公式"></a>推广的Mobius反演公式</h5><p>设 $g$ 完全可乘, <span>$h= f * g$</span><!-- Has MathJax --> ,则<span>$f= h * \mu g$</span><!-- Has MathJax --> ,即<br><span>$$h(n) = \sum _{d|n} f(d)g(\frac{n}{d})
\quad \Longleftrightarrow \quad f(n) = \sum _{d|n} h(d)
\mu(\frac{n}{d})g(\frac{n}{d})$$</span><!-- Has MathJax --></p>
<p>另上式中 $g=u$ ，上式就变成了Mobius反演公式。<br>由推广的Mobius反演公式，我们由<br><span>$$\sum _{i=1} ^n i^{\lambda} = 
n^{\lambda} * \phi _{\lambda}$$</span><!-- Has MathJax --><br>可知<br><span>$$\phi _{\lambda}(n) =
\sum _{i=1} ^n i^{\lambda} * \mu(n) n^{\lambda}$$</span><!-- Has MathJax -->  </p>
<h5 id="u4E09_u4E2A_u4F18_u7F8E_u516C_u5F0F"><a href="#u4E09_u4E2A_u4F18_u7F8E_u516C_u5F0F" class="headerlink" title="三个优美公式"></a>三个优美公式</h5><p>最后我用三个我很喜欢的公式结束这篇博文。</p>
<ol>
<li><span>$\sum _{n \leq x} d(n) = \sum _{n \leq x} \lfloor \frac{x}{n} \rfloor$</span><!-- Has MathJax -->
</li>
</ol>
<span>$$\sum _{n \leq x} \lfloor \frac{x}{n} \rfloor = 
\sum _{n \leq x} \sum _{l \leq x,\; n|l} 1 = 
\sum _{l \leq x} \sum _{n|l} 1 =
\sum _{l \leq x} d(l) =
\sum _{n \leq x} d(n)$$</span><!-- Has MathJax -->
<ol>
<li><span>$\sum _{n \leq x} \mu(n) \lfloor \frac{x}{n} \rfloor = 1$</span><!-- Has MathJax -->
</li>
</ol>
<span>$$\sum _{n \leq x} \mu(n) \lfloor \frac{x}{n} \rfloor =
\sum _{n \leq x} \mu(n) \sum _{l \leq x,\; n|l} 1 =
\sum _{l \leq x} \sum _{n|l} \mu(n) = \sum _{l \leq x} I(n) =
= 1$$</span><!-- Has MathJax -->
<ol>
<li><span>$\sum _{n=1} ^{\infty} \frac{\mu(n)}{n^2} = \frac{6}{\pi^2}$</span><!-- Has MathJax -->
</li>
</ol>
<span>$$\sum _{n=1} ^{\infty} \frac{1}{n^2} \sum _{n=1} ^{\infty} \frac{\mu(n)}{n^2} =
\sum _{n=1} ^{\infty} \frac{a_n}{n^2}$$</span><!-- Has MathJax -->
<p>其中<br><span>$$a_n = 
\sum _{d|n} \mu(d) = I(n)$$</span><!-- Has MathJax --><br>又由<br><span>$$\sum _{n=1} ^{\infty} \frac{1}{n^2} = 
\frac{\pi^2}{6}$$</span><!-- Has MathJax --><br>结论显然。</p>
<p>该博文大多资料来自 潘承洞《数论基础》，转载请注明<a href="http://dna049.com">http://dna049.com</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近重温潘承洞老先生的《数论基础》(现代数学基础丛书34)，确实是经典中的经典。以现代的眼光看数论函数，使得分析问题更加简洁本质，而这些都要归功于 Dirichlet 积的引入。<br>]]>
    
    </summary>
    
      <category term="Dirichlet" scheme="http://dna049.com/tags/Dirichlet/"/>
    
      <category term="数论" scheme="http://dna049.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
</feed>
